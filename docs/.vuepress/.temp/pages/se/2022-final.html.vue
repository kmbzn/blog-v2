<template><div><h1 id="_2022년-기말고사" tabindex="-1"><a class="header-anchor" href="#_2022년-기말고사"><span>2022년 기말고사</span></a></h1>
<h3 id="_1-다음-요구사항과-컨셉-모델을-보고-물음에-답하시오-20점" tabindex="-1"><a class="header-anchor" href="#_1-다음-요구사항과-컨셉-모델을-보고-물음에-답하시오-20점"><span>1. 다음 요구사항과 컨셉 모델을 보고 물음에 답하시오. (20점)</span></a></h3>
<ul>
<li>당신의 팀은 요청한 인쇄 매수에 따라 금액을 투입하면 인쇄가 되는 시스템을 구축하고자 한다. 기능 요구사항은 크게 3개로 정리할 수 있다.</li>
</ul>
<ol>
<li>사용자를 계정별로 관리한다.
<ul>
<li>계정은 사용자가 원하는 대로 생성할 수 있고 사용자 계정은 id/pw 와 잔액 정보를 가진다.</li>
<li>계정별로 잔액을 충전할 수 있다.</li>
</ul>
</li>
<li>인쇄는 1장당 100원의 요금을 받는다.
<ul>
<li>인쇄 진행 시 계정 잔액에서 필요한 만큼 차감한다.</li>
</ul>
</li>
<li>관리자는 프린터의 정보 및 계정 정보를 확인할 수 있다.
<ul>
<li>용지 부족 시 이에 대한 알림을 준다.</li>
<li>부족한 용지를 보충할 수 있다.</li>
<li>계정 목록 및 잔액을 확인할 수 있다.</li>
</ul>
</li>
</ol>
<ul>
<li>그 중 사용자의 인쇄 요청의 상세 유즈케이스는 다음과 같다.</li>
</ul>
<table>
<thead>
<tr>
<th>항목</th>
<th>내용</th>
</tr>
</thead>
<tbody>
<tr>
<td>Use Case</td>
<td>인쇄 요청</td>
</tr>
<tr>
<td>Actor</td>
<td>사용자</td>
</tr>
<tr>
<td>목적</td>
<td>사용자의 요청을 받아 인쇄를 진행한다.</td>
</tr>
<tr>
<td>개요</td>
<td>사용자의 요청을 받아 입력된 매수만큼 인쇄를 진행한다.</td>
</tr>
<tr>
<td>선행조건</td>
<td>사용자는 이미 로그인 된 상태이다.</td>
</tr>
<tr>
<td>성공 시나리오</td>
<td>1. 화면에 필요 인쇄 매수를 입력한다.<br>2. 인쇄 버튼을 누른다.<br>3. 매수에 따른 요금을 계산한다.<br>4. 계좌 잔액을 비교한다<br>5. 프린터의 잔여 용지를 인쇄 매수만큼 감소시킨다<br>6. 매출액을 인쇄 금액만큼 증가시킨다<br>7. 사용자 잔액을 인쇄 금액만큼 감소시킨다<br>8. 프린터에 인쇄 명령을 내린다</td>
</tr>
<tr>
<td>예외상황</td>
<td>3-E. 인쇄 매수가 <span v-pre class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>보다 작거나 같으면 에러를 표시하고 종료한다<br>4-E. 잔액이 부족하면 에러를 표시하고 종료한다.<br>5-E. 잔여 용지가 부족하면 에러를 표시하고 종료한다.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em>(그림 1. 인쇄 관리 시스템 컨셉 모델 다이어그램)</em>
<img src="@source/se/image-86.png" alt="alt text"></p>
</blockquote>
<ol>
<li>그림 1의 컨셉 모델과 요구사항 및 인쇄 요청 유즈케이스를 보고 디자인 모델의 클래스 다이어그램을 작성하시오. (10점)</li>
</ol>
<p><img src="@source/se/image-83.png" alt="alt text">
2. 인쇄 요청 유즈케이스에 대한 시퀀스 다이어그램을 작성하시오. (10점)</p>
<p><img src="@source/se/image-90.png" alt="alt text"></p>
<h3 id="_2-디자인-패턴에-대한-다음-질문에-답하시오-15점" tabindex="-1"><a class="header-anchor" href="#_2-디자인-패턴에-대한-다음-질문에-답하시오-15점"><span>2. 디자인 패턴에 대한 다음 질문에 답하시오. (15점)</span></a></h3>
<ol>
<li>Decorator 패턴과 Strategy 패턴의 클래스 다이어그램을 그리고 각 패턴의 목적과 간단한 사용예를 설명하시오 (10점)</li>
</ol>
<blockquote>
<p>Decorator 패턴: 이 패턴은 객체의 코드를 변경하지 않고도 실행 중에 필요한 기능을 유연하게 덧붙여 확장하기 위해 사용합니다.<br>
간단한 사용 예: 자바의 I/O 기능에서 기본 파일 읽기 객체에 버퍼링 기능을 추가하기 위해 BufferedReader로 감싸는 것이 대표적인 예입니다.
<img src="@source/se/image-84.png" alt="alt text"></p>
</blockquote>
<blockquote>
<p>Strategy 패턴: 이 패턴은 유사한 기능을 수행하는 여러 알고리즘을 각각 독립된 클래스로 캡슐화하여, 필요에 따라 알고리즘을 쉽게 교체해서 사용하기 위해 사용합니다.<br>
간단한 사용 예: 쇼핑몰 결제 시스템에서 사용자가 신용카드, 카카오페이, 무통장 입금 중 하나의 결제 방식을 선택하여 처리하는 것이 대표적인 예입니다.
<img src="@source/se/image-85.png" alt="alt text"></p>
</blockquote>
<ol start="2">
<li>Decorator 패턴과 Strategy 패턴의 유사점과 차이점을 설명하시오. (5점)
<ul>
<li>두 패턴의 유사점은 상속보다는 구성(Composition)과 위임(Delegation)을 통해 객체의 행위를 결정한다는 점이다. 또한 인터페이스나 추상 클래스를 통해 다형성을 활용하여 실행 시점에 행동을 변경할 수 있다는 점이 비슷하다.</li>
<li>차이점은 그 목적과 구조적 변경 범위에 있다. Decorator 패턴은 객체의 겉모양(Skin)을 변경하여 부가적인 기능을 '추가'하는 것이 주 목적이며 여러 개의 데코레이터를 중첩할 수 있다. 반면 Strategy 패턴은 객체의 내부(Guts) 로직인 알고리즘 자체를 완전히 '교체'하는 것이 목적이며, 일반적으로 한 번에 하나의 전략만 사용한다.</li>
</ul>
</li>
</ol>
<h3 id="_3-당신은-10명-규모로-구성된-신규-프로젝트를-진행하는-개발-팀을-이끄는-팀장이다-팀원간의-개발-내역을-공유하기-위해-저장소로-git을-사용한다고-할-때-다음-물음에-답하시오-15점" tabindex="-1"><a class="header-anchor" href="#_3-당신은-10명-규모로-구성된-신규-프로젝트를-진행하는-개발-팀을-이끄는-팀장이다-팀원간의-개발-내역을-공유하기-위해-저장소로-git을-사용한다고-할-때-다음-물음에-답하시오-15점"><span>3. 당신은 10명 규모로 구성된 신규 프로젝트를 진행하는 개발 팀을 이끄는 팀장이다. 팀원간의 개발 내역을 공유하기 위해 저장소로 git을 사용한다고 할 때 다음 물음에 답하시오. (15점)</span></a></h3>
<ol>
<li>
<p>당신의 팀에서 어떤 git 브랜치 전략을 사용할 것인지 서술하시오. 각 브랜치의 용도와 브랜치 사이의 관계를 명확하게 서술해야 한다 (8점)</p>
<ul>
<li>10명 규모의 신규 프로젝트라면 체계적인 버전 관리를 위해 'Git Flow' 전략을 사용하는 것이 적합하다. 이 전략은 5가지 종류의 브랜치를 운용한다.</li>
</ul>
<ol>
<li><code v-pre>master</code> 브랜치는 제품으로 출시될 수 있는 안정된 상태의 코드를 관리한다.</li>
<li><code v-pre>develop</code> 브랜치는 다음 출시 버전을 개발하는 통합 브랜치로, 개발자들의 코드가 이곳으로 모인다.</li>
<li><code v-pre>feature</code> 브랜치는 <code v-pre>develop</code>에서 분기하여 단위 기능을 개발하는 곳이며 완성되면 다시 <code v-pre>develop</code>으로 병합한다.</li>
<li><code v-pre>release</code> 브랜치는 <code v-pre>develop</code>에서 배포 시점이 다가오면 생성하여 QA 및 버그 수정을 수행하고 최종적으로 <code v-pre>master</code>와 <code v-pre>develop</code>에 병합한다.</li>
<li><code v-pre>hotfix</code> 브랜치는 배포된 버전에서 긴급한 버그가 발생했을 때 <code v-pre>master</code>에서 분기하여 수정 후 병합한다.</li>
</ol>
</li>
<li>
<p>소프트웨어 코드 품질을 높게 유지하기 위해 각 개발자의 코드를 팀 브랜치에 머지할 때 QA 기술을 적용하고자 한다. 어떤 QA 기술을 적용하는게 좋을 것인가? 2개 이상의 기술을 제시하고 해당 기술을 어떻게 적용할 수 있을지, 그리고 어떤 장점이 있는지 서술하시오 (7점)</p>
</li>
<li>
<p>정적 분석(Static Analysis) 도구를 적용한다. 코드가 머지되기 전에 린트(Lint) 도구나 SonarQube 등을 통해 코딩 컨벤션 준수 여부, 잠재적인 버그 패턴, 코드 복잡도 등을 자동으로 검사한다. 이를 통해 코드의 스타일을 통일하고 실행 전 발견 가능한 오류를 사전에 제거하여 리뷰 효율을 높일 수 있다.</p>
</li>
<li>
<p>자동화된 단위 테스트(Automated Unit Testing)와 CI(지속적 통합)를 적용한다. 개발자가 코드를 푸시하고 풀 리퀘스트를 생성하면 CI 서버가 자동으로 테스트 코드를 실행한다. 이는 새로운 코드가 기존 기능을 망가뜨리지 않는지(회귀 테스트) 즉시 확인함으로써 시스템의 안정성을 보장한다.</p>
</li>
</ol>
<h3 id="_4-다음-qa-기술들에-대한-질문에-답하시오-15점" tabindex="-1"><a class="header-anchor" href="#_4-다음-qa-기술들에-대한-질문에-답하시오-15점"><span>4. 다음 QA 기술들에 대한 질문에 답하시오. (15점)</span></a></h3>
<ol>
<li>Formal inspection과 (modern) Code Review에 대해 각각의 장, 단점을 비교하고 각각 어떤 상황에 도입할 수 있을지 서술하시오. (8점)
<ul>
<li>Formal Inspection(정형 기술 검토)은 중재자, 낭독자, 기록자 등 명확한 역할과 절차를 가지고 대면 회의를 통해 진행된다. 장점은 초기 단계에서 결함을 아주 깊이 있게 찾아낼 수 있다는 점이나, 단점은 준비와 진행에 많은 시간과 비용이 든다. 따라서 항공 우주나 의료 기기 등 사람의 생명과 직결되는 안전 최우선(Safety-critical) 시스템 개발에 도입하기 적합하다.</li>
<li>Modern Code Review(최신 코드 리뷰)는 GitHub의 Pull Request와 같이 도구를 사용하여 비동기적으로 진행된다. 장점은 절차가 간편하여 자주 수행할 수 있고 지식 공유가 활발히 일어난다는 점이나, 단점은 검토의 깊이가 얕아질 수 있다. 일반적인 웹 서비스나 앱 개발 등 빠른 배포 주기를 가진 프로젝트에 도입하기 적합하다.</li>
</ul>
</li>
<li>Static analysis의 false positive와 false negative에 대해 설명하고 왜 static analysis에서 false positive와 false negative를 완벽하게 제거할 수 없는지 설명하시오. (7점)
<ul>
<li>False Positive(오탐)는 실제로는 오류가 없는데 도구가 오류가 있다고 보고하는 것이고, False Negative(미탐)는 실제로 오류가 있는데 도구가 이를 찾아내지 못하는 것이다.</li>
<li>이러한 현상을 완벽하게 제거할 수 없는 근본적인 이유는 '정지 문제(Halting Problem)'와 같은 계산 이론적 한계 때문이다. 프로그램이 실행되지 않은 상태에서 모든 가능한 실행 경로와 데이터 상태를 완벽하게 예측하여 판별하는 것은 수학적으로 불가능하다(Undecidable). 따라서 정적 분석 도구는 정확성을 일부 희생하고 근사(Approximation)를 통해 결과를 도출할 수밖에 없으므로 오탐이나 미탐이 발생하게 된다.</li>
</ul>
</li>
</ol>
<h3 id="_5-소프트웨어-테스팅에-대한-다음-질문에-답하시오-15점" tabindex="-1"><a class="header-anchor" href="#_5-소프트웨어-테스팅에-대한-다음-질문에-답하시오-15점"><span>5. 소프트웨어 테스팅에 대한 다음 질문에 답하시오. (15점)</span></a></h3>
<ol>
<li>
<p>소프트웨어 테스팅에서 자동화가 왜 중요한가? 자동화를 하지 않았을 때의 단점과 자동화를 했을 때의 장점을 비교해서 서술하시오. (8점)</p>
<ul>
<li>소프트웨어 테스팅에서 자동화가 중요한 핵심 이유는 '반복적인 테스트의 효율성' 때문이다.</li>
<li>자동화를 하지 않았을 때(수동 테스트)는 사람이 일일이 테스트를 수행해야 하므로 속도가 느리고 비용이 많이 들며, 테스터의 피로도로 인해 실수가 발생할 수 있다. 특히 코드가 수정될 때마다 수행해야 하는 회귀 테스트를 매번 수동으로 하기는 현실적으로 불가능에 가깝다.</li>
<li>반면 자동화를 했을 때는 초기 구축 비용은 들지만, 한번 작성된 스크립트는 무한히 반복 실행이 가능하여 장기적으로 비용이 절감된다. 또한, 사람의 개입 없이 언제나 동일한 정밀도로 빠르게 테스트를 수행할 수 있어 잦은 배포와 통합(CI/CD)을 가능하게 하는 기반이 된다.</li>
</ul>
</li>
<li>
<p>소프트웨어 품질 요구사항 중에서는 자동화된 테스팅으로 검사하기 힘든 요구사항이 있어서 매뉴얼 테스팅을 같이 사용해야 한다. 이와 같은 요구사항은 어떤 것이 있고 어떤 테스트 방법을 적용할 수 있는지 예를 들어 설명하시오. (7점)</p>
<ul>
<li>자동화된 테스팅으로 검사하기 힘든 대표적인 요구사항은 '사용성(Usability)'이나 '감성 품질'과 관련된 비기능적 요구사항이다. 예를 들어 &quot;사용자 인터페이스가 직관적이어야 한다&quot;거나 &quot;색상 배합이 눈에 편안해야 한다&quot;와 같은 주관적인 기준은 코드로 검증하기 어렵다. 또한 IoT 기기처럼 물리적인 하드웨어 조작(버튼 누름, 센서 인식 등)이 필요한 경우도 완전 자동화가 어렵다.</li>
<li>이러한 경우에는 사람이 직접 제품을 사용해보며 평가하는 '사용성 테스트(Usability Testing)'나, 숙련된 테스터가 정해진 시나리오 없이 탐색적으로 결함을 찾는 '탐색적 테스팅(Exploratory Testing)' 방법을 매뉴얼로 적용해야 한다.</li>
</ul>
</li>
</ol>
<h3 id="_6-다음-주어진-코드에-데이터-흐름-data-flow-정적-분석을-적용하여-0으로-나누는-연산이-발생하는지-분석하고자-한다-이-때-다음-질문에-답하시오-단-x-y-z는-정수-타입이-아닌-일반적인-숫자-타입이라고-가정한다-20점" tabindex="-1"><a class="header-anchor" href="#_6-다음-주어진-코드에-데이터-흐름-data-flow-정적-분석을-적용하여-0으로-나누는-연산이-발생하는지-분석하고자-한다-이-때-다음-질문에-답하시오-단-x-y-z는-정수-타입이-아닌-일반적인-숫자-타입이라고-가정한다-20점"><span>6. 다음 주어진 코드에 데이터 흐름 (data-flow) 정적 분석을 적용하여 0으로 나누는 연산이 발생하는지 분석하고자 한다. 이 때 다음 질문에 답하시오. (단, x, y, z는 정수 타입이 아닌 일반적인 숫자 타입이라고 가정한다) (20점)</span></a></h3>
<ul>
<li><em>(2024년 4번 문제에 그대로 출제되었으므로 생략)</em></li>
</ul>
</div></template>


