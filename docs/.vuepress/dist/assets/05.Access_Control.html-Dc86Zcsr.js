import{_ as l,c as i,a as s,o as a}from"./app-BJB3lIex.js";const t={};function o(c,e){return a(),i("div",null,[...e[0]||(e[0]=[s('<h1 id="_05-access-control" tabindex="-1"><a class="header-anchor" href="#_05-access-control"><span>05. Access Control</span></a></h1><h2 id="access-control" tabindex="-1"><a class="header-anchor" href="#access-control"><span>Access Control</span></a></h2><p><code>ITU-T Recommendation X.800</code>이 정의한 access control(접근 제어)</p><blockquote><p>resource의 무단 사용 방지를 포함하여, 승인되지 않은 방식으로 resource를 사용하는 것을 방지하는 것</p></blockquote><h2 id="access-control-principles" tabindex="-1"><a class="header-anchor" href="#access-control-principles"><span>Access Control Principles</span></a></h2><p><code>RFC 2828</code>이 정의한 computer security(컴퓨터 보안)</p><blockquote><p>컴퓨터 시스템에서 보안 서비스를 구현하고 보증하는 조치, 특히 접근 제어 서비스를 보증하는 조치</p></blockquote><h2 id="relationship-among-access-control-and-other-security-functions" tabindex="-1"><a class="header-anchor" href="#relationship-among-access-control-and-other-security-functions"><span>Relationship Among Access Control and Other Security Functions</span></a></h2><ul><li>access control은 authentication(인증) 및 audit(감사)과 밀접하게 관련</li><li>인증은 사용자의 신원을 확인하고, access control은 확인된 사용자가 특정 resource에 접근할 수 있는지 여부를 결정</li><li>Auditing 기능은 접근 시도를 기록하여 보안 policy 준수 여부를 확인하고 침입을 탐지</li></ul><h2 id="access-control-policies" tabindex="-1"><a class="header-anchor" href="#access-control-policies"><span>Access Control Policies</span></a></h2><ul><li>Discretionary Access Control(임의 접근 제어, DAC): resource의 소유자가 다른 subject에 대한 접근 권한을 설정</li><li>Mandatory Access Control(강제 접근 제어, MAC): 시스템 전반의 policy에 따라 접근 권한이 중앙에서 관리됨.</li><li>Role-Based Access Control(role 기반 접근 제어, RBAC): 사용자의 조직 내 role에 따라 접근 권한을 부여</li></ul><h2 id="access-control-requirements" tabindex="-1"><a class="header-anchor" href="#access-control-requirements"><span>Access Control Requirements</span></a></h2><ul><li>Reliable input(신뢰 가능한 입력)</li><li>Support for fine and coarse specifications(세밀하고 포괄적인 명세 지원)</li><li>Least privilege(최소 권한)</li><li>Separation of duty(직무 분리) <ul><li>하나의 작업을 완료하기 위해 <strong>두 명 이상</strong>이 필요</li></ul></li><li>Open and closed policies(개방 및 폐쇄 policy)</li><li>Policy combinations and conflict resolution(policy 조합 및 충돌 해결)</li><li>Administrative policies(관리 policy) <ul><li>policy 개발 절차 등...</li></ul></li></ul><h2 id="access-control-basic-elements" tabindex="-1"><a class="header-anchor" href="#access-control-basic-elements"><span>Access Control Basic Elements</span></a></h2><ul><li>Subject(주체): object에 접근할 수 있는 entity <ul><li>process(process)의 개념과 동일</li><li>일반적으로 자신이 시작한 행동에 대해 책임이 있음.</li><li>종종 owner(소유자), group(그룹), world(월드)의 세 가지 class를 가짐.</li></ul></li><li>Object(객체): 접근이 control되는 resource(자원) <ul><li>정보를 포함 and/or 수신하는 데 사용되는 entity</li><li>보호는 access control이 작동하는 환경에 따라 달라짐.</li></ul></li><li>Access right(접근 권한): subject가 object에 접근하는 방식을 기술 <ul><li>예: read(읽기), write(쓰기), execute(실행), delete(삭제), create(생성), search(검색)</li></ul></li></ul><h2 id="mandatory-access-control" tabindex="-1"><a class="header-anchor" href="#mandatory-access-control"><span>Mandatory Access Control</span></a></h2><ul><li>MAC(강제 접근 제어)는 더 제한적인 방식</li><li>소유권과 관계없이 사용자가 파일에 대한 권한을 정의하는 것을 허용하지 않음.</li><li>대신, 보안 결정은 central policy administrator(중앙 policy 관리자)에 의해 이루어짐.</li><li>각 보안 규칙은 접근을 시도하는 당사자를 나타내는 subject, 접근 대상 resource를 가리키는 object, 그리고 해당 resource에 접근할 수 있는 범위를 정의하는 일련의 권한으로 구성됨.</li><li>SELinux(Security-Enhanced Linux)는 MAC을 통합함.</li></ul><h2 id="selinux-and-mac" tabindex="-1"><a class="header-anchor" href="#selinux-and-mac"><span>SELinux and MAC</span></a></h2><ul><li>모든 process와 시스템 resource는 SELinux context(SELinux 컨텍스트, 또는 SELinux 레이블)라는 특별한 보안 레이블을 가짐.</li><li>SELinux policy은 이 context를 일련의 규칙에서 사용하여 process가 서로 및 다양한 시스템 resource과 상호 작용하는 방식을 정의함.</li><li>기본적으로, policy은 규칙이 명시적으로 접근을 허용하지 않는 한 어떠한 상호 작용도 허용하지 않음.</li><li>SELinux context는 user(사용자), role(role), type(유형), security level(보안 수준) 등 여러 field를 가짐.</li><li>가장 일반적인 policy 규칙이 전체 SELinux context가 아닌 SELinux 유형을 사용하기 때문에 SELinux 유형 정보가 SELinux policy에서 가장 중요할 수 있음.</li></ul><h2 id="discretionary-access-control-dac" tabindex="-1"><a class="header-anchor" href="#discretionary-access-control-dac"><span>Discretionary Access Control (DAC)</span></a></h2><ul><li>한 entity가 다른 entity에게 일부 resource에 접근할 수 있도록 허용하는 방식</li><li>종종 access matrix(접근 행렬)을 사용하여 제공됨. <ul><li>한 차원은 resource에 대한 데이터 접근을 시도할 수 있는 식별된 subject로 구성됨.</li><li>다른 차원은 접근될 수 있는 object를 나열함.</li></ul></li><li>행렬의 각 항목은 특정 subject가 특정 object에 대해 갖는 접근 권한을 나타냄.</li></ul><h2 id="access-matrix" tabindex="-1"><a class="header-anchor" href="#access-matrix"><span>Access Matrix</span></a></h2><ul><li>행은 subject(사용자, process)를 나타내고 열은 object(파일, 장치)를 나타냄.</li><li>행렬의 각 셀 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mtext> </mtext><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,~j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>는 subject <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>가 object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>에 대해 가질 수 있는 접근 권한(예: 읽기, 쓰기, 소유)을 명시함.</li></ul><h2 id="example-of-access-control-structures" tabindex="-1"><a class="header-anchor" href="#example-of-access-control-structures"><span>Example of Access Control Structures</span></a></h2><ul><li>Access matrix(접근 행렬): subject와 object 간의 모든 권한을 표로 나타냄.</li><li>Access Control Lists(접근 제어 목록, ACLs): object 중심. 각 object에 대해 어떤 subject가 어떤 권한을 갖는지 목록으로 관리 (access matrix의 열에 해당)</li><li>Capability Lists(능력 목록): subject 중심. 각 subject가 어떤 object에 대해 어떤 권한을 갖는지 목록으로 관리 (access matrix의 행에 해당)</li></ul><h2 id="extended-access-control-matrix" tabindex="-1"><a class="header-anchor" href="#extended-access-control-matrix"><span>Extended Access Control Matrix</span></a></h2><ul><li>기존 access matrix을 확장하여 조건부 access control을 포함할 수 있음.</li><li>예를 들어, 특정 subject가 object에 대한 권한을 다른 subject에게 copy(복사)하거나 owner(소유권)를 이전하는 권한, 또는 접근을 Audit(감사)하는 권한 등을 추가로 명시.</li></ul><h2 id="access-control-function" tabindex="-1"><a class="header-anchor" href="#access-control-function"><span>Access Control Function</span></a></h2><ul><li>사용자가 object에 대한 접근을 요청하면, Access Control Function(접근 제어 함수)이 요청을 가로챔.</li><li>이 function은 Access Control Policy을 참조하여 요청을 grant할지 deny할지 결정함.</li><li>결정 결과는 Audit File에 기록될 수 있음.</li></ul><h2 id="table-4-2-access-control-system-commands" tabindex="-1"><a class="header-anchor" href="#table-4-2-access-control-system-commands"><span>Table 4.2 Access Control System Commands</span></a></h2><table><thead><tr><th style="text-align:left;">명령</th><th style="text-align:left;">설명</th></tr></thead><tbody><tr><td style="text-align:left;"><code>grant(subject, right, object)</code></td><td style="text-align:left;">subject에게 object에 대한 권한을 부여</td></tr><tr><td style="text-align:left;"><code>revoke(subject, right, object)</code></td><td style="text-align:left;">subject로부터 object에 대한 권한을 회수</td></tr><tr><td style="text-align:left;"><code>create(subject, object)</code></td><td style="text-align:left;">subject가 object를 생성. 생성자는 소유자가 됨.</td></tr><tr><td style="text-align:left;"><code>delete(subject, object)</code></td><td style="text-align:left;">subject가 object를 삭제. 소유자만 가능.</td></tr><tr><td style="text-align:left;"><code>read(subject, attribute, object)</code></td><td style="text-align:left;">subject가 object의 속성을 읽음.</td></tr><tr><td style="text-align:left;"><code>write(subject, attribute, object)</code></td><td style="text-align:left;">subject가 object의 속성을 변경. 소유자만 가능.</td></tr></tbody></table><h2 id="protection-domains" tabindex="-1"><a class="header-anchor" href="#protection-domains"><span>Protection Domains</span></a></h2><ul><li>object와 그 object에 대한 접근 권한의 집합</li><li>protection domains(보호 도메인)과 능력을 연관시킬 때 더 큰 유연성을 제공</li><li>Access matrix 측면에서, 한 행은 보호 도메인을 정의함.</li><li>사용자는 자신의 접근 권한의 일부를 가진 process를 생성할 수 있음.</li><li>process와 도메인 간의 연관은 정적이거나 동적일 수 있음.</li><li>user mode(사용자 모드)에서는 특정 메모리 영역이 사용으로부터 보호되며 특정 명령어는 실행될 수 없음.</li><li>kernel mode(커널 모드)에서는 특권 명령어가 실행될 수 있으며 보호된 메모리 영역에 접근할 수 있음.</li></ul><h2 id="unix-file-access-control" tabindex="-1"><a class="header-anchor" href="#unix-file-access-control"><span>UNIX File Access Control</span></a></h2><ul><li>UNIX 파일은 i-nodes(아이노드, index nodes)를 사용하여 관리됨. <ul><li>특정 파일에 필요한 주요 정보가 있는 제어 구조</li><li>여러 파일 이름이 단일 inode와 연관될 수 있음.</li><li>활성 inode는 정확히 하나의 파일과 연관됨.</li><li>파일 속성, 권한 및 제어 정보는 inode에 저장됨.</li><li>디스크에는 파일 시스템의 모든 파일의 inode를 포함하는 inode 테이블 또는 inode 목록이 있음.</li><li>파일이 열리면 해당 inode가 주 메모리로 가져와져 메모리 상주 inode 테이블에 저장됨.</li></ul></li><li>directory는 계층적 트리 구조로 구성됨. <ul><li>파일 및/또는 다른 directory를 포함할 수 있음.</li><li>파일 이름과 연관된 inode를 가리키는 포인터를 포함함.</li></ul></li><li>user ID(고유 사용자 식별 번호, 사용자 ID)</li><li>그룹 ID로 식별되는 주 그룹의 멤버</li><li>특정 그룹에 속함.</li><li>12개의 보호 비트 <ul><li>파일의 소유자, 그룹 멤버, 그리고 다른 모든 사용자에 대한 읽기, 쓰기, 실행 권한을 명시</li></ul></li><li>소유자 ID, 그룹 ID, 보호 비트는 파일의 inode의 일부임.</li></ul><h2 id="traditional-unix-file-access-control" tabindex="-1"><a class="header-anchor" href="#traditional-unix-file-access-control"><span>Traditional UNIX File Access Control</span></a></h2><ul><li>&quot;set user ID&quot;(SetUID)</li><li>&quot;set group ID&quot;(SetGID) <ul><li>시스템이 access control decision을 내릴 때 실제 사용자의 권한에 더하여 파일 소유자/그룹의 권한을 일시적으로 사용함.</li><li>특권 프로그램이 일반적으로 접근할 수 없는 파일/resource에 접근할 수 있게 함.</li></ul></li><li>Sticky bit(스티키 비트) <ul><li>directory에 적용될 때, 해당 directory 내의 파일 소유자만이 파일을 재명명, 이동 또는 삭제할 수 있도록 지정하는 것</li><li><code>/tmp</code> directory는 누구나 파일을 생성하고 삭제 가능한데, linux를 공동으로 여러 사용과 사용할 때 quater가 정해져 있는데, tmp directory는 system reboot될 때 다 삭제됨. <code>f1</code>라는 파일을 생성했는데, 다른 사용자가 파일을 삭제할 수 없도록 해야 하는데, <code>rwx</code>로 되어 있으니 누구나 directory 내용을 변경 가능함. 하지만 그렇게 하면 안 되므로 sticky bit가 설정된 directory는 해당 파일의 owner만 rename, move, delete할 수 있음.</li></ul></li><li>Superuser(슈퍼유저): 모든 것을 다 할 수 있는 사용자 <ul><li>일반적인 access control 제한에서 제외됨.</li><li>시스템 전반에 걸친 접근 권한을 가짐.</li></ul></li></ul><h2 id="access-control-lists-acls-in-unix" tabindex="-1"><a class="header-anchor" href="#access-control-lists-acls-in-unix"><span>Access Control Lists (ACLs) in UNIX</span></a></h2><ul><li>Modern UNIX 시스템은 ACL도 support함. <ul><li>FreeBSD, OpenBSD, Linux, Solaris 등에서</li></ul></li><li>FreeBSD <ul><li><code>setfacl</code> 명령은 UNIX 사용자 ID 및 그룹의 목록을 할당함.</li><li>파일에 임의의 수의 사용자 및 그룹을 연관시킬 수 있음.</li><li>읽기, 쓰기, 실행 보호 비트</li><li>파일이 ACL을 가질 필요는 없음.</li><li>파일에 확장 ACL이 있는지 여부를 나타내는 추가 보호 비트를 포함함.</li></ul></li><li>process가 파일 시스템 object에 접근을 요청할 때 두 단계가 수행됨. <ol><li>가장 적절한 ACL을 선택 (소유자, 지정된 사용자, 소유 그룹/지정된 그룹, 기타)</li><li>일치하는 항목에 충분한 권한이 포함되어 있는지 확인</li></ol></li><li><em>특정 파일의 삭제 권한은 상위 directory에 대한 write 권한임.</em></li></ul><h2 id="role-based-access-control-rbac" tabindex="-1"><a class="header-anchor" href="#role-based-access-control-rbac"><span>Role-Based Access Control (RBAC)</span></a></h2><ul><li>사용자는 role(역할)을 할당받고, role은 resources을 할당받는 구조</li><li>user-role, role-resources 관계를 통해 access control을 관리</li><li>사용자는 session(세션) 내에서 특정 role을 활성화하여 해당 role에 부여된 권한을 행사</li></ul><h3 id="role-based-access-control-models" tabindex="-1"><a class="header-anchor" href="#role-based-access-control-models"><span>Role-Based Access Control Models</span></a></h3><ul><li>RBAC는 여러 모델로 구성되며, 계층적 구조를 가질 수 있음.</li></ul><ol><li>Core RBAC(핵심 RBAC): user, role, permission, session의 기본 요소를 정의</li><li>Hierarchical RBAC(계층적 RBAC): role 간의 상속 관계를 지원하여 권한 관리의 효율성을 높임.</li><li>Static Separation of Duty RBAC(정적 직무 분리 RBAC): 상호 배타적인 role을 정의하여 이해 상충을 방지함.</li><li>Dynamic Separation of Duty RBAC(동적 직무 분리 RBAC): 한 session 내에서 활성화될 수 있는 role들을 제한함.</li></ol><h3 id="constraints" tabindex="-1"><a class="header-anchor" href="#constraints"><span>Constraints</span></a></h3><ul><li>조직의 행정 및 보안 policy의 특수성에 RBAC를 적용하는 수단을 제공</li><li>Role 간의 정의된 관계 또는 role과 관련된 조건</li><li>유형 <ul><li>Mutually exclusive roles(상호 배타적 역할) <ul><li>사용자는 (세션 동안 또는 정적으로) 집합 내의 한 role에만 할당될 수 있음.</li><li>모든 권한(접근 권한)은 집합 내의 한 role에만 부여될 수 있음.</li></ul></li><li>Cardinality <ul><li>role과 관련하여 maximum number를 설정</li></ul></li><li>Prerequisite roles(선행 조건 역할) <ul><li>사용자가 특정 다른 role에 이미 할당된 경우에만 특정 role에 할당될 수 있음을 지시</li></ul></li></ul></li></ul><h3 id="nist-rbac-model" tabindex="-1"><a class="header-anchor" href="#nist-rbac-model"><span>NIST RBAC Model</span></a></h3><ul><li>SSD: Static separation of duty</li><li>DSD: Dynamic separation of duty</li></ul><h3 id="basic-definitions" tabindex="-1"><a class="header-anchor" href="#basic-definitions"><span>Basic Definitions</span></a></h3><ul><li>Object <ul><li>파일, 프린터, 터미널, 데이터베이스 레코드 등 access control의 대상이 되는 모든 시스템 resource</li></ul></li><li>Operation(연산) <ul><li>프로그램의 실행 가능한 이미지로, 호출 시 사용자를 위해 일부 기능을 실행</li></ul></li><li>Permission(권한) <ul><li>하나 이상의 RBAC 보호 object에 대해 연산을 수행하는 것에 대한 허용, 승인</li></ul></li></ul><h2 id="core-rbac" tabindex="-1"><a class="header-anchor" href="#core-rbac"><span>Core RBAC</span></a></h2><ul><li>Administrative functions(관리 기능) <ul><li>사용자 집합에서 사용자 추가 및 삭제</li><li>role 집합에서 role 추가 및 삭제</li><li>user-to-role 할당 인스턴스 생성 및 삭제</li><li>permission-to-role 할당 인스턴스 생성 및 삭제</li></ul></li><li>Supporting system functions(지원 시스템 기능) <ul><li>기본 활성 role 집합으로 사용자 session 생성</li><li>session에 활성 role 추가</li><li>session에서 role 삭제</li><li>session subject가 요청된 연산을 object에 대해 수행할 권한이 있는지 확인</li></ul></li><li>Review functions(검토 기능) <ul><li>관리자가 role assignment나 permission assignment를 확인하고 관리할 수 있게 하는 기능</li><li>모델의 모든 요소와 그 관계를 수정하지 않고 볼 수 있게 함.</li></ul></li></ul><h2 id="hierarchical-rbac" tabindex="-1"><a class="header-anchor" href="#hierarchical-rbac"><span>Hierarchical RBAC</span></a></h2><ul><li>General role hierarchies: 임의의 partial ordering을 허용</li><li>Limited role hierarchies: tree 구조를 채택하여 cycle이 발생하지 않도록 함</li></ul><h2 id="static-separation-of-duty-relations-ssd" tabindex="-1"><a class="header-anchor" href="#static-separation-of-duty-relations-ssd"><span>Static Separation of Duty Relations (SSD)</span></a></h2><ul><li>한 사용자가 집합 내의 한 role에 할당되면, 해당 집합의 다른 어떤 role에도 할당될 수 없도록 하는 상호 배타적인 role 집합의 정의를 가능하게 함.</li><li>role 집합에 카디널리티 제약을 둘 수 있음. <ul><li>(<em>role set, n</em>) 쌍 형태로 정의되며, 어떤 사용자도 해당 role 집합에서 n개 이상의 role에 할당되지 않음.</li></ul></li><li>role 집합 생성 및 삭제, role 멤버 추가 및 삭제를 위한 관리 기능을 포함함.</li><li>기존 SSD 집합의 속성을 보기 위한 검토 기능을 포함함.</li></ul><h2 id="dynamic-separation-of-duty-relations-dsd" tabindex="-1"><a class="header-anchor" href="#dynamic-separation-of-duty-relations-dsd"><span>Dynamic Separation of Duty Relations (DSD)</span></a></h2><ul><li>사용자에게 가용한 권한을 제한함.</li><li>사용자 session 내에서 또는 session 간에 활성화될 수 있는 role에 제약을 둠.</li><li>제약은 (<em>role set, n</em>) 쌍으로 정의되며, 여기서 n은 자연수 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n \\geq 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>이고, 어떤 사용자 session도 role 집합에서 n개 이상의 role을 활성화할 수 없는 속성을 가짐.</li><li>관리자가 사용자에 대해 서로 다른, 겹치지 않는 시간대에 특정 능력을 지정할 수 있게 함.</li><li>DSD 관계를 정의하고 보기 위한 관리 및 검토 기능을 포함함.</li></ul><h2 id="example-of-access-control-administration" tabindex="-1"><a class="header-anchor" href="#example-of-access-control-administration"><span>Example of Access Control Administration</span></a></h2><ul><li>HR 부서: 사용자 직원 각 ID에 대하여 role을 정의하고, role에 대해서 각 사용자를 특정 role에 assign <ul><li>따라서, 하나의 사용자가 여러 role에 assign될 수 있음.</li></ul></li><li>Application 관리자: 어떤 application이 어떤 access 권한을 갖는지 정의</li><li>Authorization 관리자: 어떤 role이 어떤 application에 접근할 수 있는지 정의</li><li>RBAC 환경에서는 관리 role이 user-to-role 할당 및 permission-to-role 할당을 관리함.</li><li>예를 들어, &#39;사용자 관리자&#39; role은 사용자에게 role을 할당하고, &#39;권한 관리자&#39; role은 role에 권한을 할당하는 작업을 수행함.</li></ul><h2 id="attribute-based-access-control-abac" tabindex="-1"><a class="header-anchor" href="#attribute-based-access-control-abac"><span>Attribute-based Access Control (ABAC)</span></a></h2><ul><li>속성을 함께 결합하는 policy에 기반 <ul><li>사용자 속성, resource 속성, 환경 속성 등</li><li>예: 나이, role, 직함 등 / 읽기, 삭제, view 등 / object type 등</li></ul></li><li>다양한 속성을 평가할 수 있는 복잡한 Boolean rule set을 표현할 수 있음.</li><li>예: <ul><li>policy: 관리자는 자신의 지역 내의 transaction을 볼 수 있음.</li><li>policy: <code>user.role == manager</code>인 사용자는 <code>user.region == transaction.region</code>인 경우 <code>table == TRANSACTIONS</code> 테이블에 대해 <code>action == SELECT</code> 작업을 수행할 수 있음.</li></ul></li></ul>',62)])])}const r=l(t,[["render",o]]),d=JSON.parse('{"path":"/cs/05.Access_Control.html","title":"05. Access Control","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1760812789000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":4,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"1773cff5462b316c961165960dbee5e76d02ec5e","time":1760812789000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Refactor malware documentation for clarity and consistency; enhance terminology, improve formatting, and update examples for better understanding."},{"hash":"753602915cd35a5b4d937d16206250330fc05a20","time":1760730102000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Refactor relational model documentation for clarity and consistency"},{"hash":"b4f3a5b216ddcf4da76cea9858c62ecff3206f55","time":1760728774000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Fix section headers for consistency in documentation"},{"hash":"96ffe5267f585ee7edbbe18e9ef393ef6cd3f3e8","time":1760727848000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Add comprehensive documentation on malware, including definitions, types, features, propagation methods, and countermeasures"}]},"filePathRelative":"cs/05.Access_Control.md"}');export{r as comp,d as data};
