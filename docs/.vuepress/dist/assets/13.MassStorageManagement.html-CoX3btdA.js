import{_ as a,c as l,a as n,o as i}from"./app-Bm21SmUK.js";const t={};function e(p,s){return i(),l("div",null,s[0]||(s[0]=[n(`<h1 id="_13-mass-storage-management" tabindex="-1"><a class="header-anchor" href="#_13-mass-storage-management"><span>13. Mass Storage Management</span></a></h1><p>Dept. of Computer Science<br> Hanyang University</p><h2 id="physical-disk-structure" tabindex="-1"><a class="header-anchor" href="#physical-disk-structure"><span>Physical Disk Structure</span></a></h2><ul><li><p>디스크는 <strong>얇은 금속 플래터</strong>(platter)로 구성되며,<br> 그 위를 읽기/쓰기 헤드가 비행하며 동작</p></li><li><p>디스크에서 읽기 위해 지정해야 할 요소:</p><ul><li>cylinder #</li><li>surface #</li><li>sector #</li><li>transfer size</li><li>memory address</li></ul></li><li><p>전송 시간(Transfer time)은 다음을 포함:</p><ul><li>Seek time</li><li>Rotational delay</li><li>Transfer time</li></ul></li></ul><h2 id="disk-structure" tabindex="-1"><a class="header-anchor" href="#disk-structure"><span>Disk Structure</span></a></h2><ul><li><p>디스크 드라이브는 <strong>논리 블록</strong>(logical block)의 1차원 배열로 주소 지정됨<br> → 논리 블록은 전송의 최소 단위</p></li><li><p>이 1차원 배열은 디스크의 섹터들로 매핑됨</p><ul><li>sector 0 = 최외곽 실린더의 첫 번째 트랙의 첫 번째 섹터</li><li>매핑은 일반적으로 각 트랙을 순서대로 진행<br> → 실린더 바깥쪽에서 안쪽으로 진행<br> (실제 구현은 제품마다 다름)</li></ul></li></ul><h2 id="disk-scheduling" tabindex="-1"><a class="header-anchor" href="#disk-scheduling"><span>Disk Scheduling</span></a></h2><ul><li><p>디스크 접근 시간은 두 가지 주요 요소로 구성됨:</p><ul><li><strong>Seek time</strong>: 디스크 헤드를 원하는 실린더로 이동하는 시간</li><li><strong>Rotational latency</strong>: 원하는 섹터가 헤드 아래로 올 때까지의 대기 시간</li></ul></li><li><p>목표: Seek time 최소화</p><ul><li>Seek time ≈ Seek distance</li></ul></li><li><p><strong>디스크 대역폭</strong>:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Disk bandwidth</mtext><mo>=</mo><mfrac><mtext>총 전송 바이트 수</mtext><mtext>요청부터 완료까지 걸린 총 시간</mtext></mfrac></mrow><annotation encoding="application/x-tex">\\text{Disk bandwidth} = \\frac{\\text{총 전송 바이트 수}}{\\text{요청부터 완료까지 걸린 총 시간}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Disk bandwidth</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord hangul_fallback">요청부터</span><span class="mord"> </span><span class="mord hangul_fallback">완료까지</span><span class="mord"> </span><span class="mord hangul_fallback">걸린</span><span class="mord"> </span><span class="mord hangul_fallback">총</span><span class="mord"> </span><span class="mord hangul_fallback">시간</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord hangul_fallback">총</span><span class="mord"> </span><span class="mord hangul_fallback">전송</span><span class="mord"> </span><span class="mord hangul_fallback">바이트</span><span class="mord"> </span><span class="mord hangul_fallback">수</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li></ul><h2 id="seek-time-benchmark" tabindex="-1"><a class="header-anchor" href="#seek-time-benchmark"><span>Seek Time Benchmark</span></a></h2><ul><li><p>실린더 수에 따른 평균 seek time의 변화 그래프</p></li><li><p>Seek time 모델:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><msqrt><mi>d</mi></msqrt><mspace width="1em"></mspace><mtext>(a, b: 상수, d: 실린더 간 거리)</mtext></mrow><annotation encoding="application/x-tex">a + b\\sqrt{d} \\quad \\text{(a, b: 상수, d: 실린더 간 거리)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2311em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9811em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">d</span></span></span><span style="top:-2.9411em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0589em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord">(a, b: </span><span class="mord hangul_fallback">상수</span><span class="mord">, d: </span><span class="mord hangul_fallback">실린더</span><span class="mord"> </span><span class="mord hangul_fallback">간</span><span class="mord"> </span><span class="mord hangul_fallback">거리</span><span class="mord">)</span></span></span></span></span></span></p></li></ul><h2 id="disk-scheduling-cont" tabindex="-1"><a class="header-anchor" href="#disk-scheduling-cont"><span>Disk Scheduling (Cont.)</span></a></h2><ul><li><p>디스크 I/O 요청을 처리하는 알고리즘은 다양함</p></li><li><p>예시 요청 큐 (0~199):</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">98, 183, 37, 122, 14, 124, 65, 67</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>현재 헤드 위치: 53</p></li></ul><h2 id="fcfs" tabindex="-1"><a class="header-anchor" href="#fcfs"><span>FCFS</span></a></h2><ul><li><strong>First-Come, First-Served</strong> 디스크 스케줄링 방식</li><li>요청 순서대로 처리함</li><li>단순하지만, seek 이동이 <strong>비효율적</strong></li><li>예시:<div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">queue = 98, 183, 37, 122, 14, 124, 65, 67</span>
<span class="line">head starts at 53</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>총 이동 거리: 640 cylinders</strong></li></ul><h2 id="sstf" tabindex="-1"><a class="header-anchor" href="#sstf"><span>SSTF</span></a></h2><ul><li><strong>Shortest Seek Time First</strong></li><li>현재 헤드 위치에서 가장 가까운 요청부터 처리</li><li>SJF(Shortest Job First)의 일종으로, 일부 요청은 <strong>기아(starvation)</strong> 상태 발생 가능</li><li>성능은 <strong>예측 불가능</strong></li><li>예시에서의 <strong>총 이동 거리: 236 cylinders</strong></li></ul><h2 id="sstf-cont" tabindex="-1"><a class="header-anchor" href="#sstf-cont"><span>SSTF (Cont.)</span></a></h2><ul><li>같은 queue와 시작 위치에서<br> SSTF 방식은 가장 가까운 요청부터 차례로 접근<br> → 효율적이나, 편향된 요청은 무기한 대기할 수 있음</li></ul><h2 id="scan" tabindex="-1"><a class="header-anchor" href="#scan"><span>SCAN</span></a></h2><ul><li><p>디스크 암이 디스크의 한쪽 끝에서 시작하여 반대편 끝으로 이동하며 요청 처리</p></li><li><p>끝에 도달하면 방향을 바꿔 다시 이동하며 요청 처리</p></li><li><p><strong>엘리베이터 알고리즘</strong>이라고도 불림:</p><ul><li>올라가면서 요청 처리</li><li>내려오면서도 요청 처리</li></ul></li><li><p><strong>총 이동 거리: 208 cylinders</strong></p></li><li><p>문제점:</p><ul><li>안쪽 트랙은 <strong>두 번</strong> 서비스됨 (편도마다 접근)</li><li>외곽 트랙에 비해 <strong>불공정</strong></li></ul></li></ul><h2 id="c-scan" tabindex="-1"><a class="header-anchor" href="#c-scan"><span>C-SCAN</span></a></h2><ul><li><p>SCAN보다 더 <strong>균등한 대기 시간</strong> 제공</p></li><li><p>디스크의 한쪽 끝에서 다른 끝까지 이동하며 요청 처리<br> → 끝에 도달하면 <strong>되돌아오는 경로에서는 요청 처리하지 않음</strong></p></li><li><p><strong>원형 디스크 리스트</strong>(circular list)처럼 작동<br> → 마지막 실린더에서 첫 번째 실린더로 점프</p></li><li><p>문제점:</p><ul><li>반대 방향으로 이동 중에도 <strong>요청이 없더라도 계속 진행</strong></li></ul></li><li><p><code>C-SCAN</code> 알고리즘의 디스크 헤드 이동 경로 시각화</p></li><li><p>한 방향으로 모든 요청을 처리한 후,<br> 되돌아가는 경로에서는 요청을 무시하고 처음 위치로 이동</p></li></ul><h2 id="c-look" tabindex="-1"><a class="header-anchor" href="#c-look"><span>C-LOOK</span></a></h2><ul><li><code>C-SCAN</code>의 변형 버전</li><li>디스크 끝까지 이동하지 않고, <strong>요청이 있는 마지막 위치까지만 이동</strong></li><li>그 후 <strong>즉시 반대 방향으로 전환</strong></li><li>디스크 끝까지 가는 불필요한 이동 제거</li></ul><h2 id="c-look-cont" tabindex="-1"><a class="header-anchor" href="#c-look-cont"><span>C-LOOK (Cont.)</span></a></h2><ul><li>예시 queue:<div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">queue = 98, 183, 37, 122, 14, 124, 65, 67</span>
<span class="line">head starts at 53</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>요청이 있는 마지막 지점까지만 이동하고 되돌아옴<br> → 보다 효율적인 이동 거리 확보</li></ul><h2 id="arm-stickiness-problem" tabindex="-1"><a class="header-anchor" href="#arm-stickiness-problem"><span>Arm Stickiness Problem</span></a></h2><ul><li><p><code>SCAN</code>, <code>C-SCAN</code>, <code>SSTF</code>는 <strong>Arm Stickiness</strong> 문제를 가질 수 있음</p></li><li><p>설명:</p><ul><li>특정 트랙에 접근 빈도가 높은 프로세스가 있을 경우</li><li>해당 트랙에만 반복적으로 접근 요청을 보내면서 디스크 암을 <strong>그 위치에 고정</strong>시킴</li><li>결과적으로 디스크 전체 사용이 <strong>비효율</strong>해짐</li></ul></li></ul><h2 id="disk-management" tabindex="-1"><a class="header-anchor" href="#disk-management"><span>Disk Management</span></a></h2><ul><li><p><strong>물리적 포맷(Physical formatting)</strong> 또는 <strong>저수준 포맷</strong></p><ul><li>디스크를 섹터 단위로 나누어 컨트롤러가 읽고 쓸 수 있도록 함</li><li>섹터 = 헤더 + 데이터(보통 512B) + 트레일러</li><li>여분 섹터 또는 실린더는 bad block 대비용</li></ul></li><li><p><strong>파일 시스템 사용을 위한 논리 포맷(Logical formatting)</strong> 필요</p><ul><li>OS가 파티션을 논리적인 단위로 구분</li><li>파티션마다 파일 시스템 구조를 초기화</li></ul></li><li><p><strong>부팅 과정(Power-up)</strong></p><ul><li>작은 bootstrap loader는 ROM에서 실행됨</li><li>디스크의 부트 블록을 로딩하여 OS를 실행</li></ul></li></ul><h2 id="raid" tabindex="-1"><a class="header-anchor" href="#raid"><span>RAID</span></a></h2><ul><li><p><strong>RAID (Redundant Array of Inexpensive Disks)</strong></p><ul><li>다수의 디스크를 병렬로 구성하여 <strong>고용량</strong> 및 <strong>고속</strong> 제공</li><li><strong>신뢰성 향상</strong>: 데이터 중복 저장 → 일부 디스크 실패 시에도 복구 가능</li></ul></li><li><p>이점:</p><ul><li>하나의 디스크가 고장날 확률 &lt; 여러 디스크 중 일부가 고장날 확률</li><li>하지만 RAID는 복구 가능성을 높여 전체 시스템 신뢰성을 향상시킴</li></ul></li><li><p>예시:</p><ul><li>100개의 디스크를 가진 시스템 <ul><li>각 디스크 MTTF: 100,000시간</li><li>시스템 전체 MTTF는 약 1000시간 (41일)</li></ul></li></ul></li><li><p>대규모 디스크 시스템에서는 <strong>데이터 손실 방지 기술</strong>이 필수</p></li></ul><h2 id="improvement-of-reliability-via-redundancy" tabindex="-1"><a class="header-anchor" href="#improvement-of-reliability-via-redundancy"><span>Improvement of Reliability via Redundancy</span></a></h2><ul><li><strong>Redundancy</strong>: 디스크 고장 시 손실된 정보를 복구할 수 있는 추가 정보 저장</li><li>예시: <strong>Mirroring (shadowing)</strong><ul><li>두 개의 물리 디스크에 동일한 논리 디스크 내용을 저장</li><li>각 쓰기 작업은 두 디스크 모두에 수행됨</li><li>읽기 요청은 어느 디스크에서든 처리 가능</li></ul></li><li>장점: <ul><li>한 디스크가 고장 나더라도 다른 디스크에서 정보 복구 가능</li><li><strong>동시 고장 확률</strong>이 매우 낮음</li></ul></li><li>단점: <ul><li>디스크 수 증가</li></ul></li><li>평균 데이터 손실 시간 = 고장까지의 평균 시간 + 복구 시간 <ul><li>MTTF = 100,000시간, 복구 = 10시간 → RAID 1 구성 시 약 5천만 시간</li></ul></li></ul><h2 id="improvement-in-performance-via-parallelism" tabindex="-1"><a class="header-anchor" href="#improvement-in-performance-via-parallelism"><span>Improvement in Performance via Parallelism</span></a></h2><ul><li>디스크 병렬성의 목표: <ol><li>부하 분산 → 처리량 증가</li><li>병렬 접근 → 응답 시간 단축</li></ol></li><li><strong>Bit-level striping</strong><ul><li>각 바이트의 비트를 여러 디스크에 나눠 저장</li><li>읽기 속도는 빠르지만, seek/latency는 단일 디스크보다 나쁠 수 있음</li></ul></li><li><strong>Block-level striping</strong><ul><li>블록 단위로 디스크에 분산 저장: <ul><li>예: 디스크 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>에 저장 → <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(i \\mod n) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li></ul></li><li>연속된 블록 요청 시 여러 디스크에서 동시에 병렬 처리 가능</li></ul></li></ul><h2 id="raid-levels" tabindex="-1"><a class="header-anchor" href="#raid-levels"><span>RAID Levels</span></a></h2><ul><li><strong>RAID</strong>는 디스크 스트라이핑 + 패리티를 통해 <strong>저비용으로 중복성</strong> 제공</li><li>다양한 RAID 레벨은 비용, 성능, 신뢰성 측면에서 차이를 보임</li><li><strong>RAID 0</strong>: 블록 스트라이핑, <strong>중복 없음</strong><ul><li>데이터 손실 허용 불가능한 환경에는 적합하지 않음</li></ul></li><li><strong>RAID 1</strong>: 미러링 (복제 디스크) <ul><li>뛰어난 쓰기 성능 제공</li><li>데이터베이스 시스템 등에 적합</li></ul></li><li><strong>RAID 2</strong>: Bit-level striping + ECC 디스크 <ul><li>각 비트 단위로 디스크 분산, ECC로 에러 복구 가능</li></ul></li><li><strong>RAID 3</strong>: Byte-level striping + 패리티 전용 디스크 <ul><li>전체 데이터를 바이트 단위로 나눠 여러 디스크에 저장</li><li>패리티는 별도의 디스크에 저장됨</li></ul></li><li><strong>RAID 4</strong>: Block-interleaved parity, block-level striping <ul><li>모든 디스크에서의 해당 블록들과 XOR하여 패리티 디스크에 저장</li><li>패리티 블록은 <strong>병렬 쓰기 병목 현상</strong>의 원인이 될 수 있음</li></ul></li><li><strong>RAID 5</strong>: Block-interleaved distributed parity, block-level striping <ul><li>데이터와 패리티를 모든 디스크에 <strong>분산 저장</strong></li><li>예: 디스크가 5개일 때, <ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>번째 블록의 패리티는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>5</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(n \\mod 5) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>번째 디스크에 저장</li><li>나머지 4개 디스크에는 데이터 블록 저장</li></ul></li></ul></li><li>분산 패리티 → 병목 현상 줄임</li></ul><h2 id="choice-of-raid-level" tabindex="-1"><a class="header-anchor" href="#choice-of-raid-level"><span>Choice of RAID Level</span></a></h2><ul><li><p>RAID 레벨 선택 시 고려 요소:</p><ul><li>비용 (Monetary cost)</li><li>성능: 초당 I/O 연산 수, 정상 작동 중 대역폭</li><li>장애 발생 시 성능</li><li>디스크 복구 시 성능</li></ul></li><li><p><strong>RAID 0</strong>: 데이터 안전이 중요하지 않을 때만 사용</p><ul><li>다른 소스로부터 데이터를 빠르게 복구할 수 있는 경우</li></ul></li><li><p><strong>RAID 2, 3</strong>: 현재는 사용되지 않음</p><ul><li>비트/바이트 단위 striping은 모든 디스크 접근을 강제</li><li>디스크 암 이동 낭비 → 블록 단위 striping이 이를 피함 (RAID 4, 5)</li></ul></li><li><p><strong>RAID 4</strong>: RAID 5에 흡수되어 사용되지 않음</p></li><li><p>→ 실질적 선택지는 <strong>RAID 1 vs RAID 5</strong></p></li><li><p><strong>RAID 1</strong>: RAID 5보다 <strong>훨씬 나은 쓰기 성능</strong></p><ul><li>RAID 5는 블록 1개 쓰기에도 최소 2개의 읽기 + 2개의 쓰기 필요</li><li>RAID 1은 블록 2개 쓰기만 필요</li><li>로그 디스크 등 <strong>업데이트 빈도 높은 환경에 적합</strong></li></ul></li><li><p><strong>RAID 1</strong>의 단점: 저장 공간 요구량이 RAID 5보다 큼</p><ul><li>하지만 디스크 용량은 빠르게 증가 (연간 50%)</li><li>디스크 접근 시간은 천천히 감소 (10년간 3배 수준)</li><li>웹 서버 등에서 I/O 요구량이 매우 큼</li><li>충분한 디스크를 확보해두었다면 여유 용량이 남는 경우도 많음<br> → 이 경우 RAID 1도 추가 비용 없이 구성 가능</li></ul></li><li><p><strong>RAID 5</strong>: 업데이트가 적고 <strong>대량의 데이터</strong>를 다루는 환경에 적합</p></li><li><p><strong>RAID 1</strong>: 그 외 모든 상황에 권장됨</p></li></ul>`,40)]))}const m=a(t,[["render",e]]),o=JSON.parse('{"path":"/os/13.MassStorageManagement.html","title":"13. Mass Storage Management","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1749897692000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":2,"url":"https://github.com/kmbzn"},{"name":"김병준","username":"","email":"kmbzn24@hanyang.ac.kr","commits":1}],"changelog":[{"hash":"7dfc10ae87be9ce0083cb39d24d30b15e77a0371","time":1749897692000,"email":"kmbzn24@hanyang.ac.kr","author":"김병준","message":"directory name change"},{"hash":"03cd770d5fee5783f5cf264e71aab51bd9333c96","time":1749482620000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update"},{"hash":"dae7635ba2316839b2896e1a76d96639f0a02d6b","time":1749398480000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"commit os md files"}]},"filePathRelative":"os/13.MassStorageManagement.md"}');export{m as comp,o as data};
