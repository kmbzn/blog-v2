import{_ as i,c as e,a,o as n}from"./app-wm9GLIzR.js";const r={};function s(t,l){return n(),e("div",null,[...l[0]||(l[0]=[a('<h1 id="_14-i-o-systems" tabindex="-1"><a class="header-anchor" href="#_14-i-o-systems"><span>14. I/O Systems</span></a></h1><h2 id="i-o-hardware" tabindex="-1"><a class="header-anchor" href="#i-o-hardware"><span>I/O Hardware</span></a></h2><ul><li>다양한 I/O 장치 존재</li><li>공통 개념: <ul><li>포트 (예: Serial port)</li><li>버스 (daisy chain, shared direct access)</li><li>컨트롤러 (단독 또는 host adapter 카드에 위치)</li></ul></li><li>I/O 명령어는 <strong>컨트롤러를 제어</strong><ul><li>컨트롤러는 데이터 및 제어 신호용 레지스터 보유</li></ul></li><li>프로세서는 다음 방법 중 하나로 장치에 명령/데이터 전달: <ul><li><strong>전용 I/O 명령어</strong>를 이용해 I/O 포트 주소 접근</li><li><strong>메모리 매핑 I/O</strong><ul><li>장치 제어 레지스터가 프로세스 주소 공간에 매핑됨</li><li>CPU는 표준 데이터 전송 명령어로 I/O 수행</li></ul></li></ul></li><li>I/O 포트는 다음 네 개의 레지스터로 구성됨: <ul><li><strong>Status register</strong><ul><li>호스트가 읽을 수 있는 bit 포함 (Busy bit, error bit 등)</li></ul></li><li><strong>Control register</strong><ul><li>명령 실행 또는 장치 모드 변경용</li></ul></li><li><strong>Data-in register</strong><ul><li>호스트가 장치로부터 데이터를 읽을 때 사용</li></ul></li><li><strong>Data-out register</strong><ul><li>호스트가 장치로 데이터를 보낼 때 사용</li></ul></li></ul></li></ul><h2 id="polling" tabindex="-1"><a class="header-anchor" href="#polling"><span>Polling</span></a></h2><ul><li>장치 상태 판단 방식 <ul><li>Status register의 <strong>Busy bit</strong> 체크</li></ul></li><li><strong>Busy-wait</strong>: 장치 준비될 때까지 대기 <ul><li>장치/컨트롤러가 빠르면 polling이 합리적</li></ul></li><li><strong>Polling의 단점</strong>: <ul><li>장치 준비 여부를 계속 확인하지만 대부분 비효율적</li><li>CPU가 유용한 작업을 하지 못함</li></ul></li><li>이럴 경우, <strong>인터럽트 방식</strong>으로 하드웨어 컨트롤러가 CPU에 알림</li></ul><h2 id="interrupts" tabindex="-1"><a class="header-anchor" href="#interrupts"><span>Interrupts</span></a></h2><ul><li>CPU는 <strong>interrupt-request line</strong>이라는 선을 통해 인터럽트 감지 <ul><li>I/O 장치가 트리거</li><li>CPU는 매 명령 후 인터럽트 발생 여부 감지</li></ul></li><li>인터럽트 발생 시: <ul><li>현재 상태 저장 후, 고정된 인터럽트 핸들러 주소로 점프</li><li>핸들러는 원인 분석, 처리 후 <strong>return from interrupt</strong>로 복귀</li></ul></li><li>두 종류의 인터럽트 요청 라인: <ul><li><strong>Nonmaskable</strong>: 치명적 오류 등 마스킹 불가능</li><li><strong>Maskable</strong>: CPU에 의해 제어 가능 (일반 I/O 인터럽트 등)</li></ul></li><li>인터럽트 벡터: <ul><li>올바른 핸들러로 분기하게 해줌</li></ul></li><li><strong>예외 처리에도 사용</strong>: <ul><li>0으로 나누기, 보호 메모리 접근 등</li></ul></li></ul><h2 id="a-kernel-i-o-structure" tabindex="-1"><a class="header-anchor" href="#a-kernel-i-o-structure"><span>A Kernel I/O Structure</span></a></h2><ul><li>커널 I/O 구조는 다음으로 구성: <ul><li>하드웨어 레벨의 장치들 (SCSI, 키보드, 마우스 등)</li><li>각 장치에 해당하는 <strong>디바이스 컨트롤러</strong></li><li>컨트롤러에 대응하는 <strong>디바이스 드라이버</strong></li><li>커널의 <strong>I/O 서브시스템</strong>이 이들을 관리</li></ul></li></ul><h2 id="application-i-o-interface" tabindex="-1"><a class="header-anchor" href="#application-i-o-interface"><span>Application I/O Interface</span></a></h2><ul><li>I/O 시스템 호출은 다양한 장치 동작을 일반화된 클래스에 캡슐화함 <ul><li>I/O 장치를 표준 방식으로 다룰 수 있도록 함</li></ul></li><li>장치는 다양한 특성을 가짐: <ul><li>문자 기반 또는 블록 기반</li><li>순차 접근 또는 임의 접근</li><li>공유 또는 전용</li><li>작동 속도</li><li>읽기-쓰기, 읽기 전용, 쓰기 전용</li></ul></li><li>디바이스 드라이버 계층은 커널로부터 장치 제어기 차이를 숨김</li></ul><h2 id="block-and-character-devices" tabindex="-1"><a class="header-anchor" href="#block-and-character-devices"><span>Block and Character Devices</span></a></h2><ul><li><strong>Block devices</strong>: 디스크 드라이브 포함 <ul><li>명령어: <code>read</code>, <code>write</code>, <code>seek</code></li><li><strong>Raw I/O</strong> (예: 데이터베이스 시스템) 또는 파일 시스템 접근</li><li><strong>Memory-mapped file</strong> 접근 가능</li></ul></li><li><strong>Character devices</strong>: 키보드, 마우스, 시리얼 포트 등 <ul><li>명령어: <code>get</code>, <code>put</code></li><li>사용자 입력에 적합 (자발적 데이터 생성)</li><li>출력 장치(프린터, 오디오 등)에도 적절</li></ul></li></ul><h2 id="blocking-and-nonblocking-i-o" tabindex="-1"><a class="header-anchor" href="#blocking-and-nonblocking-i-o"><span>Blocking and Nonblocking I/O</span></a></h2><ul><li><strong>Blocking I/O</strong><ul><li>I/O 완료까지 프로세스 정지됨</li><li>실행 큐에서 대기 큐로 이동</li><li>사용이 쉬움</li></ul></li><li><strong>Non-blocking I/O</strong><ul><li>가능한 만큼 즉시 반환</li><li>읽거나 쓴 바이트 수를 반환</li></ul></li><li><strong>Asynchronous I/O</strong><ul><li>I/O 수행 중에도 프로세스 계속 실행</li><li>요청된 작업은 추후 완료</li><li>구현 어려움</li></ul></li><li>I/O 서브시스템은 I/O 완료 시점에 시그널을 보냄</li></ul><h2 id="kernel-i-o-subsystem" tabindex="-1"><a class="header-anchor" href="#kernel-i-o-subsystem"><span>Kernel I/O Subsystem</span></a></h2><h3 id="scheduling" tabindex="-1"><a class="header-anchor" href="#scheduling"><span>Scheduling</span></a></h3><ul><li>각 장치별 큐로 I/O 요청 순서 정렬</li><li>공정성 유지 시도</li></ul><h3 id="buffering" tabindex="-1"><a class="header-anchor" href="#buffering"><span>Buffering</span></a></h3><ul><li>장치 간 전송 시 데이터를 메모리에 임시 저장</li><li>속도 및 전송 크기 불일치 대응</li><li><strong>&quot;copy semantics&quot; 유지</strong><ul><li>응용 프로그램에서 넘긴 데이터는 커널 버퍼에 복사</li><li>디스크에 쓰는 것은 커널 버퍼 기준</li></ul></li></ul><h3 id="caching" tabindex="-1"><a class="header-anchor" href="#caching"><span>Caching</span></a></h3><ul><li>성능 핵심</li><li>디스크 데이터의 복사본을 빠른 메모리에 유지</li><li>단일 복사본 보장 (buffer holds only copy)</li></ul><h3 id="spooling" tabindex="-1"><a class="header-anchor" href="#spooling"><span>Spooling</span></a></h3><ul><li>장치 출력 임시 보관</li><li>한 번에 하나의 요청만 처리 가능한 장치에서 사용 <ul><li>예: 프린터</li></ul></li></ul><h3 id="error-handling" tabindex="-1"><a class="header-anchor" href="#error-handling"><span>Error Handling</span></a></h3><ul><li>OS는 다양한 오류 복구 가능 <ul><li>디스크 오류, 장치 불가용, 일시적 실패 등</li></ul></li><li>실패한 I/O 요청에 대해: <ul><li>오류 코드 반환</li><li>시스템 로그 기록</li></ul></li></ul><h3 id="kernel-data-structures" tabindex="-1"><a class="header-anchor" href="#kernel-data-structures"><span>Kernel Data Structures</span></a></h3><ul><li>장치 상태 추적용 구조체 유지 <ul><li>파일 테이블, 네트워크 연결, 문자 장치 상태 등</li></ul></li><li>버퍼, 메모리, dirty 블록 등 다양한 트래킹 구조 사용</li></ul><h2 id="performance" tabindex="-1"><a class="header-anchor" href="#performance"><span>Performance</span></a></h2><ul><li><strong>I/O는 시스템 성능에 큰 영향을 미침</strong><ul><li>디바이스 드라이버, 커널 I/O 코드를 실행하기 위해 CPU에 큰 부하 발생</li><li>인터럽트에 의한 컨텍스트 스위칭</li><li>데이터 복사 비용</li><li>네트워크 트래픽은 특히 부담이 큼</li></ul></li><li><strong>I/O 성능 향상 방법</strong><ul><li>컨텍스트 스위치 수 감소</li><li>데이터 복사량 최소화</li><li>대용량 전송 또는 polling 사용으로 인터럽트 수 감소</li><li>DMA(Direct Memory Access) 활용</li><li>CPU, 메모리, 버스, I/O 성능의 균형을 통해 최대 처리량 확보</li></ul></li></ul><h2 id="concluding-the-os-course" tabindex="-1"><a class="header-anchor" href="#concluding-the-os-course"><span>Concluding the OS course…</span></a></h2><blockquote><p><strong>Operating System is…</strong></p><blockquote><p><em>a collection of Cheating Schemes.</em></p></blockquote></blockquote>',32)])])}const u=i(r,[["render",s]]),c=JSON.parse('{"path":"/os/14.IOSystems.html","title":"14. I/O Systems","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1749897692000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":3,"url":"https://github.com/kmbzn"},{"name":"김병준","username":"","email":"kmbzn24@hanyang.ac.kr","commits":1}],"changelog":[{"hash":"7dfc10ae87be9ce0083cb39d24d30b15e77a0371","time":1749897692000,"email":"kmbzn24@hanyang.ac.kr","author":"김병준","message":"directory name change"},{"hash":"03cd770d5fee5783f5cf264e71aab51bd9333c96","time":1749482620000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update"},{"hash":"b3884173e67cfd4943b847807ec332172ff886a1","time":1749398530000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"commit change"},{"hash":"dae7635ba2316839b2896e1a76d96639f0a02d6b","time":1749398480000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"commit os md files"}]},"filePathRelative":"os/14.IOSystems.md"}');export{u as comp,c as data};
