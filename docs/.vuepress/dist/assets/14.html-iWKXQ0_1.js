import{_ as i,c as a,a as e,o as n}from"./app-DVb85zHU.js";const r={};function s(c,l){return n(),a("div",null,[...l[0]||(l[0]=[e('<h1 id="_14-i-o-systems" tabindex="-1"><a class="header-anchor" href="#_14-i-o-systems"><span>14. I/O Systems</span></a></h1><h2 id="i-o-hardware" tabindex="-1"><a class="header-anchor" href="#i-o-hardware"><span>I/O Hardware</span></a></h2><ul><li>다양한 I/O 장치 존재</li><li>공통 개념 <ul><li>포트 (예: Serial port)</li><li>버스 (daisy chain, shared direct access)</li><li>컨트롤러 (단독 또는 host adapter 카드에 위치)</li></ul></li><li>I/O 명령어는 컨트롤러를 제어 <ul><li>컨트롤러는 데이터 및 제어 신호용 레지스터 보유</li></ul></li><li>프로세서는 다음 방법 중 하나로 장치에 명령/데이터 전달 <ul><li>전용 I/O 명령어를 이용해 I/O 포트 주소 접근</li><li>메모리 매핑 I/O <ul><li>장치 제어 레지스터가 프로세스 주소 공간에 매핑됨</li><li>CPU는 표준 데이터 전송 명령어로 I/O 수행</li></ul></li></ul></li><li>I/O 포트는 다음 네 개의 레지스터로 구성됨 <ul><li>Status register <ul><li>호스트가 읽을 수 있는 bit 포함 (Busy bit, error bit 등)</li></ul></li><li>Control register <ul><li>명령 실행 또는 장치 모드 변경용</li></ul></li><li>Data-in register <ul><li>호스트가 장치로부터 데이터를 읽을 때 사용</li></ul></li><li>Data-out register <ul><li>호스트가 장치로 데이터를 보낼 때 사용</li></ul></li></ul></li></ul><h2 id="polling" tabindex="-1"><a class="header-anchor" href="#polling"><span>Polling</span></a></h2><ul><li>장치 상태 판단 방식 <ul><li>Status register의 Busy bit 체크</li></ul></li><li>Busy-wait: 장치 준비될 때까지 대기 <ul><li>장치/컨트롤러가 빠르면 polling이 합리적</li></ul></li><li>Polling의 단점 <ul><li>장치 준비 여부를 계속 확인하지만 대부분 비효율적</li><li>CPU가 유용한 작업을 하지 못함</li></ul></li><li>이럴 경우, 인터럽트 방식으로 하드웨어 컨트롤러가 CPU에 알림</li></ul><h2 id="interrupts" tabindex="-1"><a class="header-anchor" href="#interrupts"><span>Interrupts</span></a></h2><ul><li>CPU는 interrupt-request line이라는 선을 통해 인터럽트 감지 <ul><li>I/O 장치가 트리거</li><li>CPU는 매 명령 후 인터럽트 발생 여부 감지</li></ul></li><li>인터럽트 발생 시 <ul><li>현재 상태 저장 후, 고정된 인터럽트 핸들러 주소로 점프</li><li>핸들러는 원인 분석, 처리 후 return from interrupt로 복귀</li></ul></li><li>두 종류의 인터럽트 요청 라인 <ul><li>Nonmaskable: 치명적 오류 등 마스킹 불가능</li><li>Maskable: CPU에 의해 제어 가능 (일반 I/O 인터럽트 등)</li></ul></li><li>인터럽트 벡터 <ul><li>올바른 핸들러로 분기하게 해줌</li></ul></li><li>예외 처리에도 사용 <ul><li>0으로 나누기, 보호 메모리 접근 등</li></ul></li></ul><h2 id="a-kernel-i-o-structure" tabindex="-1"><a class="header-anchor" href="#a-kernel-i-o-structure"><span>A Kernel I/O Structure</span></a></h2><ul><li>커널 I/O 구조는 다음으로 구성 <ul><li>하드웨어 레벨의 장치들 (SCSI, 키보드, 마우스 등)</li><li>각 장치에 해당하는 디바이스 컨트롤러</li><li>컨트롤러에 대응하는 디바이스 드라이버</li><li>커널의 I/O 서브시스템이 이들을 관리</li></ul></li></ul><h2 id="application-i-o-interface" tabindex="-1"><a class="header-anchor" href="#application-i-o-interface"><span>Application I/O Interface</span></a></h2><ul><li>I/O 시스템 호출은 다양한 장치 동작을 일반화된 클래스에 캡슐화함 <ul><li>I/O 장치를 표준 방식으로 다룰 수 있도록 함</li></ul></li><li>장치는 다양한 특성을 가짐 <ul><li>문자 기반 또는 블록 기반</li><li>순차 접근 또는 임의 접근</li><li>공유 또는 전용</li><li>작동 속도</li><li>읽기-쓰기, 읽기 전용, 쓰기 전용</li></ul></li><li>디바이스 드라이버 계층은 커널로부터 장치 제어기 차이를 숨김</li></ul><h2 id="block-and-character-devices" tabindex="-1"><a class="header-anchor" href="#block-and-character-devices"><span>Block and Character Devices</span></a></h2><ul><li>Block devices: 디스크 드라이브 포함 <ul><li>명령어: <code>read</code>, <code>write</code>, <code>seek</code></li><li>Raw I/O (예: 데이터베이스 시스템) 또는 파일 시스템 접근</li><li>Memory-mapped file 접근 가능</li></ul></li><li>Character devices: 키보드, 마우스, 시리얼 포트 등 <ul><li>명령어: <code>get</code>, <code>put</code></li><li>사용자 입력에 적합 (자발적 데이터 생성)</li><li>출력 장치(프린터, 오디오 등)에도 적절</li></ul></li></ul><h2 id="blocking-and-nonblocking-i-o" tabindex="-1"><a class="header-anchor" href="#blocking-and-nonblocking-i-o"><span>Blocking and Nonblocking I/O</span></a></h2><ul><li>Blocking I/O <ul><li>I/O 완료까지 프로세스 정지됨</li><li>실행 큐에서 대기 큐로 이동</li><li>사용이 쉬움</li></ul></li><li>Non-blocking I/O <ul><li>가능한 만큼 즉시 반환</li><li>읽거나 쓴 바이트 수를 반환</li></ul></li><li>Asynchronous I/O <ul><li>I/O 수행 중에도 프로세스 계속 실행</li><li>요청된 작업은 추후 완료</li><li>구현 어려움</li></ul></li><li>I/O 서브시스템은 I/O 완료 시점에 시그널을 보냄</li></ul><h2 id="kernel-i-o-subsystem" tabindex="-1"><a class="header-anchor" href="#kernel-i-o-subsystem"><span>Kernel I/O Subsystem</span></a></h2><h3 id="scheduling" tabindex="-1"><a class="header-anchor" href="#scheduling"><span>Scheduling</span></a></h3><ul><li>각 장치별 큐로 I/O 요청 순서 정렬</li><li>공정성 유지 시도</li></ul><h3 id="buffering" tabindex="-1"><a class="header-anchor" href="#buffering"><span>Buffering</span></a></h3><ul><li>장치 간 전송 시 데이터를 메모리에 임시 저장</li><li>속도 및 전송 크기 불일치 대응</li><li>&quot;copy semantics&quot; 유지 <ul><li>응용 프로그램에서 넘긴 데이터는 커널 버퍼에 복사</li><li>디스크에 쓰는 것은 커널 버퍼 기준</li></ul></li></ul><h3 id="caching" tabindex="-1"><a class="header-anchor" href="#caching"><span>Caching</span></a></h3><ul><li>성능 핵심</li><li>디스크 데이터의 복사본을 빠른 메모리에 유지</li><li>단일 복사본 보장 (buffer holds only copy)</li></ul><h3 id="spooling" tabindex="-1"><a class="header-anchor" href="#spooling"><span>Spooling</span></a></h3><ul><li>장치 출력 임시 보관</li><li>한 번에 하나의 요청만 처리 가능한 장치에서 사용 <ul><li>예: 프린터</li></ul></li></ul><h3 id="error-handling" tabindex="-1"><a class="header-anchor" href="#error-handling"><span>Error Handling</span></a></h3><ul><li>OS는 다양한 오류 복구 가능 <ul><li>디스크 오류, 장치 불가용, 일시적 실패 등</li></ul></li><li>실패한 I/O 요청에 대해 <ul><li>오류 코드 반환</li><li>시스템 로그 기록</li></ul></li></ul><h3 id="kernel-data-structures" tabindex="-1"><a class="header-anchor" href="#kernel-data-structures"><span>Kernel Data Structures</span></a></h3><ul><li>장치 상태 추적용 구조체 유지 <ul><li>파일 테이블, 네트워크 연결, 문자 장치 상태 등</li></ul></li><li>버퍼, 메모리, dirty 블록 등 다양한 트래킹 구조 사용</li></ul><h2 id="performance" tabindex="-1"><a class="header-anchor" href="#performance"><span>Performance</span></a></h2><ul><li>I/O는 시스템 성능에 큰 영향을 미침 <ul><li>디바이스 드라이버, 커널 I/O 코드를 실행하기 위해 CPU에 큰 부하 발생</li><li>인터럽트에 의한 컨텍스트 스위칭</li><li>데이터 복사 비용</li><li>네트워크 트래픽은 특히 부담이 큼</li></ul></li><li>I/O 성능 향상 방법 <ul><li>컨텍스트 스위치 수 감소</li><li>데이터 복사량 최소화</li><li>대용량 전송 또는 polling 사용으로 인터럽트 수 감소</li><li>DMA(Direct Memory Access) 활용</li><li>CPU, 메모리, 버스, I/O 성능의 균형을 통해 최대 처리량 확보</li></ul></li></ul><h2 id="concluding-the-os-course" tabindex="-1"><a class="header-anchor" href="#concluding-the-os-course"><span>Concluding the OS course…</span></a></h2><blockquote><p>Operating System is…</p><blockquote><p><em>a collection of Cheating Schemes.</em></p></blockquote></blockquote>',32)])])}const o=i(r,[["render",s]]),t=JSON.parse('{"path":"/os/14.html","title":"14. I/O Systems","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1764506597000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":4,"url":"https://github.com/kmbzn"},{"name":"김병준","username":"","email":"kmbzn24@hanyang.ac.kr","commits":1}],"changelog":[{"hash":"4997c37eb1d4ad491f033600ca10151bd286506e","time":1764506597000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"탭 개편"},{"hash":"7dfc10ae87be9ce0083cb39d24d30b15e77a0371","time":1749897692000,"email":"kmbzn24@hanyang.ac.kr","author":"김병준","message":"directory name change"},{"hash":"03cd770d5fee5783f5cf264e71aab51bd9333c96","time":1749482620000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update"},{"hash":"b3884173e67cfd4943b847807ec332172ff886a1","time":1749398530000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"commit change"},{"hash":"dae7635ba2316839b2896e1a76d96639f0a02d6b","time":1749398480000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"commit os md files"}]},"filePathRelative":"os/14.md"}');export{o as comp,t as data};
