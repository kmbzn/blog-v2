import{_ as s,c as l,a as e,o as t}from"./app-BV4FAx4-.js";import"./vendor-bWEtUbjf.js";/* empty css                 */const i={};function n(r,a){return t(),l("div",null,[...a[0]||(a[0]=[e(`<h1 id="_06-database-security" tabindex="-1"><a class="header-anchor" href="#_06-database-security"><span>06. Database Security</span></a></h1><h2 id="데이터베이스-databases" tabindex="-1"><a class="header-anchor" href="#데이터베이스-databases"><span>데이터베이스 Databases</span></a></h2><ul><li>하나 이상의 애플리케이션에서 사용하기 위해 저장된 데이터의 구조화된 모음</li><li>데이터 항목과 데이터 항목 그룹 간의 관계를 포함</li><li>때로는 보안이 필요한 민감한 데이터를 포함할 수 있음.</li><li>데이터베이스 관리 시스템(DBMS, database management system) <ul><li>데이터베이스를 구축하고 유지하기 위한 프로그램 모음</li><li>여러 사용자 및 애플리케이션에 임시 query(ad hoc query) 기능을 제공</li></ul></li><li>Query language <ul><li>데이터베이스에 대한 통일된 인터페이스를 제공</li></ul></li></ul><h2 id="dbms-architecture" tabindex="-1"><a class="header-anchor" href="#dbms-architecture"><span>DBMS Architecture</span></a></h2><ul><li>사용자와 애플리케이션은 SQL 인터페이스를 통해 DBMS와 상호작용함.</li><li>Query Optimizer(쿼리 최적화기)는 SQL query를 효율적인 실행 계획으로 변환함.</li><li>Query Executor(쿼리 실행기)는 관계형 연산자를 사용하여 이 계획을 실행함.</li><li>Storage Manager(저장 관리자)는 데이터베이스의 물리적 저장을 처리하며, 버퍼 관리자, 디스크 공간 관리자, 트랜잭션 관리자, 잠금 관리자, 복구 관리자 등의 하위 구성요소로 이루어짐.</li></ul><h2 id="relational-databases" tabindex="-1"><a class="header-anchor" href="#relational-databases"><span>Relational Databases</span></a></h2><ul><li>행과 열로 구성된 데이터 테이블</li><li>각 열은 특정 유형의 데이터를 보유</li><li>각 행은 각 열에 대한 특정 값을 포함</li><li>이상적으로는 모든 값이 고유하여 해당 행의 식별자/key(키)를 형성하는 하나의 열을 가짐.</li><li>모든 테이블에 존재하는 고유 식별자에 의해 서로 연결된 여러 테이블의 생성을 가능하게 함.</li><li>데이터베이스에 접근하기 위해 relational query language(관계형 query어)를 사용</li><li>사용자가 주어진 기준에 맞는 데이터를 요청할 수 있도록 허용</li></ul><h2 id="figure-5-2-relational-database-example" tabindex="-1"><a class="header-anchor" href="#figure-5-2-relational-database-example"><span>Figure 5.2 Relational Database Example</span></a></h2><ul><li><code>Staff</code>, <code>Branch</code>, <code>StaffBranch</code> 세 개의 테이블로 구성된 관계형 데이터베이스 예시</li><li><code>Staff</code> 테이블은 <code>staffNo</code>(기본 키), <code>name</code>, <code>telNo</code>, <code>posn</code> 열을 가짐.</li><li><code>Branch</code> 테이블은 <code>branchNo</code>(기본 키), <code>bAddress</code> 열을 가짐.</li><li><code>StaffBranch</code> 테이블은 <code>Staff</code>와 <code>Branch</code>를 연결하며, <code>staffNo</code>와 <code>branchNo</code>를 외래 키로 가짐.</li></ul><h2 id="relational-database-elements" tabindex="-1"><a class="header-anchor" href="#relational-database-elements"><span>Relational Database Elements</span></a></h2><ul><li>Relation(관계), Table(테이블), File(파일)</li><li>Tuple(튜플), Row(행), Record(레코드)</li><li>Attribute(속성), Column(열), Field(필드)</li><li>Primary key(기본 키) <ul><li>행을 고유하게 식별</li><li>하나 이상의 열 이름으로 구성</li></ul></li><li>Foreign key(외래 키) <ul><li>한 테이블을 다른 테이블의 속성과 연결</li></ul></li><li>View(뷰), Virtual table(가상 테이블) <ul><li>하나 이상의 테이블에서 선택된 행과 열을 반환하는 query의 결과</li></ul></li></ul><h2 id="structured-query-language-sql" tabindex="-1"><a class="header-anchor" href="#structured-query-language-sql"><span>Structured Query Language (SQL)</span></a></h2><ul><li>1970년대 중반 IBM에서 처음 개발됨.</li><li>관계형 데이터베이스의 데이터를 정의, 조작 및 query하기 위한 표준화된 언어</li><li>여러 유사한 버전의 ANSI/ISO 표준 존재</li><li>SQL 문은 다음을 위해 사용될 수 있음. <ul><li>테이블 생성</li><li>테이블에 데이터 삽입 및 삭제</li><li>뷰 생성</li><li>query문을 사용하여 데이터 검색</li></ul></li></ul><h2 id="sql-standard-query-language" tabindex="-1"><a class="header-anchor" href="#sql-standard-query-language"><span>SQL: Standard Query Language</span></a></h2><ul><li>SQL은 데이터베이스에 접근하고 관리(query)하게 함.</li><li>데이터베이스는 신속한 검색 및 조회를 위해 필드와 열이 있는 테이블로 구성된 대규모 데이터 모음임.</li><li>예시 테이블 <code>CS166</code>: <ul><li>필드/열: <code>First_Name</code>, <code>Last_Name</code>, <code>Code_ID</code></li><li>레코드/행: <code>(Bernardo, Palazzi, 345)</code></li></ul></li></ul><h2 id="sql-syntax" tabindex="-1"><a class="header-anchor" href="#sql-syntax"><span>SQL Syntax</span></a></h2><ul><li><code>SELECT</code> 문은 데이터베이스의 하나 이상의 테이블에서 데이터를 선택하는 데 사용됨.</li><li>결과 집합은 결과 테이블에 저장됨.</li><li><code>WHERE</code> 절은 레코드를 필터링하는 데 사용됨.</li><li>기본 구문:<div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token operator">*</span></span>
<span class="line"><span class="token keyword">FROM</span> table_name</span>
<span class="line"><span class="token keyword">WHERE</span> column_name operator <span class="token keyword">value</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><code>ORDER BY</code>는 하나 이상의 필드(열)를 따라 데이터를 정렬하는 데 사용됨.</li><li><code>LIMIT</code>는 특정 수의 레코드(행)만 검색하도록 허용함.</li><li>확장 구문:<div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token operator">*</span></span>
<span class="line"><span class="token keyword">FROM</span> table_name</span>
<span class="line"><span class="token keyword">WHERE</span> column_name operator <span class="token keyword">value</span></span>
<span class="line"><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> column_name <span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span></span>
<span class="line"><span class="token keyword">LIMIT</span> <span class="token keyword">starting</span> <span class="token keyword">row</span> <span class="token operator">and</span> number <span class="token keyword">of</span> <span class="token keyword">lines</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="owasp-top-10" tabindex="-1"><a class="header-anchor" href="#owasp-top-10"><span>OWASP top 10</span></a></h2><ul><li>2013 OWASP Top 10 보안 취약점 목록 <ol><li>인젝션(Injection)</li><li>Broken Authentication and Session Management(인증 및 세션 관리 취약점)</li><li>크로스 사이트 스크립팅(Cross-Site Scripting, XSS)</li><li>Insecure Direct Object References(안전하지 않은 직접 객체 참조)</li><li>Security Misconfiguration(보안 설정 오류)</li><li>Sensitive Data Exposure(민감한 데이터 노출)</li><li>Missing Function Level Access Control(기능 수준 access control 부재)</li><li>크로스 사이트 요청 위조(Cross-Site Request Forgery, CSRF)</li><li>Using Components with Known Vulnerabilities(알려진 취약점이 있는 구성요소 사용)</li><li>Unvalidated Redirects and Forwards(검증되지 않은 리다이렉트 및 포워드)</li></ol></li></ul><h2 id="sql-injection-attack" tabindex="-1"><a class="header-anchor" href="#sql-injection-attack"><span>SQL Injection Attack</span></a></h2><ul><li>많은 웹 애플리케이션은 폼에서 사용자 입력을 받음.</li><li>종종 이 사용자 입력은 데이터베이스에 제출되는 SQL query를 구성하는 데 문자 그대로 사용됨. 예: <ul><li><code>SELECT user FROM table WHERE name = &#39;user_input&#39;;</code></li></ul></li><li>SQL Injection Attack(인젝션 공격)은 사용자 입력에 SQL 문을 삽입하는 것을 포함함.</li></ul><h2 id="login-authentication-query" tabindex="-1"><a class="header-anchor" href="#login-authentication-query"><span>Login Authentication Query</span></a></h2><ul><li>사용자를 인증하기 위한 표준 query: <ul><li><code>select * from users where user=&#39;$usern&#39; AND pwd=&#39;$password&#39;</code></li></ul></li><li>전형적인 SQL 인젝션 공격 <ul><li>서버 측 코드가 웹 폼의 사용자 입력으로부터 변수 <code>$username</code>과 <code>$passwd</code>를 설정</li><li>변수가 SQL query에 전달됨. <ul><li><code>select * from users where user=&#39;$username&#39; AND pwd=&#39;$passwd&#39;</code></li></ul></li><li>공격자에 의해 특수 문자열이 입력될 수 있음. <ul><li><code>select * from users where user=&#39;M&#39; OR 1=1 --&#39; AND pwd=&#39;M&#39; OR &#39;1=1&#39;</code></li></ul></li><li>결과: 암호 없이 접근 권한 획득</li></ul></li></ul><h2 id="some-improvements" tabindex="-1"><a class="header-anchor" href="#some-improvements"><span>Some improvements …</span></a></h2><ul><li>query 수정: <ul><li><code>select user,pwd from users where user=&#39;$usern&#39;</code></li><li><code>$usern=&quot;M&#39; OR &#39;1=1&quot;</code></li><li>결과: 전체 테이블</li></ul></li><li>우리는 확인할 수 있음. <ul><li>단 하나의 튜플 결과</li><li>결과의 형식적 정확성</li></ul></li><li><code>$usern=&quot;M&#39; ; drop table user;&quot;</code>와 같은 공격도 가능함.</li></ul><h2 id="correct-solution" tabindex="-1"><a class="header-anchor" href="#correct-solution"><span>Correct Solution</span></a></h2><ul><li>모든 &quot;악의적인&quot; 문자를 변경하는 Escape(이스케이프) 방법을 사용할 수 있음. <ul><li><code>Escape(&quot;t &#39; c&quot;)</code>는 <code>&quot;t \\&#39; c&quot;</code>를 결과로 제공</li></ul></li><li><code>select user,pwd from users where user=&#39;$usern&#39;</code>에서 <code>$usern=escape(&quot;M&#39; ;drop table user;&quot;)</code>를 적용하면,</li><li>결과는 안전한 query가 됨. <ul><li><code>select user,pwd from users where user=&#39;M\\&#39; drop table user;\\&#39;&#39;</code></li></ul></li></ul><h2 id="database-access-control" tabindex="-1"><a class="header-anchor" href="#database-access-control"><span>Database Access Control</span></a></h2><ul><li>데이터베이스 access control 시스템은 다음을 결정함. <ul><li>사용자가 전체 데이터베이스에 접근할 수 있는지 또는 일부에만 접근할 수 있는지</li><li>사용자가 어떤 접근 권한(생성, 삽입, 삭제, 업데이트, 읽기, 쓰기)을 갖는지</li></ul></li><li>다양한 관리 정책을 지원할 수 있음. <ul><li>Centralized administration(중앙 집중식 관리) <ul><li>소수의 권한 있는 사용자가 접근 권한을 부여하고 취소할 수 있음.</li></ul></li><li>Ownership-based administration(소유권 기반 관리) <ul><li>테이블의 생성자가 해당 테이블에 대한 접근 권한을 부여하고 취소할 수 있음.</li></ul></li><li>Decentralized administration(분산 관리) <ul><li>테이블의 소유자가 다른 사용자에게 권한 부여 권한을 부여하고 취소할 수 있게 하여, 그들이 테이블에 대한 접근 권한을 부여하고 취소할 수 있도록 함.</li></ul></li></ul></li></ul><h2 id="sql-access-controls" tabindex="-1"><a class="header-anchor" href="#sql-access-controls"><span>SQL Access Controls</span></a></h2><ul><li>접근 권한 관리를 위한 두 가지 명령: <ul><li><code>GRANT</code>: 하나 이상의 접근 권한을 부여하거나 사용자를 역할에 할당하는 데 사용</li><li><code>REVOKE</code>: 접근 권한을 취소</li></ul></li><li>일반적인 접근 권한: <ul><li><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>REFERENCES</code></li></ul></li></ul><h2 id="cascading-authorizations" tabindex="-1"><a class="header-anchor" href="#cascading-authorizations"><span>Cascading Authorizations</span></a></h2><ul><li>권한의 연쇄적 취소를 의미함.</li><li>예를 들어, 사용자 A가 B에게 권한을 부여하고, B가 C에게, C가 D에게 동일한 권한을 부여했을 때, A가 B의 권한을 취소(<code>REVOKE</code>)하면, B로부터 권한을 부여받은 C와 D의 권한도 연쇄적으로 취소됨.</li></ul><h2 id="role-based-access-control-rbac" tabindex="-1"><a class="header-anchor" href="#role-based-access-control-rbac"><span>Role-Based Access Control (RBAC)</span></a></h2><ul><li>역할 기반 access control는 관리 부담을 줄이고 보안을 향상시킴.</li><li>데이터베이스 RBAC는 다음 기능을 제공해야 함. <ul><li>역할 생성 및 삭제</li><li>역할에 대한 권한 정의</li><li>사용자의 역할 할당 및 취소</li></ul></li><li>데이터베이스 사용자 범주: <ul><li>Application owner(애플리케이션 소유자): 애플리케이션의 일부로 데이터베이스 객체를 소유하는 최종 사용자</li><li>End user(최종 사용자): 특정 애플리케이션을 통해 데이터베이스 객체를 조작하지만 데이터베이스 객체를 소유하지 않는 최종 사용자</li><li>Administrator(관리자): 데이터베이스의 일부 또는 전체에 대한 관리 책임을 가진 사용자</li></ul></li></ul><h2 id="inference-attack" tabindex="-1"><a class="header-anchor" href="#inference-attack"><span>Inference Attack</span></a></h2><ul><li>query를 수행하고 수신된 합법적인 응답으로부터 승인되지 않은 정보를 추론하는 과정</li><li>Inference channel(추론 채널) <ul><li>승인되지 않은 데이터가 획득되는 정보 전송 경로</li></ul></li></ul><h2 id="inference-example" tabindex="-1"><a class="header-anchor" href="#inference-example"><span>Inference Example</span></a></h2><ul><li>공격자는 합법적인 통계 query를 조합하여 개인의 민감한 정보를 추론할 수 있음.</li></ul><ol><li><code>(전공=&#39;CS&#39; AND 성별=&#39;남&#39;)</code>인 사람의 수를 query하여 1이라는 결과를 얻음.</li><li><code>(전공=&#39;CS&#39; AND 성별=&#39;남&#39;)</code>인 사람의 이름을 query하여 <code>Jones</code>라는 결과를 얻음.</li><li>이 두 결과를 통해, 남성 CS 전공자가 <code>Jones</code> 한 명뿐임을 알게 됨.</li><li><code>(전공=&#39;CS&#39; AND 성별=&#39;남&#39;)</code>인 사람의 평균 급여를 query하여 $50K라는 결과를 얻음.</li><li>공격자는 <code>Jones</code>의 급여가 $50K라고 추론함.</li></ol><h2 id="inference-countermeasures" tabindex="-1"><a class="header-anchor" href="#inference-countermeasures"><span>Inference Countermeasures</span></a></h2><ul><li>데이터베이스 설계 시 추론 탐지 <ul><li>데이터베이스 구조를 변경하거나 access control 체제를 변경</li></ul></li><li>query 시 추론 탐지 <ul><li>query를 모니터링하고 변경하거나 거부</li></ul></li><li>두 접근 방식 모두 추론 탐지 알고리즘이 필요함. <ul><li>어려움.</li><li>지속적인 연구 주제임.</li></ul></li></ul><h2 id="statistical-databases-sdb" tabindex="-1"><a class="header-anchor" href="#statistical-databases-sdb"><span>Statistical Databases (SDB)</span></a></h2><ul><li>개수 및 평균과 같은 통계적 성격의 데이터를 제공</li><li>두 가지 유형: <ul><li>Pure statistical database(순수 통계 데이터베이스) <ul><li>통계 데이터만 저장</li></ul></li><li>Ordinary database with statistical access(통계적 접근이 가능한 일반 데이터베이스) <ul><li>개별 항목을 포함</li><li>DAC, MAC, RBAC를 사용</li></ul></li></ul></li><li>access control 목표는 데이터베이스의 기밀성을 손상시키지 않으면서 사용자에게 필요한 정보를 제공하는 것임.</li><li>보안 문제는 추론의 문제임.</li></ul><h2 id="abstract-model-of-a-relational-database" tabindex="-1"><a class="header-anchor" href="#abstract-model-of-a-relational-database"><span>Abstract Model of a Relational Database</span></a></h2><ul><li><p>데이터베이스는 레코드 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>의 집합으로 모델링될 수 있으며, 각 레코드는 M개의 속성 값 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>의 연결로 표현됨</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>…</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mrow><mi>i</mi><mi>M</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B_i = (x_{i1} || x_{i2} || \\dots || x_{iM})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣∣</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p></li></ul><h2 id="statistical-database-security" tabindex="-1"><a class="header-anchor" href="#statistical-database-security"><span>Statistical Database Security</span></a></h2><ul><li>characteristic formula(특성 공식) C 사용</li><li>속성 값에 대한 논리식</li><li>예: <code>(Sex=Male) AND ((Major=CS) OR (Major=EE))</code></li><li>특성 공식 C의 query set(query 집합) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>는 C와 일치하는 레코드의 집합임.</li><li>통계적 query는 query 집합에 대해 계산된 값을 생성하는 query임.</li></ul><h2 id="other-query-restrictions" tabindex="-1"><a class="header-anchor" href="#other-query-restrictions"><span>Other Query Restrictions</span></a></h2><ul><li>Query set overlap control(query 집합 중복 제어) <ul><li>새로운 query와 이전 query 간의 중복을 제한</li><li>여러 문제점을 가짐.</li></ul></li><li>Partitioning(파티셔닝) <ul><li>레코드를 여러 상호 배타적인 그룹으로 클러스터링</li><li>각 그룹 전체의 통계적 속성을 query</li></ul></li><li>Query denial and information leakage(query 거부 및 정보 유출) <ul><li>거부는 정보를 유출할 수 있음.</li><li>대응하려면 사용자의 query를 추적해야 함.</li></ul></li></ul><h2 id="protecting-against-inference" tabindex="-1"><a class="header-anchor" href="#protecting-against-inference"><span>Protecting Against Inference</span></a></h2><ul><li>추론 방지 기법은 크게 Query Restriction(query 제한)과 Perturbation(섭동)으로 나님.</li><li>query 제한 <ul><li>query 집합 크기 제어</li><li>query 집합 중복 제어</li><li>파티셔닝</li></ul></li><li>섭동 <ul><li>Data perturbation(데이터 섭동) (예: 데이터 스와핑)</li><li>Output perturbation(출력 섭동) (예: 잡음 추가, 무작위 표본)</li></ul></li></ul><h2 id="perturbation" tabindex="-1"><a class="header-anchor" href="#perturbation"><span>Perturbation</span></a></h2><ul><li>원본 데이터에서 생성된 통계에 잡음(noise)을 추가</li><li>Data perturbation(데이터 섭동) 기법 <ul><li>개별 레코드의 값을 추론하는 데 사용할 수 없는 통계를 생성하도록 데이터를 수정할 수 있음.</li></ul></li><li>Output perturbation(출력 섭동) 기법 <ul><li>시스템이 원본 데이터베이스가 제공할 통계와는 다른 수정된 통계를 생성함.</li></ul></li><li>Random-sample query(무작위 표본 query) <ul><li>목표는 원본 결과와 섭동된 결과 간의 차이를 최소화하는 것임.</li><li>주요 과제는 사용할 오류의 평균 크기를 결정하는 것임.</li></ul></li></ul><h2 id="data-perturbation-techniques-data-swapping" tabindex="-1"><a class="header-anchor" href="#data-perturbation-techniques-data-swapping"><span>Data Perturbation Techniques: Data Swapping</span></a></h2><ul><li>Data swapping(데이터 스와핑)은 민감한 속성과 비민감 속성 간의 연관성을 끊기 위해 레코드 간에 비민감 속성 값을 교환하는 기법임.</li><li>예를 들어, 특정 질병과 거주 도시 간의 연관성을 숨기기 위해, 두 레코드의 도시 값을 서로 바꿈.</li><li>이 방법은 각 속성에 대한 1차 통계(예: 각 도시에 사는 사람의 수)는 보존하면서, 속성 간의 통계적 관계를 왜곡함.</li></ul><h2 id="database-encryption" tabindex="-1"><a class="header-anchor" href="#database-encryption"><span>Database Encryption</span></a></h2><ul><li>데이터베이스는 일반적으로 모든 조직에서 가장 가치 있는 정보 자원</li><li>여러 단계, 계층의 보안으로 보호됨. <ul><li>방화벽, 인증, OS access control 시스템, DB access control 시스템, 데이터베이스 자체에 대한 암호화</li></ul></li><li>암호화는 특히 sensitive한 데이터에 주로 구현됨. (개인정보보호법에 의해 명시)</li><li>전체 데이터베이스, 레코드 수준, 속성 수준 또는 개별 필드 수준 중 어느 수준에 적용할지 결정 필요</li><li>암호화의 단점: <ul><li>Key management(키 관리)</li><li>Inflexibility(유연성 부족) <ul><li>query 처리 시</li></ul></li></ul></li><li>Data owner(데이터 소유자): 통제된 release를 위해 데이터를 생성하는 조직</li><li>User(사용자): 시스템에 query를 제출하는 human entity</li><li>Client(클라이언트): 사용자 query를 서버에 저장된 암호화된 데이터에 대한 query로 변환하는 프론트엔드</li><li>Server(서버): 데이터 소유자로부터 암호화된 데이터를 받아 클라이언트에 배포할 수 있도록 하는 조직</li></ul><h2 id="abstract-model-of-a-relational-database-1" tabindex="-1"><a class="header-anchor" href="#abstract-model-of-a-relational-database-1"><span>Abstract Model of a Relational Database</span></a></h2><ul><li>암호화 <ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><msub><mi>B</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>…</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mrow><mi>i</mi><mi>M</mi></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(k, B_i) = E(k, (x_{i1} || x_{i2} || \\dots || x_{iM} ))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣∣</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></li></ul></li><li>Query: <code>Salary &lt;= $70K</code> ? <ul><li>처리가 복잡해질 수 있음</li></ul></li></ul><h2 id="encryption-scheme-for-database" tabindex="-1"><a class="header-anchor" href="#encryption-scheme-for-database"><span>Encryption Scheme for Database</span></a></h2><ul><li>index 값을 참조해서 해당 record만 복호화</li></ul><table><thead><tr><th>eid</th><th>ename</th><th>salary</th><th>addr</th><th>did</th></tr></thead><tbody><tr><td>23</td><td>Tom</td><td>70K</td><td>Maple</td><td>45</td></tr><tr><td>860</td><td>Mary</td><td>60K</td><td>Main</td><td>83</td></tr><tr><td>320</td><td>John</td><td>50K</td><td>River</td><td>50</td></tr><tr><td>875</td><td>Jerry</td><td>55K</td><td>Hopewell</td><td>92</td></tr></tbody></table><p>(a) Employee Table</p><table><thead><tr><th style="text-align:left;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">E</mtext><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\textbf{E}(k,~B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textbf">E</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></th><th style="text-align:left;">I(eid)</th><th style="text-align:left;">I(ename)</th><th style="text-align:left;">I(salary)</th><th style="text-align:left;">I(addr)</th><th style="text-align:left;">I(did)</th></tr></thead><tbody><tr><td style="text-align:left;">1100110011001011...</td><td style="text-align:left;">1</td><td style="text-align:left;">10</td><td style="text-align:left;">3</td><td style="text-align:left;">7</td><td style="text-align:left;">4</td></tr><tr><td style="text-align:left;">0111000111001010...</td><td style="text-align:left;">5</td><td style="text-align:left;">7</td><td style="text-align:left;">2</td><td style="text-align:left;">7</td><td style="text-align:left;">8</td></tr><tr><td style="text-align:left;">1100010010001101...</td><td style="text-align:left;">2</td><td style="text-align:left;">5</td><td style="text-align:left;">1</td><td style="text-align:left;">9</td><td style="text-align:left;">5</td></tr><tr><td style="text-align:left;">0011010011111101...</td><td style="text-align:left;">5</td><td style="text-align:left;">5</td><td style="text-align:left;">2</td><td style="text-align:left;">4</td><td style="text-align:left;">9</td></tr></tbody></table><p>(b) Encrypted Employee Table with Indexes</p><h2 id="cloud-security" tabindex="-1"><a class="header-anchor" href="#cloud-security"><span>Cloud Security</span></a></h2><ul><li><strong>NIST</strong>는 cloud computing(클라우드 컴퓨팅)을 다음과 같이 정의함 <code>MELL11</code>: - &quot;최소한의 관리 노력이나 서비스 제공자와의 상호작용으로 신속하게 프로비저닝되고 해제될 수 있는 구성 가능한 컴퓨팅 자원(예: 네트워크, 서버, 스토리지, 애플리케이션, 서비스)의 공유 풀에 대해 유비쿼터스하고 편리하며 주문형 네트워크 접근을 가능하게 하는 모델. 이 클라우드 모델은 가용성을 증진시키며, 5가지 필수 특성, 3가지 서비스 모델, 4가지 배포 모델로 구성됨.&quot;</li></ul><h2 id="cloud-computing-elements" tabindex="-1"><a class="header-anchor" href="#cloud-computing-elements"><span>Cloud Computing Elements</span></a></h2><ul><li>5가지 필수 특성 <ul><li>Broad Network Access</li><li>Rapid Elasticity</li><li>Measured Service</li><li>On-Demand Self-Service</li><li>Resource Pooling</li></ul></li><li>3가지 service Models <ul><li>서비스형 소프트웨어(SaaS, Software as a Service)</li><li>서비스형 플랫폼(PaaS, Platform as a Service)</li><li>서비스형 인프라(IaaS, Infrastructure as a Service)</li></ul></li><li>4가지 Deployment Models <ul><li>Public</li><li>Private</li><li>Hybrid</li><li>Community</li></ul></li></ul><h2 id="cloud-computing-context" tabindex="-1"><a class="header-anchor" href="#cloud-computing-context"><span>Cloud Computing Context</span></a></h2><ul><li>Cloud service provider: end user가 resource를 필요한 만큼 사용하고, 데이터를 저장할 수 있는 서비스 제공</li></ul><h2 id="cloud-security-risks" tabindex="-1"><a class="header-anchor" href="#cloud-security-risks"><span>Cloud Security Risks</span></a></h2><ul><li>CSA(Cloud Security Alliance)는 다음과 같은 클라우드 관련 주요 보안 위협을 나열함. <ul><li>클라우드 컴퓨팅의 남용 및 악의적 사용</li><li>안전하지 않은(insecure) interface 및 API</li><li>악의적인 내부자</li><li>공유된 기술 문제</li><li>데이터 손실 또는 유출</li><li>Account 또는 Service hijacking</li><li>아직 발견되지 않은(unknown) risk profile</li></ul></li></ul><h2 id="data-protection-in-the-cloud" tabindex="-1"><a class="header-anchor" href="#data-protection-in-the-cloud"><span>Data Protection in the Cloud</span></a></h2><ul><li>클라우드에서는 데이터 유출 위협이 증가 <ul><li>클라우드 고유의 위험과 과제</li><li>클라우드 환경의 아키텍처 또는 운영 특성</li><li>Multi-instance model(다중 인스턴스 모델) <ul><li>각 클라우드 가입자에게 가상 머신 인스턴스에서 실행되는 고유한 DBMS를 제공</li><li>가입자에게 보안 관련 관리 작업에 대한 완전한 제어권을 부여</li><li>Multi-tenant model(다중 테넌트 모델) <ul><li>일반적으로 가입자 식별자로 데이터를 태그하여 다른 테넌트와 공유되는 사전 정의된 환경을 클라우드 가입자에게 제공</li><li>인스턴스를 독점적으로 사용하는 것처럼 보이지만, 안전한 데이터베이스 환경을 구축하고 유지하기 위해 클라우드 제공자에게 의존함.</li></ul></li></ul></li></ul></li></ul><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><ul><li>Database(데이터베이스): 구조화된 데이터 모음</li><li>데이터베이스 관리 시스템(DBMS): 데이터베이스를 구축하고 유지하기 위한 프로그램</li><li>SQL(Structured Query Language): 관계형 데이터베이스의 데이터를 정의/조작/query하는 데 사용되는 언어</li><li>관계형 데이터베이스: 행(튜플)과 열(속성)으로 구성된 데이터 테이블</li><li>데이터베이스 access control: 중앙 집중식/소유권 기반/분산 관리</li><li>역할 기반 access control(RBAC): 애플리케이션 소유자/애플리케이션 소유자 이외의 최종 사용자/관리자</li><li>Inference channel(추론 채널): 승인되지 않은 데이터가 획득되는 정보 전송 경로</li><li>통계 데이터베이스(SDB): query 제한/섭동/데이터 스와핑/무작위 표본 query</li><li>Database Encryption(데이터베이스 암호화)</li><li>클라우드 컴퓨팅/보안/데이터 보호</li><li>다중 인스턴스/다중 테넌트 모델</li></ul>`,78)])])}const m=s(i,[["render",n]]),d=JSON.parse('{"path":"/cs/6.html","title":"06. Database Security","lang":"ko-KR","frontmatter":{},"git":{},"filePathRelative":"cs/6.md"}');export{m as comp,d as data};
