import{_ as e,c as n,a,b as s,r as t,o}from"./app-De080F_6.js";const r={};function p(d,l){const i=t("home");return o(),n("div",null,[l[0]||(l[0]=a(`<h1 id="_8-lighting" tabindex="-1"><a class="header-anchor" href="#_8-lighting"><span>8 - Lighting</span></a></h1><h2 id="outline" tabindex="-1"><a class="header-anchor" href="#outline"><span>Outline</span></a></h2><ul><li>물체의 가시 색상 (Visible Color of Objects)</li><li>빛의 반사 (Reflection of Light)</li><li>Phong 조명 모델 (Phong Illumination Model)</li><li>다각형 쉐이딩 (Polygon Shading) <ul><li>면/정점 법선 (Face / Vertex Normal)</li><li>평면 / Gouraud / Phong 쉐이딩 (Flat / Gouraud / Phong Shading)</li></ul></li></ul><h2 id="visible-color-of-objects" tabindex="-1"><a class="header-anchor" href="#visible-color-of-objects"><span>Visible Color of Objects</span></a></h2><ul><li>빛이 물체에 닿으면, 일부는 흡수되고 일부는 반사됨</li><li>물체의 색상은 <strong>반사되는 빛의 파장</strong>에 따라 결정됨 <ul><li>예: 빨간 물체는 주로 빨간색 빛을 반사하고 나머지 파장은 흡수하므로 빨간색으로 보임</li></ul></li><li><strong>어떤 색이 흡수되고 반사되는지는 표면의 고유한 성질</strong>에 의해 결정됨</li></ul><h2 id="visible-color-of-objects-1" tabindex="-1"><a class="header-anchor" href="#visible-color-of-objects-1"><span>Visible Color of Objects</span></a></h2><ul><li>따라서, 물체의 가시 색상은 <strong>광원의 색상에 영향을 받음</strong></li></ul><blockquote><p>Room for one colour, Olafur Eliasson</p></blockquote><h2 id="computing-visible-color-of-objects" tabindex="-1"><a class="header-anchor" href="#computing-visible-color-of-objects"><span>Computing Visible Color of Objects</span></a></h2><ul><li><p>컴퓨터 그래픽스(CG)에서는 색상을 일반적으로 R, G, B 성분으로 표현함</p></li><li><p>광원 색상 (Light color): 광원에서 방출되는 각 색 성분의 세기</p><ul><li>예: (1, 1, 1) → 흰색 광원</li></ul></li><li><p>재질 색상 (Material color): 입사광에서 반사되는 각 색 성분의 비율</p><ul><li>예: (0.5, 0, 0) → 빨간색의 절반만 반사되고, 녹색과 파랑은 전부 흡수됨</li></ul></li><li><p><strong>빛과 재질의 RGB 성분을 성분별 곱셈 (element-wise multiplication)</strong> 하는 것이 <strong>표면 반사의 근사 모델</strong>로 적절함</p></li></ul><h2 id="computing-color-of-objects-examples" tabindex="-1"><a class="header-anchor" href="#computing-color-of-objects-examples"><span>Computing Color of Objects: Examples</span></a></h2><ul><li><p>예시:</p><ul><li>어떤 표면의 재질 색상이 (0.5, 0.8, 0.2)일 경우 <ul><li>이 표면은 입사광의 빨간색 50%, 녹색 80%, 파란색 20%를 반사함</li></ul></li></ul></li><li><p>광원 색상이 (1.0, 1.0, 1.0)일 경우 → 흰색 광원</p><ul><li>가시 표면 색상 = (0.5, 0.8, 0.2) (성분별 곱셈 결과)</li></ul></li><li><p>광원 색상이 (1.0, 0.0, 0.0)일 경우 → 빨간색 광원</p><ul><li>가시 표면 색상 = (0.5, 0.0, 0.0) → 더 어두운 빨간색 표면</li></ul></li></ul><h1 id="reflection-of-light" tabindex="-1"><a class="header-anchor" href="#reflection-of-light"><span>Reflection of Light</span></a></h1><h2 id="reflection-of-light-1" tabindex="-1"><a class="header-anchor" href="#reflection-of-light-1"><span>Reflection of Light</span></a></h2><ul><li><p>빛은 물체에 의해 흡수(absorbed), 발산(emitted), 산란(scattered), 반사(reflected), 굴절(refracted)될 수 있음</p></li><li><p><strong>산란과 반사</strong>는 불투명 물체 표면의 시각적 특성(예: 표면 색상, 하이라이트 등)을 결정하는 주요 요인</p></li><li><p>반사의 종류:</p><ul><li>Diffuse reflection (난반사)</li><li>Specular reflection (정반사) <ul><li>Ideal specular reflection</li><li>Non-ideal specular reflection (Glossy reflection)</li></ul></li></ul></li></ul><blockquote><p><em>컴퓨터 그래픽스에서는 산란과 반사를 모두 &quot;반사(reflection)&quot;로 통칭함</em></p></blockquote><h2 id="diffuse-reflection" tabindex="-1"><a class="header-anchor" href="#diffuse-reflection"><span>Diffuse Reflection</span></a></h2><ul><li><p>특정 파장의 빛을 <strong>모든 방향으로 고르게 산란</strong> → 표면 색상을 결정함</p></li><li><p><strong>시점에 무관한(view-independent)</strong> 특성</p></li><li><p>예:</p><ul><li>자홍색 파장을 강하게 산란</li><li>전 파장을 거의 균일하게 산란</li><li>모든 파장을 흡수 (산란 거의 없음)</li></ul></li></ul><h2 id="diffuse-reflection-lambert-s-cosine-law" tabindex="-1"><a class="header-anchor" href="#diffuse-reflection-lambert-s-cosine-law"><span>Diffuse Reflection - Lambert’s Cosine Law</span></a></h2><ul><li>작은 표면에서 반사되는 에너지는 <strong>입사광 방향과 표면 법선 사이의 각도의 cosine</strong>에 비례함</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I_reflected = I_incident × cos(θ)  </span>
<span class="line">             = I_incident × (N̂ · L̂)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>I_reflected: 반사광의 세기</li><li>I_incident: 입사광의 세기</li><li>N̂: 입사 지점에서의 표면 법선 벡터</li><li>L̂: 정규화된 입사광 벡터</li></ul><h2 id="diffuse-reflection-lambert-s-cosine-law-1" tabindex="-1"><a class="header-anchor" href="#diffuse-reflection-lambert-s-cosine-law-1"><span>Diffuse Reflection - Lambert’s Cosine Law</span></a></h2><ul><li>Lambert 법칙의 2D 시각화</li></ul><blockquote><p><em>이 이미지는 Brown 대학 Andy van Dam 교수 강의자료에서 인용됨</em><br> http://cs.brown.edu/courses/cs1230/lectures.shtml</p></blockquote><h2 id="ideal-specular-reflection" tabindex="-1"><a class="header-anchor" href="#ideal-specular-reflection"><span>Ideal Specular Reflection</span></a></h2><ul><li><p>매끄럽고 평탄한 표면에서 <strong>거울과 같은 반사</strong> 발생<br> → 거울상의 이미지 생성</p></li><li><p><strong>시점 의존적(view-dependent)</strong> 특성</p></li></ul><h2 id="ideal-specular-reflection-laws-of-reflection" tabindex="-1"><a class="header-anchor" href="#ideal-specular-reflection-laws-of-reflection"><span>Ideal Specular Reflection - Laws of Reflection</span></a></h2><ul><li><p>N̂, L̂, R̂은 동일한 평면상에 존재</p></li><li><p>입사각 θᵢ = 반사각 θᵣ</p></li><li><p>L̂과 R̂은 N̂의 양쪽에 위치</p></li><li><p>기호 설명:</p><ul><li>N̂: 입사 지점에서의 표면 법선</li><li>L̂: 정규화된 입사광 벡터</li><li>R̂: 정규화된 반사광 벡터</li></ul></li></ul><h2 id="non-ideal-specular-reflection-a-k-a-glossy-reflection" tabindex="-1"><a class="header-anchor" href="#non-ideal-specular-reflection-a-k-a-glossy-reflection"><span>Non-Ideal Specular Reflection (a.k.a. Glossy Reflection)</span></a></h2><ul><li><p>광택이 있으나 거울처럼 완전히 매끄럽지 않은 표면에서의 반사</p><ul><li>표면의 거칠기로 인해 반사광이 퍼짐</li><li>밝은 하이라이트 생성</li></ul></li><li><p><strong>시점 의존적(view-dependent)</strong> 특성</p></li></ul><h2 id="reflection-of-general-materials" tabindex="-1"><a class="header-anchor" href="#reflection-of-general-materials"><span>Reflection of General Materials</span></a></h2><ul><li>대부분의 재질 표면은 <strong>diffuse reflection</strong>과 <strong>(비이상적인) specular reflection</strong>을 동시에 가짐</li></ul><blockquote><p>Total Scattering = Diffuse + Specular<br> → 전체 산란 분포는 두 반사의 합으로 구성됨</p></blockquote><blockquote><p><em>이 이미지는 Brown 대학 Andy van Dam 교수 강의자료에서 인용됨</em><br> http://cs.brown.edu/courses/cs1230/lectures.shtml</p></blockquote><h2 id="quiz-1" tabindex="-1"><a class="header-anchor" href="#quiz-1"><span>Quiz 1</span></a></h2><h1 id="phong-illumination-model" tabindex="-1"><a class="header-anchor" href="#phong-illumination-model"><span>Phong Illumination Model</span></a></h1><h2 id="lighting-or-illumination" tabindex="-1"><a class="header-anchor" href="#lighting-or-illumination"><span>Lighting (or Illumination)</span></a></h2><ul><li><p>컴퓨터 그래픽스에서 lighting (또는 illumination)은<br> 빛의 효과를 계산하는 과정을 의미함</p><p>→ 물체 표면 색상 및 하이라이트 계산</p></li></ul><h2 id="phong-illumination-model-1" tabindex="-1"><a class="header-anchor" href="#phong-illumination-model-1"><span>Phong Illumination Model</span></a></h2><ul><li>컴퓨터 그래픽스에서 가장 널리 사용되는 “고전적” 조명 모델 중 하나 <ul><li>실험적(empirical) 모델이며, 물리 기반 모델은 아님</li></ul></li></ul><blockquote><p>Bùi Tường Phong (1942 – 1975)</p></blockquote><h2 id="phong-illumination-model-2" tabindex="-1"><a class="header-anchor" href="#phong-illumination-model-2"><span>Phong Illumination Model</span></a></h2><ul><li>세 가지 구성 요소: <ul><li><strong>Ambient</strong><ul><li>비특정한 일정한 전역 조명</li><li>간접 조명에 대한 조잡한 근사</li></ul></li><li><strong>Diffuse</strong><ul><li>Lambert 법칙을 따르는 난반사 모델</li><li>표면 색상 결정</li></ul></li><li><strong>Specular</strong><ul><li>cosⁿ(α)을 이용한 광택 반사 근사</li><li>빛나는 물체의 하이라이트 계산</li></ul></li></ul></li></ul><blockquote><p>Ambient + Diffuse + Specular = Phong Reflection</p></blockquote><h2 id="phong-illumination-model-3" tabindex="-1"><a class="header-anchor" href="#phong-illumination-model-3"><span>Phong Illumination Model</span></a></h2><ul><li><p>이제부터 각 지점에서 <strong>Phong 조명 모델의 각 구성 요소</strong>(ambient, diffuse, specular)의 색을 계산하는 방법을 살펴봄</p></li><li><p>이 지점은 다음 중 하나일 수 있음:</p><ul><li>다각형의 정점</li><li>다각형 내부의 임의 지점 (필름 공간의 픽셀에 해당)</li></ul></li></ul><h2 id="ambient-component" tabindex="-1"><a class="header-anchor" href="#ambient-component"><span>Ambient Component</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">Iₐ = lₐ * mₐ</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>lₐ: 광원의 ambient 색</li><li>mₐ: 표면 지점의 재질 ambient 색</li><li>Iₐ: 최종 ambient 색 결과</li><li>*: 성분별 곱셈 (element-wise multiplication)</li></ul><h2 id="result" tabindex="-1"><a class="header-anchor" href="#result"><span>Result</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I = lₐ * mₐ</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p><em>이 이미지는 텍사스 A&amp;M 대학교의 Huamin Qu 교수 슬라이드에서 인용됨</em><br> http://faculty.cs.tamu.edu/schaefer/CSCE441/notes.html</p></blockquote><h2 id="diffuse-component" tabindex="-1"><a class="header-anchor" href="#diffuse-component"><span>Diffuse Component</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I_d = l_d * m_d * cos(θ) = l_d * m_d * (L · N)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p>L: 광원 방향 벡터</p></li><li><p>N: 표면 법선 벡터</p><ul><li>L과 N은 단위 벡터(unit vector)</li></ul></li><li><p>· : 내적(dot product)</p></li><li><p>l_d: 광원의 diffuse 색상</p></li><li><p>m_d: 재질의 diffuse 색상</p></li><li><p>I_d: 표면 지점에서의 diffuse 결과 색상</p></li></ul><h2 id="result-1" tabindex="-1"><a class="header-anchor" href="#result-1"><span>Result</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I = lₐ * mₐ</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>(그림: ambient 성분만 적용된 렌더링 결과)</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I = lₐ * mₐ + l_d * m_d * (L · N)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>(그림: ambient + diffuse 성분 적용)</p><h2 id="specular-component" tabindex="-1"><a class="header-anchor" href="#specular-component"><span>Specular Component</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I_s = l_s * m_s * cosⁿ(α) = l_s * m_s * (V · R)ⁿ</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p>V: 시점(view) 방향 벡터</p></li><li><p>R: 반사 방향 벡터</p><ul><li>V와 R은 단위 벡터</li></ul></li><li><p>n: 광택 계수 (shininess coefficient)</p></li><li><p>l_s: 광원의 specular 색상</p></li><li><p>m_s: 재질의 specular 색상</p></li><li><p>I_s: 표면 지점에서의 specular 결과 색상</p></li></ul><h2 id="result-2" tabindex="-1"><a class="header-anchor" href="#result-2"><span>Result</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I = lₐ * mₐ</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>(그림: ambient 성분만 적용된 렌더링)</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I = lₐ * mₐ + l_d * m_d * (L · N)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>(그림: ambient + diffuse 성분 적용)</p><h2 id="result-3" tabindex="-1"><a class="header-anchor" href="#result-3"><span>Result</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I = lₐ * mₐ + l_d * m_d * (L · N) + l_s * m_s * (V · R)ⁿ</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>n = 5</li></ul><p>(그림: ambient + diffuse + specular, n=5)</p><h2 id="result-4" tabindex="-1"><a class="header-anchor" href="#result-4"><span>Result</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I = lₐ * mₐ + l_d * m_d * (L · N) + l_s * m_s * (V · R)ⁿ</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>n = 50</li></ul><p>(그림: ambient + diffuse + specular, n=50)</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">I = lₐ * mₐ + l_d * m_d * (L · N) + l_s * m_s * (V · R)ⁿ</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>n = 500</li></ul><p>(그림: 광택 계수 n이 커질수록 specular highlight가 좁아짐)</p><h2 id="demo-phong-illumination" tabindex="-1"><a class="header-anchor" href="#demo-phong-illumination"><span>[Demo] Phong Illumination</span></a></h2><ul><li><p>http://www.cs.toronto.edu/~jacobson/phong-demo/</p></li><li><p>“Phong Shading”을 선택한 후 다음 요소들을 바꿔보며 실험</p><ul><li>ambient, diffuse, specular 계수 및 색상</li><li>광택 계수 (shininess)</li><li>물체 종류, 광원 위치, 배경색 등도 변경 가능</li></ul></li></ul><h2 id="quiz-2" tabindex="-1"><a class="header-anchor" href="#quiz-2"><span>Quiz 2</span></a></h2><h1 id="polygon-shading" tabindex="-1"><a class="header-anchor" href="#polygon-shading"><span>Polygon Shading</span></a></h1><h2 id="shading" tabindex="-1"><a class="header-anchor" href="#shading"><span>Shading</span></a></h2><ul><li>물체 표면에 나타나는 색상 분포의 변화 <ul><li>조명의 영향을 강하게 받음</li></ul></li></ul><p>(그림: 조명 조건에 따라 표면의 색상이 다르게 보임)</p><ul><li><p>컴퓨터 그래픽스에서 shading이라는 용어는 다음을 설명함:</p><ul><li>조명 모델로 인해 발생하는 표면 색상의 변화</li><li>또는 다각형 내부의 픽셀 색상 변화</li></ul></li><li><p>현재 다루는 의미는 후자임<br> → 혼동을 피하기 위해 <strong>polygon shading</strong>이라는 용어를 사용함</p></li><li><p><strong>Polygon shading</strong>:<br> 조명 모델을 기반으로 다각형 내부 각 픽셀의 색상을 결정하는 과정</p></li></ul><h2 id="surface-normal" tabindex="-1"><a class="header-anchor" href="#surface-normal"><span>Surface Normal</span></a></h2><ul><li><p>특정 지점에서 표면에 수직인 벡터<br> → 일반적으로 단위 벡터 사용 (길이 = 1)</p></li><li><p>shading 및 조명 계산에서 핵심적인 역할</p></li><li><p>Diffuse reflection:</p><ul><li>Lambert의 코사인 법칙 적용</li></ul></li><li><p>Specular reflection:</p><ul><li>반사의 법칙 적용</li></ul></li></ul><p>(수식 포함된 그림: 코사인 법칙과 반사 각도)</p><h2 id="face-normal" tabindex="-1"><a class="header-anchor" href="#face-normal"><span>Face Normal</span></a></h2><ul><li><p><strong>다각형 면의 surface normal을 얻는 방법</strong></p></li><li><p>정점의 순서는 중요함!</p></li><li><p>삼각형 &lt;p₁, p₂, p₃&gt;의 법선은 다음과 같이 계산됨:</p><ul><li><code>v₁ × v₂</code><ul><li>v₁: p₁에서 p₂로 향하는 벡터</li><li>v₂: p₁에서 p₃로 향하는 벡터</li></ul></li></ul></li><li><p><strong>그래서 정점의 시계 반대 방향(counterclockwise) 나열이 중요함</strong></p><ul><li>Face normal의 방향이 표면 &quot;바깥쪽&quot;을 향하게 하기 위해</li></ul></li></ul><blockquote><p><em>이 이미지는 한양대 정재형 교수 강의자료에서 인용됨</em></p></blockquote><h2 id="flat-shading" tabindex="-1"><a class="header-anchor" href="#flat-shading"><span>Flat Shading</span></a></h2><ul><li><p>다각형당 하나의 법선(normal)을 사용</p></li><li><p>다각형당 한 번만 색상 계산</p></li><li><p>빠르지만 곡면 표현에는 부적합</p><ul><li>다각형 수를 아무리 늘려도 여전히 &quot;각져 보임(faceted)&quot;</li></ul></li></ul><h2 id="smooth-shading" tabindex="-1"><a class="header-anchor" href="#smooth-shading"><span>Smooth Shading</span></a></h2><ul><li><p>꼭짓점마다 평균 낸 법선 벡터 사용</p></li><li><p>인접 다각형 간 부드러운 색상 전환 가능</p></li><li><p>방법:</p><ul><li>Gouraud shading</li><li>Phong shading</li></ul></li></ul><h2 id="gouraud-shading" tabindex="-1"><a class="header-anchor" href="#gouraud-shading"><span>Gouraud Shading</span></a></h2><ul><li>꼭짓점마다 하나의 vertex normal 사용</li><li>각 꼭짓점에서 조명 모델로 색상을 계산</li><li>다각형 내부는 꼭짓점 색상을 보간하여 색상 결정 <ul><li>Barycentric interpolation 사용</li></ul></li></ul><blockquote><p>Henri Gouraud (1944–)</p></blockquote><p>(이미지: Flat shading vs Gouraud shading 비교)</p><ul><li>문제점: <strong>specular highlight가 부정확하게 표현됨</strong><ul><li>하이라이트가 왜곡되거나 아예 사라질 수 있음</li><li>다각형 수를 늘리면 이러한 문제는 줄어듦</li></ul></li></ul><h2 id="phong-shading" tabindex="-1"><a class="header-anchor" href="#phong-shading"><span>Phong Shading</span></a></h2><ul><li>꼭짓점마다 하나의 vertex normal 사용</li><li>다각형 내부는 vertex normal을 보간(interpolation)</li><li>보간된 normal을 사용하여 <strong>각 픽셀에서 색상을 계산</strong></li></ul><blockquote><p>Bùi Tường Phong (1942–1975)</p></blockquote><p>(이미지: Gouraud shading vs Phong shading 비교)</p><ul><li><p><strong>하이라이트를 훨씬 더 정확히 표현함</strong></p><ul><li>내부 픽셀마다 보간된 normal은 해당 지점의 실제 표면 normal을 더 잘 근사함</li><li>품질은 좋지만 계산량이 더 많음</li></ul></li><li><p><strong>Phong의 조명 모델과 혼동하지 말 것</strong></p><ul><li>동일 인물이 개발했지만 다른 개념</li></ul></li></ul><h2 id="demo-polygon-shading" tabindex="-1"><a class="header-anchor" href="#demo-polygon-shading"><span>[Demo] Polygon Shading</span></a></h2><ul><li><p>Flat &amp; Gouraud shading</p><ul><li>http://math.hws.edu/graphicsbook/demos/c4/smooth-vs-flat.html</li></ul></li><li><p>Gouraud &amp; Phong shading</p><ul><li>http://www.cs.toronto.edu/~jacobson/phong-demo/</li></ul></li></ul><h2 id="normal-vector-transformation" tabindex="-1"><a class="header-anchor" href="#normal-vector-transformation"><span>Normal Vector Transformation</span></a></h2><ul><li><p>어떤 표면 위 점들의 집합에 affine 변환 M이 적용되면,</p><ul><li><strong>접선 벡터(tangent)는 M에 의해 변환됨</strong><ul><li>점 간의 차이도 M에 의해 변환되기 때문</li></ul></li></ul></li><li><p>그러나 <strong>법선 벡터(normal)는 M에 의해 변환되어서는 안 됨</strong></p><ul><li>법선은 접선에 수직이어야 하기 때문</li></ul></li></ul><p>(그림 설명)</p><ul><li>위: 도형에 M 적용 → OK</li><li>중간: 법선에 M 적용 → (X)</li><li>아래: 법선에 다른 변환 적용 → (O)</li></ul><p>(그림 및 수식 설명)</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">t · n = tᵀn = 0 (기존 수직 조건)</span>
<span class="line"></span>
<span class="line">원하는 조건: Mt · Xn = tᵀ Mᵀ Xn = 0  </span>
<span class="line">→ X = (Mᵀ)⁻¹ 로 설정  </span>
<span class="line">→ Mt · Xn = tᵀ Mᵀ (Mᵀ)⁻¹ n = tᵀn = 0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>결론:<br><strong>X = (Mᵀ)⁻¹</strong></p></li><li><p>기호:</p><ul><li>t: 접선 벡터</li><li>n: 법선 벡터</li></ul></li></ul>`,117)),s(i)])}const c=e(r,[["render",p]]),h=JSON.parse('{"path":"/computer-graphics/8-Lighting.html","title":"8 - Lighting","lang":"ko-KR","frontmatter":{},"git":{},"filePathRelative":"computer-graphics/8-Lighting.md"}');export{c as comp,h as data};
