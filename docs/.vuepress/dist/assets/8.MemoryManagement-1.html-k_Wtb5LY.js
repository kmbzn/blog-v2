import{_ as n,c as s,a as e,o as i}from"./app-JAo_gOXj.js";const l={};function r(d,a){return i(),s("div",null,a[0]||(a[0]=[e(`<h1 id="_8-memory-management-1" tabindex="-1"><a class="header-anchor" href="#_8-memory-management-1"><span>8. Memory Management(1)</span></a></h1><h2 id="background" tabindex="-1"><a class="header-anchor" href="#background"><span>Background</span></a></h2><ul><li>프로그램은 디스크에서 메모리로 불러온 후, 프로세스 내에 위치해야 실행될 수 있음</li><li>main memory와 register만이 CPU가 직접 접근 가능한 저장 장치임</li><li>register 접근은 CPU clock cycle 1회 (또는 그 이하)</li><li>main memory 접근은 여러 cycle이 소요될 수 있음</li><li><strong>cache</strong>는 main memory와 CPU register 사이에 위치</li><li>올바른 동작을 보장하기 위해 메모리 보호가 필요함</li></ul><h2 id="multistep-processing-of-a-user-program" tabindex="-1"><a class="header-anchor" href="#multistep-processing-of-a-user-program"><span>Multistep Processing of a User Program</span></a></h2><p>사용자 프로그램은 메모리에서 실행되기 전까지 여러 단계를 거침</p><blockquote><p>source program<br> ↓ (compiler 또는 assembler)<br> object module<br> ↓ (linker 또는 linkage editor)<br> executable module<br> ↓ (loader)<br> memory image<br> ↓<br> 실행</p></blockquote><h2 id="process-in-memory-address-space" tabindex="-1"><a class="header-anchor" href="#process-in-memory-address-space"><span>Process in Memory: Address Space</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">    max</span>
<span class="line">  +--------+</span>
<span class="line">  | stack  |</span>
<span class="line">  +--------+</span>
<span class="line">  |  heap  |</span>
<span class="line">  +--------+</span>
<span class="line">  |  data  |</span>
<span class="line">  +--------+</span>
<span class="line">  |  text  |</span>
<span class="line">  +--------+</span>
<span class="line">    0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="binding-of-instructions-and-data-to-memory" tabindex="-1"><a class="header-anchor" href="#binding-of-instructions-and-data-to-memory"><span>Binding of Instructions and Data to Memory</span></a></h2><h3 id="compile-time-binding" tabindex="-1"><a class="header-anchor" href="#compile-time-binding"><span>Compile time binding</span></a></h3><ul><li>이 시점에 각 symbol의 <strong>절대 주소</strong>가 결정되어야 함</li><li><strong>절대 주소를 포함한 absolute code가 생성됨</strong></li><li>시작 위치가 바뀌면 <strong>코드를 다시 컴파일해야 함</strong></li></ul><h3 id="load-time-binding" tabindex="-1"><a class="header-anchor" href="#load-time-binding"><span>Load time binding</span></a></h3><ul><li>loader가 각 symbol에 대한 절대 주소를 할당</li><li>compiler는 <strong>상대 주소를 포함한 relocatable code</strong>를 생성함</li></ul><h3 id="execution-time-binding" tabindex="-1"><a class="header-anchor" href="#execution-time-binding"><span>Execution time binding</span></a></h3><ul><li>실행 중일 때, 프로세스가 메모리 내 위치를 변경할 경우 사용됨</li><li>CPU가 주소를 생성할 때마다 **주소 변환(address mapping)**이 필요</li><li><strong>하드웨어 지원 필요</strong> (예: base and limit register, MMU)</li></ul><h2 id="address-mapping-table" tabindex="-1"><a class="header-anchor" href="#address-mapping-table"><span>Address Mapping Table</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">          CPU</span>
<span class="line">    논리적 주소 (logical)    →    물리적 주소 (physical)</span>
<span class="line">    ---------------------      -------------------------</span>
<span class="line">        0번지                    →     500번지</span>
<span class="line">      500번지                    →   20000번지</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CPU가 제시한 주소 = 논리 메모리 내 주소<br> 실제 메모리에서의 위치 = 물리 메모리 내 주소<br> 예: 논리 주소 <code>500</code> → 물리 주소 <code>20500</code></p><h1 id="contiguous-allocation-cont" tabindex="-1"><a class="header-anchor" href="#contiguous-allocation-cont"><span>Contiguous Allocation (Cont.)</span></a></h1><ul><li>Hole: 사용 가능한 메모리 블록 <ul><li>다양한 크기의 hole(빈 공간)은 메모리 전반에 흩어져 있음</li><li>프로세스가 도착하면, 해당 요청을 수용할 수 있는 크기의 hole에서 메모리가 할당됨</li></ul></li><li>운영체제는 다음 정보를 유지함: <ul><li>a) 할당된 공간</li><li>b) 빈 공간 (hole)</li></ul></li></ul><h2 id="dynamic-storage-allocation-problem" tabindex="-1"><a class="header-anchor" href="#dynamic-storage-allocation-problem"><span>Dynamic Storage-Allocation Problem</span></a></h2><ul><li><p>요청 크기 <code>n</code>을 충족시키기 위해 hole 리스트에서 어떻게 할당할 것인가</p></li><li><p><strong>First-fit</strong></p><ul><li>충분히 큰 <strong>첫 번째 hole</strong>에 할당</li></ul></li><li><p><strong>Best-fit</strong></p><ul><li>충분히 큰 <strong>가장 작은 hole</strong>에 할당</li><li>전체 리스트를 탐색해야 함 (정렬된 경우 예외)</li><li><strong>많은 작은 leftover hole</strong>을 생성함</li></ul></li><li><p><strong>Worst-fit</strong></p><ul><li><strong>가장 큰 hole</strong>에 할당</li><li>역시 전체 리스트를 탐색해야 함</li><li><strong>가장 큰 leftover hole</strong>을 생성</li></ul></li></ul><blockquote><p>저장 공간 활용 측면에서 First-fit 및 Best-fit이 Worst-fit보다 더 효율적임</p></blockquote><h2 id="fragmentation" tabindex="-1"><a class="header-anchor" href="#fragmentation"><span>Fragmentation</span></a></h2><ul><li><p><strong>External fragmentation</strong></p><ul><li>전체 메모리 공간은 요청을 만족할 수 있을 만큼 있지만, <strong>연속적이지 않음</strong></li></ul></li><li><p><strong>Internal fragmentation</strong></p><ul><li>할당된 메모리는 실제 요청보다 약간 클 수 있음 → 이 크기 차이가 <strong>internal fragmentation</strong> (파티션 내부 메모리이나 사용되지 않음)</li></ul></li><li><p>외부 단편화를 줄이는 방법: <strong>compaction</strong></p><ul><li>메모리 내 내용을 섞어 모든 빈 공간을 하나의 큰 블록으로 만듦</li><li>단, relocation이 <strong>동적으로 가능하고 실행 시간에 수행될 경우</strong>에만 compaction 가능</li></ul></li></ul><h2 id="paging" tabindex="-1"><a class="header-anchor" href="#paging"><span>Paging</span></a></h2><ul><li><p><strong>Paging</strong></p><ul><li>주소 공간을 <strong>비연속적으로 만들 수 있게 하는</strong> 스킴</li></ul></li><li><p>기본 방식</p><ul><li>물리 메모리를 <strong>고정 크기 블록(frame)</strong> 으로 나눔<br> (크기는 2의 제곱수, 512B ~ 8MB)</li><li>논리 메모리를 <strong>같은 크기의 블록(page)</strong> 으로 나눔</li><li>모든 frame의 상태를 추적</li><li>프로그램 실행 시, <code>n</code>개의 페이지에 대해 <code>n</code>개의 빈 frame과 page table이 필요</li><li><strong>페이지 테이블</strong>을 통해 논리 주소를 물리 주소로 변환</li><li><strong>내부 단편화는 있으나 외부 단편화는 없음</strong></li></ul></li></ul><h2 id="paging-1" tabindex="-1"><a class="header-anchor" href="#paging-1"><span>Paging</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">  max</span>
<span class="line">   │</span>
<span class="line">   ▼</span>
<span class="line"> ┌────────────┐</span>
<span class="line"> │   stack    │</span>
<span class="line"> ├────────────┤</span>
<span class="line"> │    ...     │   ← pages</span>
<span class="line"> ├────────────┤</span>
<span class="line"> │   heap     │</span>
<span class="line"> ├────────────┤</span>
<span class="line"> │   data     │</span>
<span class="line"> ├────────────┤</span>
<span class="line"> │   text     │</span>
<span class="line"> └────────────┘</span>
<span class="line">Process Address Space</span>
<span class="line"></span>
<span class="line">         │</span>
<span class="line">         ▼</span>
<span class="line">┌──┬──┬──┬──┬──┬──┬──┐</span>
<span class="line">│  │  │  │  │  │  │  │  ← (page) frames</span>
<span class="line">└──┴──┴──┴──┴──┴──┴──┘</span>
<span class="line">   Physical Memory</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="address-translation-scheme-in-paging" tabindex="-1"><a class="header-anchor" href="#address-translation-scheme-in-paging"><span>Address Translation Scheme in Paging</span></a></h2><ul><li><p>CPU가 생성하는 주소는 다음 두 부분으로 나뉨:</p><ul><li><p><strong>Page number (p)</strong><br> → 페이지 테이블에서 물리 메모리의 각 페이지에 해당하는 base address를 찾는 인덱스로 사용됨</p></li><li><p><strong>Page offset (d)</strong><br> → base address에 더해 실제 메모리 접근 주소를 결정</p></li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">주소 구조:</span>
<span class="line"></span>
<span class="line">  page number   page offset</span>
<span class="line">  ┌───────┬────────────────┐</span>
<span class="line">  │   p   │       d        │</span>
<span class="line">  └───────┴────────────────┘</span>
<span class="line">     (m-n)비트       n비트</span>
<span class="line"></span>
<span class="line">- 논리 주소 공간이 $2^m$일 때, 페이지 크기가 $2^n$이면</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="address-translation-architecture" tabindex="-1"><a class="header-anchor" href="#address-translation-architecture"><span>Address Translation Architecture</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">CPU</span>
<span class="line"> ↓</span>
<span class="line">┌─────────────┐</span>
<span class="line">│ logical addr│</span>
<span class="line">└────┬────────┘</span>
<span class="line">     ↓</span>
<span class="line">┌─────────────┐</span>
<span class="line">│ Page Table  │</span>
<span class="line">└────┬────────┘</span>
<span class="line">     ↓</span>
<span class="line">┌──────────────┐</span>
<span class="line">│ physical addr│</span>
<span class="line">└──────────────┘</span>
<span class="line">              ↓</span>
<span class="line">     Physical Memory</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="paging-example" tabindex="-1"><a class="header-anchor" href="#paging-example"><span>Paging Example</span></a></h2><ul><li><p>Page Number = 2 / 4 = 0</p></li><li><p>Offset = 2 % 4 = 2</p></li><li><p>Logical address (m): 4비트</p></li><li><p>Page number (m-n): 2비트</p></li><li><p>Offset (n): 2비트</p></li><li><p><strong>4바이트 페이지 → n = 2비트</strong></p></li></ul><h2 id="free-frames" tabindex="-1"><a class="header-anchor" href="#free-frames"><span>Free Frames</span></a></h2><ul><li>(a) 할당 전</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">free-frame list: 18 3 14 9 6 ...</span>
<span class="line">new process: page 0, page 1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>(b) 할당 후</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">free-frame list: 13 8 10 ...</span>
<span class="line">new process:</span>
<span class="line">  page 0 → frame 14</span>
<span class="line">  page 1 → frame 9</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="implementation-of-page-table" tabindex="-1"><a class="header-anchor" href="#implementation-of-page-table"><span>Implementation of Page Table</span></a></h2><ul><li><p>페이지 테이블은 <strong>주기억장치에 저장됨</strong></p><ul><li>Page-table base register (PTBR): 페이지 테이블을 가리킴</li><li>Page-table length register (PTLR): 테이블의 크기를 나타냄</li></ul></li><li><p><strong>문제점</strong>: 메모리 접근마다 <strong>두 번의 접근</strong>이 필요함</p><ul><li>하나는 페이지 테이블, 다른 하나는 데이터/명령어 접근</li></ul></li><li><p><strong>해결책</strong>: <strong>TLB</strong>(Translation Look-aside Buffer) 또는 <strong>Associative memory</strong> 사용</p><ul><li>일반적으로, TLB는 <strong>컨텍스트 전환 시 플러시</strong>됨 (이전 항목 제거)</li><li>일부 TLB는 <strong>ASID</strong>(Address-Space Identifiers)를 저장하여 플러시를 피함<br> → 각 프로세스의 주소 공간 보호 지원</li></ul></li></ul><h2 id="associative-memory-tlb" tabindex="-1"><a class="header-anchor" href="#associative-memory-tlb"><span>Associative Memory (TLB)</span></a></h2><ul><li><p>두 가지 종류의 메모리:</p><ol><li><strong>일반 메모리</strong> (예: DRAM) <ul><li>주소를 주면 데이터를 반환</li></ul></li><li><strong>연관 메모리</strong> (Associative memory) <ul><li>데이터 일부를 주면 전체 레코드를 반환 (ex: 전화번호부)</li><li>병렬 탐색 없이는 느림, 구현 비용이 큼</li></ul></li></ol></li><li><p><strong>Associative Memory (TLB)</strong>: 병렬 탐색<br> → 페이지 테이블의 일부만 TLB에 저장됨</p></li><li><p>주소 변환 과정 (p, d)</p><ul><li>페이지 번호 p를 TLB에서 먼저 찾음 <ul><li>존재하면 해당 frame 반환</li><li>없으면 페이지 테이블에서 frame 번호 검색</li></ul></li></ul></li></ul><h2 id="paging-hardware-with-tlb" tabindex="-1"><a class="header-anchor" href="#paging-hardware-with-tlb"><span>Paging Hardware with TLB</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">           logical address</span>
<span class="line">                ↓</span>
<span class="line">               ┌───┐</span>
<span class="line">               │ p │────┐</span>
<span class="line">               └───┘    │</span>
<span class="line">                        ↓</span>
<span class="line">                     ┌──────┐</span>
<span class="line">               ┌────▶│ TLB  │────┐</span>
<span class="line">               │     └──────┘    ↓</span>
<span class="line">               │            ┌────────────┐</span>
<span class="line">               │            │ Page Table │</span>
<span class="line">               │            └────────────┘</span>
<span class="line">               ↓                    ↓</span>
<span class="line">             ┌────┐             ┌──────┐</span>
<span class="line">             │  d │────────────▶│ + d  │</span>
<span class="line">             └────┘             └──────┘</span>
<span class="line">                                ↓</span>
<span class="line">                         Physical Memory</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="effective-access-time" tabindex="-1"><a class="header-anchor" href="#effective-access-time"><span>Effective Access Time</span></a></h2><ul><li><p>연관 메모리(associative memory) 탐색 시간 = α time unit</p></li><li><p>메모리 접근 시간 = β</p></li><li><p><strong>Hit ratio = ε</strong> (연관 메모리에서 찾은 비율)</p></li><li><p>유효 접근 시간 (EAT: Effective Access Time)</p></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&lt;히트 시&gt; + &lt;미스 시&gt;</span>
<span class="line">EAT = (α + β) * ε + (α + 2β) * (1 − ε)</span>
<span class="line">    = α + (2 − ε)β</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="memory-protection" tabindex="-1"><a class="header-anchor" href="#memory-protection"><span>Memory Protection</span></a></h2><ul><li>메모리 보호는 각 frame에 보호 비트(protection bit)를 연결하여 구현</li><li><strong>Valid-invalid 비트</strong>: 페이지 테이블의 각 항목에 포함 <ul><li><strong>&quot;valid&quot;</strong>: 해당 페이지가 유효 (사용 가능한 page) <ul><li>프로세스의 논리 주소 공간에 포함됨</li></ul></li><li><strong>&quot;invalid&quot;</strong>: 접근이 허용되지 않음 (해당 주소는 불법)</li></ul></li></ul><h2 id="valid-v-or-invalid-i-bit-in-a-page-table" tabindex="-1"><a class="header-anchor" href="#valid-v-or-invalid-i-bit-in-a-page-table"><span>Valid (v) or Invalid (i) Bit in a Page Table</span></a></h2><ul><li>페이지 크기 = 2KB</li><li>주소 범위: 0 ~ 10468만 사용</li><li>총 6개 페이지만 사용됨 (10469 / 2048 = 약 6)</li><li>페이지 테이블에서는 6개의 항목만 유효</li><li>PTLR(Page Table Length Register)을 사용하여 valid-invalid bit 대신 유효성을 검사할 수 있음</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">logical address → 00000</span>
<span class="line">                → frame number</span>
<span class="line">                → valid-invalid bit</span>
<span class="line"></span>
<span class="line">페이지 테이블:</span>
<span class="line">page 0 → valid</span>
<span class="line">page 1 → valid</span>
<span class="line">...</span>
<span class="line">page 4 → valid</span>
<span class="line">page 5 → valid</span>
<span class="line">page 6 이상 → invalid</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="shared-pages" tabindex="-1"><a class="header-anchor" href="#shared-pages"><span>Shared Pages</span></a></h2><ul><li><p><strong>Shared code</strong></p><ul><li>읽기 전용 (read-only, <strong>재진입 가능</strong>) 코드</li><li>여러 프로세스가 공유 (예: 텍스트 편집기, 컴파일러, 윈도우 시스템)</li><li>공유 코드는 <strong>논리 주소 공간의 동일한 위치</strong>에 있어야 함 <ul><li>공유 코드에서의 <strong>자기 참조</strong>가 가능하도록 하기 위함</li></ul></li></ul></li><li><p><strong>Private code and data</strong></p><ul><li>각 프로세스는 <strong>개별 복사본</strong>을 유지</li><li>해당 코드는 논리 주소 공간 내 <strong>임의의 위치</strong>에 존재할 수 있음</li></ul></li></ul><h2 id="shared-pages-example" tabindex="-1"><a class="header-anchor" href="#shared-pages-example"><span>Shared Pages Example</span></a></h2><ul><li>에디터는 3개의 페이지로 구성 (ed1, ed2, ed3)</li><li>ed1~ed3는 공유 코드</li><li>나머지 데이터 페이지는 프로세스 별로 분리됨</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">process P1:</span>
<span class="line">  page table → ed1</span>
<span class="line">              ed2</span>
<span class="line">              ed3</span>
<span class="line">              data1</span>
<span class="line">              data2</span>
<span class="line"></span>
<span class="line">process P2:</span>
<span class="line">  page table → ed1</span>
<span class="line">              ed2</span>
<span class="line">              ed3</span>
<span class="line">              data3</span>
<span class="line"></span>
<span class="line">process P3:</span>
<span class="line">  page table → ed1</span>
<span class="line">              ed2</span>
<span class="line">              ed3</span>
<span class="line">              ...</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="memorymanagement-1-교수님-강의-내용-요약" tabindex="-1"><a class="header-anchor" href="#memorymanagement-1-교수님-강의-내용-요약"><span>MemoryManagement-1 교수님 강의 내용 요약</span></a></h1><h2 id="address-binding" tabindex="-1"><a class="header-anchor" href="#address-binding"><span>Address Binding</span></a></h2><ul><li>모든 instruction과 함수 이름은 주소를 가짐</li><li>CPU는 instruction을 fetch 및 실행하며 주소 정보를 필요로 함</li><li>주소를 결정하는 주체는 <strong>compiler</strong></li></ul><h2 id="binding-종류" tabindex="-1"><a class="header-anchor" href="#binding-종류"><span>Binding 종류</span></a></h2><table><thead><tr><th>시점</th><th>설명</th></tr></thead><tbody><tr><td>Compile Time</td><td>physical address를 직접 코드에 삽입 (kernel 이후 주소부터)</td></tr><tr><td>Load Time</td><td>로딩 시 physical address를 삽입</td></tr><tr><td>Execution Time</td><td>실행 시 주소 변환 수행 (가장 유연, modern OS에서 사용)</td></tr></tbody></table><ul><li>Execution Time Binding에서는 주소를 <strong>실시간으로 변환</strong></li><li>이 작업을 빠르게 하기 위해 <strong>MMU (Memory Management Unit)</strong> 사용</li></ul><h2 id="mmu의-역할" tabindex="-1"><a class="header-anchor" href="#mmu의-역할"><span>MMU의 역할</span></a></h2><ul><li>Logical Address + Base Address = Physical Address</li><li>덧셈 연산만으로 처리됨 (오버헤드 낮음)</li><li>Protection: limit register를 사용하여 접근 범위 제한</li></ul><h1 id="메모리-단편화-문제와-paging-도입" tabindex="-1"><a class="header-anchor" href="#메모리-단편화-문제와-paging-도입"><span>메모리 단편화 문제와 Paging 도입</span></a></h1><h2 id="문제-external-fragmentation" tabindex="-1"><a class="header-anchor" href="#문제-external-fragmentation"><span>문제: External Fragmentation</span></a></h2><ul><li>연속 할당 방식에서는 빈 공간이 파편화되어 사용 불가</li><li>compaction은 성능 비용 큼 → 비현실적</li></ul><h2 id="해결-paging" tabindex="-1"><a class="header-anchor" href="#해결-paging"><span>해결: Paging</span></a></h2><ul><li>Address space와 memory를 동일한 크기(page, frame)로 분할</li><li>page를 빈 frame 아무 곳에나 할당</li><li><strong>Internal Fragmentation</strong>: 마지막 page에서만 낭비 발생 → 무시할 수 있는 수준</li></ul><h2 id="주소-변환-방식" tabindex="-1"><a class="header-anchor" href="#주소-변환-방식"><span>주소 변환 방식</span></a></h2><ul><li>Logical Address = Page Number + Offset</li><li>변환: page number → frame number (via page table), offset 그대로 유지</li><li>주소 변환시 <strong>paging table</strong> 사용 (process마다 하나씩 존재)</li></ul><h2 id="비트-분할을-통한-효율적-주소-변환" tabindex="-1"><a class="header-anchor" href="#비트-분할을-통한-효율적-주소-변환"><span>비트 분할을 통한 효율적 주소 변환</span></a></h2><ul><li>Page size = 2^n 일 때 <ul><li>하위 n비트 → offset</li><li>상위 비트 → page number</li></ul></li><li>나눗셈 불필요, bit 분할로 연산 가능</li></ul><h1 id="tlb-translation-lookaside-buffer" tabindex="-1"><a class="header-anchor" href="#tlb-translation-lookaside-buffer"><span>TLB (Translation Lookaside Buffer)</span></a></h1><h2 id="tlb란" tabindex="-1"><a class="header-anchor" href="#tlb란"><span>TLB란?</span></a></h2><ul><li>페이지 테이블 중 일부를 cache에 저장</li><li><strong>Associative Memory</strong> 사용</li><li>TLB hit 시: 빠른 주소 변환 가능 (1 memory access)</li><li>TLB miss 시: page table 접근 필요 (2 memory access)</li></ul><h2 id="context-switch와-tlb" tabindex="-1"><a class="header-anchor" href="#context-switch와-tlb"><span>Context-Switch와 TLB</span></a></h2><ul><li>프로세스 전환 시 TLB는 invalidate되어야 함</li><li>초기에는 miss 발생하지만 locality 덕분에 금방 hit 증가</li></ul><h2 id="effective-access-time-계산" tabindex="-1"><a class="header-anchor" href="#effective-access-time-계산"><span>Effective Access Time 계산</span></a></h2><ul><li>hit ratio: ( \\epsilon \\ )</li><li>TLB hit: ( \\alpha \\ ) (access time)</li><li>Memory access: ( \\beta \\ )</li><li>EAT = ( \\epsilon (\\alpha + \\beta) + (1 - \\epsilon)(\\alpha + 2\\beta) )</li></ul><h2 id="tlb의-장점" tabindex="-1"><a class="header-anchor" href="#tlb의-장점"><span>TLB의 장점</span></a></h2><ul><li>Locality 덕분에 hit ratio 매우 높음 (ex: 1023/1024)</li><li>성능 향상에 매우 효과적</li></ul><h2 id="protection" tabindex="-1"><a class="header-anchor" href="#protection"><span>Protection</span></a></h2><ul><li>Valid / Invalid bit 사용</li><li>접근 가능한 범위만 valid로 설정</li></ul><h1 id="shared-paging" tabindex="-1"><a class="header-anchor" href="#shared-paging"><span>Shared Paging</span></a></h1><h2 id="공유의-필요성" tabindex="-1"><a class="header-anchor" href="#공유의-필요성"><span>공유의 필요성</span></a></h2><ul><li>text section 등은 read-only이므로 공유 가능</li><li>서로 다른 process라도 같은 frame을 가리키게 설정 가능</li><li>메모리 절약 효과 큼</li></ul><h2 id="paging의-공유-구조" tabindex="-1"><a class="header-anchor" href="#paging의-공유-구조"><span>Paging의 공유 구조</span></a></h2><ul><li>process별로 독립된 page table 유지</li><li>text section의 entry만 동일 frame 번호를 가리킴</li></ul><h1 id="결론" tabindex="-1"><a class="header-anchor" href="#결론"><span>결론</span></a></h1><ul><li>Paging은 효율적인 메모리 관리를 가능케 하는 핵심 기법</li><li>Overhead((\\alpha))는 존재하지만, 메모리 효율과 공유 구조로 인해 이를 상쇄함</li><li>TLB, 비트 분할, shared paging 등으로 성능 최적화 가능</li></ul>`,96)]))}const p=n(l,[["render",r]]),c=JSON.parse('{"path":"/operating-system/8.MemoryManagement-1.html","title":"8. Memory Management(1)","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1749486934000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":3,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"0bcd31829c652a9bbf03564b05b0c23bda2af518","time":1749486934000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update 요약"},{"hash":"03cd770d5fee5783f5cf264e71aab51bd9333c96","time":1749482620000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update"},{"hash":"21eb54832113279f03578ae6f740db3f7338cf13","time":1748840663000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update os"}]},"filePathRelative":"operating-system/8.MemoryManagement-1.md"}');export{p as comp,c as data};
