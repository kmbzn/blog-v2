import{_ as i,c as e,a as o,o as n}from"./app-DYuS003L.js";const a={};function s(r,l){return n(),e("div",null,[...l[0]||(l[0]=[o(`<h1 id="_08-firmware-analysis" tabindex="-1"><a class="header-anchor" href="#_08-firmware-analysis"><span>08. Firmware Analysis</span></a></h1><h2 id="펌웨어-분석의-필요성" tabindex="-1"><a class="header-anchor" href="#펌웨어-분석의-필요성"><span>펌웨어 분석의 필요성</span></a></h2><ul><li>IoT 기기, 스마트 기기 등 임베디드 시스템의 바이너리 안전성 증진 필요</li><li>스마트 가전 등 IoT 기기 공격 증가</li><li>원격 메디컬 펌웨어 공격 증가</li><li>펌웨어 수준의 난이도 높은 공격 증가</li><li>국가기간망 펌웨어 공격 증가</li></ul><h2 id="owasp-iot-top-10" tabindex="-1"><a class="header-anchor" href="#owasp-iot-top-10"><span>OWASP IoT Top 10</span></a></h2><ol><li>Weak, Guessable, or Hardcoded Passwords</li><li>Insecure Network Services</li><li>Insecure Ecosystem Interfaces</li></ol><ul><li>Insecure web, backend API, cloud, ...</li></ul><ol start="4"><li>Lack of Secure Update Mechanism</li><li>Use of Insecure or Outdated Components</li><li>Insufficient Privacy Protection</li><li>Insecure Data Transfer and Storage</li><li>Lack of Device Management</li></ol><ul><li>Asset management, system monitoring, response, ...</li></ul><ol start="9"><li>Insecure Default Settings</li><li>Lack of Physical Hardening</li></ol><h2 id="펌웨어-분석-프로세스" tabindex="-1"><a class="header-anchor" href="#펌웨어-분석-프로세스"><span>펌웨어 분석 프로세스</span></a></h2><pre><code>┌──────────────────────┐          ┌──────────────────────┐          ┌─────────────────────┐
│ 펌웨어 획득 및 추출  │          │   검증 벡터 선정     │          │      정적 분석      │
└──────────┬───────────┘          └──────────┬───────────┘          └─────┬───────────────┘
           │                       ▲         │                            │
           │                       │         │                            │
  ┌────────┴────────┐              └─────────┼────────────────────────────┤
  │  제조사 제공    │                        │                            │
  │     펌웨어      │             ┌──────────┴───────────┐          ┌─────┴──────┐
  ├─────────────────┤             │    검증 벡터 탐색    │          │  펌웨어    │
  │   패킷 스니핑   │             └─────┬──────────┬─────┘          │ 구조 분석  │
  ├─────────────────┤                   │          │                ├────────────┤
  │  플래시 메모리  │          ┌────────┴───┐  ┌───┴────────┐       │ 파일시스템 │
  │      덤프       │          │ 인터페이스 │  │  네트워크  │       │    분석    │
  ├─────────────────┤          │    분석    │  │ 패킷 분석  │       └────────────┘
  │    JTAG 이용    │          └────────┬───┘  └───┬────────┘
  ├─────────────────┤                   │          │
  │    UART 연결    │              ┌────┴──────────┴────┐           ┌─────────────────────┐
  └─────────────────┘              │     검증 벡터      │           │      동적 분석      │
                                   │    평가 및 선정    │           └─────┬───────────────┘
                                   └────────────────────┘                 │
                                                                          │
                                                                    ┌─────┴──────┐
                                                                    │  분석 환경 │
                                                                    │    조성    │
                                                                    ├────────────┤
                                                                    │   의존성   │
                                                                    │  문제 해결 │
                                                                    ├────────────┤
                                                                    │  동적 분석 │
                                                                    │    수행    │
                                                                    └────────────┘
</code></pre><h2 id="펌웨어-이미지-획득" tabindex="-1"><a class="header-anchor" href="#펌웨어-이미지-획득"><span>펌웨어 이미지 획득</span></a></h2><ul><li><strong>제조사 제공 펌웨어</strong>: 제조사 홈페이지에서 업데이트 등의 지원을 위해 제공</li><li><strong>패킷 스니핑</strong>: 네트워크를 통한 펌웨어 업데이트 시 전송되는 이미지 추출</li><li><strong>플래시 메모리 덤프</strong>: 임베디드 장치의 플래시 메모리에 저장된 펌웨어 덤프 (디바이스 분해 및 데이터 시트 참고 필요)</li><li><strong>JTAG (Joint Test Action Group) 이용</strong>: 임베디드 기기 디버깅 표준 장비. Emulator 이용 가능. 비휘발성 메모리 데이터(펌웨어) 추출 기능 제공</li><li><strong>UART (Universal Asynchronous Receiver/Transmitter)</strong>: 병렬/직렬 데이터 전송 하드웨어. JTAG보다 간단하고 저렴. 디버깅 용도로 많이 이용. UART 포트 존재 시 펌웨어 덤프 가능</li></ul><h2 id="동적-분석-펌웨어-분석" tabindex="-1"><a class="header-anchor" href="#동적-분석-펌웨어-분석"><span>동적 분석 펌웨어 분석</span></a></h2><ul><li><strong>동적 분석</strong>: 정적 분석만으로는 실제 처리 과정 및 결과 확인 어려움. 특정 입력에 대한 출력 과정과 결과 확인 가능</li><li><strong>동적 분석 환경</strong>: QEMU와 같은 emulator 이용. 대상 디바이스와 동일 환경 구현. GDB 등 디버거로 동적 분석 수행. 하드웨어 의존성 문제 해결 필요</li></ul><h2 id="펌웨어-구조-분석-펌웨어-분석" tabindex="-1"><a class="header-anchor" href="#펌웨어-구조-분석-펌웨어-분석"><span>펌웨어 구조 분석 펌웨어 분석</span></a></h2><pre><code> ┌──────────┐     ┌───────────┐     ┌──────────┐
 │          │     │Bootloader │     │          │
 │          │     ├───────────┤     │  Linux   │
 │          │     │  Kernel   │     │ ┌──────┐ │
 │ Firmware ├──┬─►├───────────┼──┬─►│ │ Ex2  │ │
 │  Image   │  |  │File System│  |  │ │ File │ │
 │          │  |  ├───────────┤  |  │ │System│ │
 │          │  |  │User Level │  |  │ └──────┘ │
 └──────────┘  |  └───────────┘  |  └──────────┘
               |                 |              
     Image offset analysis   File system dump   
     (signiture based)        &amp; mounting        
</code></pre><ul><li><strong>펌웨어 구조 분석</strong>: Bootloader / kernel 이미지 / filesystem 등의 offset 파악 필요. <ul><li>대표 도구: Firmware Mod Kit, <code>binwalk</code></li></ul></li><li><strong>파일 시스템 추출 및 분석</strong>: 펌웨어 이미지에서 filesystem 덤프. <ul><li>지원 운영체제에서 mount (예: <code>sudo mount –v –o loop –t ext2 filesys.img /tmp/fs</code>). Mount된 파일 시스템 내 실행 코드 파일 추출 및 분석</li></ul></li></ul><h2 id="이미지-파일-분석-펌웨어-분석" tabindex="-1"><a class="header-anchor" href="#이미지-파일-분석-펌웨어-분석"><span>이미지 파일 분석 펌웨어 분석</span></a></h2><ul><li><strong>펌웨어 이미지 파일 구조 분석</strong><ul><li>Bootloader: 시스템 하드웨어 초기화 및 kernel을 메모리에 적재</li><li>Kernel: 하드웨어와 소프트웨어 간 중간자</li><li>File system: 크기 문제로 압축되어 있음</li></ul></li><li><strong>펌웨어 무결성 검증 방법</strong><ul><li>해시 값이나 체크섬 값 이용</li><li>검증 과정 변조 시 무력화</li><li>Watchdog 사용 가능 (자체 변조 가능성으로 신뢰도 문제)</li></ul></li></ul><h2 id="소스코드-분석-–-정적-분석-펌웨어-분석" tabindex="-1"><a class="header-anchor" href="#소스코드-분석-–-정적-분석-펌웨어-분석"><span>소스코드 분석 – 정적 분석 펌웨어 분석</span></a></h2><ul><li><strong>펌웨어 소스코드/바이너리 분석 예</strong><ul><li><code>Buffer overflow</code> 발생 가능 취약 함수 검사 (예: <code>strcpy()</code>, <code>sprint()</code>)</li><li>Debugging code 포함 여부 검사</li><li>업데이트 모듈 분석</li><li>로그인 모듈 분석</li><li>Password/암호화 키의 하드코딩 여부 분석</li></ul></li></ul><h2 id="펌웨어-취약점-분석" tabindex="-1"><a class="header-anchor" href="#펌웨어-취약점-분석"><span>펌웨어 취약점 분석</span></a></h2><ul><li><strong>FirmwareModificationKit을 통한 추출 및 분석</strong>: 펌웨어 이미지로부터 파일 시스템 추출. 무결성 검증 루틴 포함 파일 분석</li><li><strong>문자열 검색 기반 분석</strong>: 키워드 문자열 검색 (예: <code>Certificate</code>)으로 무결성 검증 방법 분석</li><li><strong>부팅 로그 분석</strong>: 부팅 로그 분석을 통한 무결성 검증 과정 확인. (예: 1024 bit RSA 키 자체 생성 확인)</li><li><strong>파일시스템 파일 분석</strong>: 인증서 연결 형태 / 인증서 파일 자체 분석</li></ul><h2 id="nas-취약점-분석-사례-1-취약점-분석-사례" tabindex="-1"><a class="header-anchor" href="#nas-취약점-분석-사례-1-취약점-분석-사례"><span>NAS 취약점 분석 사례 1 취약점 분석 사례</span></a></h2><ul><li><strong>펌웨어 획득</strong>: 제조사 홈페이지 제공 (버전 5592, 릴리즈 2015.08.08)</li><li><strong>기본 인터페이스</strong>: 기본 관리자 계정 없음. 리눅스를 브라우저 기반 OS로 customizing</li><li><strong>제조사 웹페이지 제공 펌웨어 이미지 분석 시도</strong><ul><li>FMK 이용</li><li>의미 있는 filesystem 탐색 불가능</li><li>일반적인 펌웨어 구조가 아님</li></ul></li></ul><h2 id="nas-취약점-분석-사례-2-취약점-분석-사례" tabindex="-1"><a class="header-anchor" href="#nas-취약점-분석-사례-2-취약점-분석-사례"><span>NAS 취약점 분석 사례 2 취약점 분석 사례</span></a></h2><ul><li><strong>UART 연결 시 shell</strong>: UART 연결 시 root 권한의 부트로더 쉘 획득 가능</li><li><strong>취약한 인자 전달 루틴</strong></li><li><strong>펌웨어 획득</strong>: 제조사 홈페이지 제공</li><li><strong>디버깅용 백도어</strong>: 별도 인가 과정 없이 접근 가능한 바이너리에 존재. 특정 인자값 전달 시 사용 가능</li></ul><h2 id="nas-펌웨어-분석-결과-취약점-분석-사례" tabindex="-1"><a class="header-anchor" href="#nas-펌웨어-분석-결과-취약점-분석-사례"><span>NAS 펌웨어 분석 결과 취약점 분석 사례</span></a></h2><ul><li><strong>일반 사용자 디버깅용 백도어 접근 및 활용</strong><ol><li><code>help.cgi</code>는 <code>d</code> 인자가 999인지 확인. 참이면 디버깅용 백도어 루틴 실행 허용</li><li>백도어 루틴은 <code>votmdnjem</code> 인자의 값이 <code>!@elqjrld&amp;*</code> 인지 비교. 동일하면 명령 실행 및 결과 출력</li></ol></li><li><strong>디버깅용 백도어 활용 명령어 실행 예시</strong><ol><li><strong>백도어 접속</strong>: NAS 일반 사용자 로그인 후, <code>[IP]/help.cgi?d=999</code> 로 접속</li><li><strong><code>id</code> 명령어 실행</strong>: <code>!@elqjrld&amp;*</code> 입력</li><li><strong><code>ls</code> 명령어 실행</strong>: <code>!@elqjrld&amp;*</code> 입력 및 Input Box에 열람할 html 파일 입력 (예: <code>logout.html</code>)</li></ol></li></ul><h2 id="스마트-스피커-분석-취약점-분석-사례" tabindex="-1"><a class="header-anchor" href="#스마트-스피커-분석-취약점-분석-사례"><span>스마트 스피커 분석 취약점 분석 사례</span></a></h2><ul><li>스피커 제조사의 메인 서버에서 명령 및 데이터 처리</li><li>스피커는 사용자 음성 명령 입력 및 서버 명령 출력 역할</li><li>제한된 공격 경로</li></ul><h2 id="스마트-스피커-분석-스마트-스피커-분석" tabindex="-1"><a class="header-anchor" href="#스마트-스피커-분석-스마트-스피커-분석"><span>스마트 스피커 분석 스마트 스피커 분석</span></a></h2><ul><li><strong>스마트 스피커의 물리적 구조 확인 (NUGU 스피커)</strong><ul><li>접근 쉬운 위치(고무커버 밑)에 UART, USB 추정 테스트 포트 발견</li><li>USB 포트의 D-pair 연결 확인 (USB 통한 공격 가능)</li><li>마이크가 기판 사이에 위치 (레이저 이용 공격 불가능)</li></ul></li><li><strong>스마트 스피커의 분해 사진자료 (SKT NUGU)</strong>: (사진 자료: USB N.C.되지 않음, 메인보드 집적회로, 기판 뒷면 마이크, 밑면 테스팅 포트)</li><li><strong>NUGU candle 해체</strong><ul><li>하단 부분 해체 시 UART 핀 노출</li><li><code>UART_RX</code>, <code>UART_TX</code>, <code>GND</code>, <code>DC_IN_PW</code> 핀 확인</li></ul></li><li><strong>UART (Universal Asynchronous Receiver / Transmitter) 핀 역할</strong><ul><li><code>TX</code>: 데이터 송신</li><li><code>RX</code>: 데이터 수신</li><li><code>GND</code>: 그라운드</li><li><code>VCC</code>: 전압</li></ul></li></ul><h2 id="uart-포트-접속-및-분석-스마트-스피커-분석" tabindex="-1"><a class="header-anchor" href="#uart-포트-접속-및-분석-스마트-스피커-분석"><span>UART 포트 접속 및 분석 스마트 스피커 분석</span></a></h2><ul><li><strong>방법 1: 케이블 전원 공급 후 아두이노 이용 연결</strong><ul><li>AI 스피커용 케이블로 전원 공급 후 아두이노로 UART 연결</li><li>결과: 읽을 수 없는 문자열만 출력</li></ul></li><li><strong>방법 2: 케이블 전원 공급 후 UART to USB 이용 연결</strong><ul><li>AI 스피커용 케이블로 전원 공급 후 UART to USB로 연결</li><li>주로 사용되는 baud rate 모두 시도</li><li>결과: 읽을 수 없는 문자열 출력</li></ul></li><li><strong>방법 3: 신호분석기를 통한 UART 핀 분석</strong><ul><li>Baud rate 115200일 때 부팅 메시지 출력 확인</li><li>Python script 작성 분석 결과, 부팅 메시지 정상 출력 확인</li></ul></li><li><strong>방법 4: FT232RL USB to UART converter</strong><ul><li>Baud rate 115200으로 설정</li><li>연결 케이블 재확인</li><li>결과: Uboot shell 획득 성공</li></ul></li></ul><h2 id="uboot-shell-스마트-스피커-분석" tabindex="-1"><a class="header-anchor" href="#uboot-shell-스마트-스피커-분석"><span>Uboot Shell 스마트 스피커 분석</span></a></h2><ul><li>Uboot는 디바이스 부팅 과정 중 하나</li><li>Uboot 명령어는 Kernel 실행 전에 실행됨</li><li>메모리 직접 수정/읽기 가능</li><li>임의 주소 메모리 덤프 (펌웨어 덤프) 가능</li></ul><h2 id="펌웨어-업데이트-패킷-분석-스마트-스피커-분석" tabindex="-1"><a class="header-anchor" href="#펌웨어-업데이트-패킷-분석-스마트-스피커-분석"><span>펌웨어 업데이트 패킷 분석 스마트 스피커 분석</span></a></h2><ul><li>NUGU 스피커 펌웨어 업데이트 패킷은 암호화되어 있음</li></ul><h2 id="펌웨어-분석-요약" tabindex="-1"><a class="header-anchor" href="#펌웨어-분석-요약"><span>펌웨어 분석 요약</span></a></h2><ul><li><strong>펌웨어 획득</strong>: 제조사 다운로드, 패킷 스니핑, 디버깅 포트 덤프 등</li><li><strong>펌웨어 구조 분석</strong>: 섹션 별 offset 확인, 파일 시스템 확인 및 분석</li><li><strong>정적/동적 분석</strong>: 바이너리 파일 분석과 유사 (디버깅 코드, 하드코딩된 패스워드, 취약 함수 사용 여부 등)</li><li><strong>검증 벡터 선정</strong>: 사용자 인터페이스, 네트워크 처리, 외부 입력 데이터 처리, 펌웨어 무결성 처리 부분 분석</li></ul><h2 id="firmware-analysis" tabindex="-1"><a class="header-anchor" href="#firmware-analysis"><span>Firmware Analysis</span></a></h2><ul><li><strong><code>strings</code> command options</strong><ul><li><code>-n</code>: 최소 글자 수</li><li><code>-e</code>: 인코딩 타입</li><li><code>-tx</code>, <code>-to</code>: 문자열의 offset 출력 (x: hexadecimal, o: octal)</li></ul></li></ul><h2 id="binwalk" tabindex="-1"><a class="header-anchor" href="#binwalk"><span>binwalk</span></a></h2><ul><li><strong>설치 방법 (linux)</strong>: <code>sudo apt install binwalk</code></li><li><strong>파일 탐색기 root 디렉토리</strong>: <code>\\\\wsl$</code></li><li><strong>WSL 확인</strong>: <code>wsl –l -v</code></li><li><strong>Ubuntu version 확인</strong>: <code>lsb_release –a</code></li><li><strong>백업</strong>: <code>wsl –export Ubuntu-20.04 backup.tar</code></li><li><strong>복구</strong>: <code>wsl –import Ubuntu-20.04 (install location) (file location)</code></li><li><strong>펌웨어 이미지 확인</strong>: <code>binwalk ****.bin</code> (커널 이미지와 주소 확인)</li><li><strong>커널 이미지 추출</strong>: <code>dd if=****.bin skip=시작주소 bs=1 of=kernel.lzma</code><ul><li><code>if</code>: input file</li><li><code>bs</code>: block size</li><li><code>of</code>: output file</li></ul></li><li><strong>커널 파일 확인</strong><ul><li><code>file kernel.lzma</code></li><li><code>unlzma kernel.lzma</code></li><li><code>file kernel</code></li><li><code>binwalk kernel</code> (kernel version 및 데이터 확인)</li></ul></li><li><strong><code>sasquatch</code> 설치</strong>: <code>git clone https://github.com/devttys0/sasquatch</code> (설치 후 <code>binwalk</code> 실행)</li></ul><h2 id="firmware-modification-kit-fmk" tabindex="-1"><a class="header-anchor" href="#firmware-modification-kit-fmk"><span>firmware modification kit (FMK)</span></a></h2><ul><li><strong>사이트</strong><ul><li><a href="https://www.kali.org/tools/firmware-mod-kit/#firmware-mod-kit" target="_blank" rel="noopener noreferrer">https://www.kali.org/tools/firmware-mod-kit/#firmware-mod-kit</a></li><li><a href="https://github.com/rampageX/firmware-mod-kit" target="_blank" rel="noopener noreferrer">https://github.com/rampageX/firmware-mod-kit</a></li></ul></li><li><strong>설치 (Ubuntu 20.04 and newer)</strong><ul><li><code>sudo apt-get install git build-essential zlib1g-dev liblzma-dev python3-magic autoconf python-is-python3</code> (에러 시 <code>sudo apt update</code> 후 재시도)</li><li>Git Clone: <code>git clone https://github.com/rampageX/firmware-mod-kit</code></li></ul></li><li><strong>펌웨어 추출</strong>: <code>./extract-firmware.sh ****.bin</code></li></ul>`,48)])])}const c=i(a,[["render",s]]),d=JSON.parse('{"path":"/cs/8.html","title":"08. Firmware Analysis","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1765654172000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":4,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"fbc761248c4632f2dc6fe5fc2afee172914eca6c","time":1765654172000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update security"},{"hash":"f81f9042e7888855a506f92261c74aaa2d86aa2a","time":1764305376000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update npm"},{"hash":"0057409eafde79271953401af3d5cad037e22073","time":1763922601000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Refactor code structure for improved readability and maintainability"},{"hash":"08867d8bfee10c04c85190c56237679cf303850b","time":1762151841000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Add comprehensive documentation for firmware analysis process and tools"}]},"filePathRelative":"cs/8.md"}');export{c as comp,d as data};
