import{_ as a,c as e,a as l,o as s}from"./app-DiAjUdp1.js";const t="/assets/image-BlgBamXR.png",n="/assets/image-1-CyOw2cUv.png",r="/assets/image-2-B0YiloXQ.png",o="/assets/image-3-CmGNWxnV.png",c="/assets/image-4-BslhlSLK.png",d="/assets/image-5-DzKY_uNT.png",h="/assets/image-6-DjepMF_C.png",u="/assets/image-7-DiAbNIrd.png",m="/assets/image-8-DJzl2nHf.png",p="/assets/image-10-Co6pRBq-.png",g="/assets/image-9-WPAH7EUH.png",b="/assets/image-11-BM0ideY1.png",y="/assets/image-13-DwWrQE8g.png",f="/assets/image-12-sm2rEQjT.png",x="/assets/image-15-Cluqxuve.png",v="/assets/image-14-e5F5FyaT.png",S="/assets/image-16-BjedPPxZ.png",C={};function A(U,i){return s(),e("div",null,[...i[0]||(i[0]=[l('<h1 id="_9-unified-modelling-language" tabindex="-1"><a class="header-anchor" href="#_9-unified-modelling-language"><span>9. Unified Modelling Language</span></a></h1><h2 id="learning-goals" tabindex="-1"><a class="header-anchor" href="#learning-goals"><span>Learning Goals</span></a></h2><ul><li>UML (Unified Modeling Language)이 무엇인지, 왜 필요한지 이해</li><li>기본 UML notation(표기법)을 사용하여 design(설계)을 전달</li><li>다양한 유형의 UML diagram(다이어그램)의 표기법과 목적 이해</li></ul><h2 id="what-could-the-arrow-mean-revisited" tabindex="-1"><a class="header-anchor" href="#what-could-the-arrow-mean-revisited"><span>What Could the Arrow Mean? (Revisited)</span></a></h2><ul><li>많은 가능성 존재</li><li>A가 B로 control(제어)을 전달</li><li>A가 B로 data(데이터)를 전달</li><li>A가 B로부터 value(값)을 가져옴</li><li>A가 B로 데이터를 stream(스트림)</li><li>A가 B로 message(메시지)를 전송</li><li>A가 B를 create(생성)</li><li>A가 B보다 먼저 발생</li><li>B가 A로부터 전기를 공급받음.</li></ul><h2 id="what-is-uml" tabindex="-1"><a class="header-anchor" href="#what-is-uml"><span>What is UML?</span></a></h2><ul><li>Unified Modeling Language (통합 모델링 언어)</li><li>Specifying(명세화), constructing(구축), documenting(문서화)를 위한 visual language(시각적 언어)</li><li>OMG (Object Management Group)에 의해 유지 관리</li><li>웹사이트: <a href="http://www.omg.org" target="_blank" rel="noopener noreferrer">http://www.omg.org</a></li><li>Object-oriented(객체 지향)</li><li>Model(모델) / view(뷰) 패러다임</li><li>Target language(대상 언어) 독립적</li></ul><h2 id="model-view-paradigm" tabindex="-1"><a class="header-anchor" href="#model-view-paradigm"><span>Model/View Paradigm</span></a></h2><ul><li>각 diagram은 system(시스템) 일부에 대한 view에 불과</li><li>모든 diagram이 함께 모여 완전한 그림을 제공</li></ul><h2 id="underlying-system-model" tabindex="-1"><a class="header-anchor" href="#underlying-system-model"><span>Underlying System Model</span></a></h2><ul><li>UML diagram 유형의 Classification(분류)</li></ul><h2 id="favorite-uml-diagram-types" tabindex="-1"><a class="header-anchor" href="#favorite-uml-diagram-types"><span>Favorite UML diagram types</span></a></h2><ul><li>widely used(널리 사용됨): 출처의 60% 이상</li><li>Scarcely used(거의 사용되지 않음): 출처의 40% 이하</li><li>(참고: Riggo et al., What are the used UML diagrams? A Preliminary Survey, EESSMod, 2013)</li></ul><h2 id="uml" tabindex="-1"><a class="header-anchor" href="#uml"><span>UML</span></a></h2><ul><li>UML을 적용(사용)하는 3가지 방법</li><li>Sketch(스케치) <ul><li>Conceptual perspective(개념적 관점)</li><li>Problem 또는 solution space의 어려운 부분을 탐색하기 위해 비공식적이고 불완전한 diagram 생성 → 상호 소통 매체</li></ul></li><li>Blueprint(청사진) <ul><li>Specification perspective(명세 관점)</li><li>Code generation(코드 생성)을 위해 <strong>비교적 상세한</strong> design diagram 사용</li></ul></li><li>Programming language(프로그래밍 언어) <ul><li>Implementation perspective(구현 관점)</li><li>UML로 소프트웨어 system의 완전한 executable specification(실행 가능 명세) 작성</li><li>실행 가능한 코드가 자동으로 생성</li><li>이론, 도구 robustness(견고성), usability(사용성) 측면에서 여전히 개발 중</li></ul></li></ul><h2 id="what-the-uml-is-not" tabindex="-1"><a class="header-anchor" href="#what-the-uml-is-not"><span>What the UML is Not?</span></a></h2><ul><li>UML은 Object-Oriented 분석 및 design process(프로세스)가 아님. <ul><li>UML은 소프트웨어 system을 개발하는 체계적인 방법이 아님.</li></ul></li><li>UML은 Object-Oriented 사고방식을 가르쳐주지 않음. <ul><li>객체 structure(구조)나 behavior(행위)를 어떻게 설계해야 하는지 알려주지 않음.</li><li>design이 좋은지 나쁜지 알려주지 않음.</li></ul></li></ul><h1 id="use-case-diagrams" tabindex="-1"><a class="header-anchor" href="#use-case-diagrams"><span>Use Case Diagrams</span></a></h1><h2 id="what-is-a-use-case" tabindex="-1"><a class="header-anchor" href="#what-is-a-use-case"><span>What is a Use Case?</span></a></h2><ul><li>Use Case(유스케이스): 사람 사용자, 다른 system, 하드웨어 구성요소 또는 내부 시계에 의해 system으로 전송된 event(이벤트)에 의해 촉발되는 behavior 또는 일관된 behavior 집합</li></ul><h2 id="use-case-diagrams-1" tabindex="-1"><a class="header-anchor" href="#use-case-diagrams-1"><span>Use Case Diagrams</span></a></h2><ul><li>System이 high-level(높은 수준)에서 무엇(WHAT)을 할 것인지 기술</li><li>(다이어그램 구성 요소)</li><li>Use Case</li><li>Use Case Name (유스케이스 이름)</li><li>Subject Name (주체 이름)</li><li>Subject(주체)</li><li>System Boundary(시스템 경계)</li><li>Association(연관)</li><li>Dependency(의존)</li><li>Actor(행위자)</li></ul><h2 id="actor" tabindex="-1"><a class="header-anchor" href="#actor"><span>Actor</span></a></h2><ul><li>System과 상호작용해야 하는 누군가 또는 무언가</li><li>사용자, 외부 system, 장치</li></ul><h2 id="an-actor-is-a-role" tabindex="-1"><a class="header-anchor" href="#an-actor-is-a-role"><span>An Actor is a Role</span></a></h2><ul><li>Actor는 사용자가 system과 상호작용할 때 수행하는 단일 role(역할)을 정의</li><li>여러 사용자가 단일 role 수행 가능</li><li>단일 사용자가 여러 role 수행 가능</li></ul><h2 id="identifying-actors" tabindex="-1"><a class="header-anchor" href="#identifying-actors"><span>Identifying Actors</span></a></h2><ul><li>유용한 질문들 <ul><li>누가 system의 주요 functionality(기능)을 사용할 것인가 (<strong>primary actors</strong>(주요 행위자))?</li><li>누가 일상 업무를 위해 system의 지원을 필요로 하는가?</li><li>누가 system을 유지보수, 관리하고 작동하도록 유지해야 하는가 (<strong>secondary actors</strong>(보조 행위자))?</li><li>System이 처리해야 할 hardware devices(하드웨어 장치)는 무엇인가?</li><li>System이 상호작용해야 할 다른 system은 무엇인가?</li><li>누가 또는 무엇이 system이 생성하는 결과(가치)에 관심이 있는가?</li></ul></li></ul><h2 id="use-case" tabindex="-1"><a class="header-anchor" href="#use-case"><span>Use Case</span></a></h2><ul><li>Actor와 Subject 간의 transaction(트랜잭션)으로 표현되는 기능 단위</li><li>하나 이상의 Actor와 system 간의 상호작용</li><li>Use case 식별하기 <ul><li>Actor가 system에 요구하는 function(기능)은 무엇인가?</li><li>Actor가 system의 특정 정보를 읽기, 생성, 삭제, 수정 또는 저장해야 하는가?</li><li>Actor가 system의 event에 대해 notify(알림)을 받아야 하는가?</li><li>System의 새로운 기능을 통해 Actor의 일상 업무가 단순화되거나 효율화될 수 있는가?</li></ul></li></ul><h2 id="an-example-of-use-case-text" tabindex="-1"><a class="header-anchor" href="#an-example-of-use-case-text"><span>An Example of Use Case Text</span></a></h2><ul><li>Buy a Product (제품 구매)</li><li>Main Success Scenario(주 성공 시나리오): <ol><li>고객이 카탈로그를 탐색하고 구매할 아이템 선택</li><li>고객이 결제 진행</li><li>고객이 배송 정보 입력 (주소; 익일 또는 3일 배송)</li><li>System이 배송비 포함 전체 가격 정보 제시</li><li>고객이 신용카드 정보 입력</li><li>System이 구매 승인</li><li>System이 즉시 판매 확인</li><li>System이 고객에게 확인 이메일 발송</li></ol></li><li>Extensions(확장): <ul><li>3a: 고객이 regular customer(단골 고객)인 경우 <ul><li>.1: system이 현재 배송, 가격, 청구 정보 표시</li><li>.2: 고객이 이 default(기본값)을 수락하거나 변경 가능, MSS 6단계로 복귀</li></ul></li><li>6a: system이 신용카드 구매 승인 실패 <ul><li>.1: 고객이 신용카드 정보를 다시 입력하거나 취소 가능</li></ul></li></ul></li></ul><h2 id="subject-symbol" tabindex="-1"><a class="header-anchor" href="#subject-symbol"><span>Subject Symbol</span></a></h2><ul><li>System Boundary 표시</li><li>Use Case에 의해 정의된 behavior를 realize(실현)하는 Classifier(분류자)</li></ul><h2 id="association" tabindex="-1"><a class="header-anchor" href="#association"><span>Association</span></a></h2><ul><li>Actor와 system 간의 bi-directional 통신 표현</li><li>Actor와 Use Case 사이에 그려짐</li><li>화살표 없이, 선으로 표현</li></ul><h2 id="dependency–include" tabindex="-1"><a class="header-anchor" href="#dependency–include"><span>Dependency–Include</span></a></h2><ul><li>Base Use Case에서 inclusion Use Case로의 관계 표현</li><li>Use Case가 다른 Use Case를 call(호출)함을 암시</li><li>주로 여러 Use Case에 공통적인 behavior를 reuse하기 위해 사용됨.</li></ul><h2 id="dependency–extend" tabindex="-1"><a class="header-anchor" href="#dependency–extend"><span>Dependency–Extend</span></a></h2><ul><li>일부 추가적인 behavior가 더해져야 할 때 사용</li><li>Optional(선택적) 또는 conditional(조건부) behavior를 모델링</li><li>Infrequent events(드문 이벤트) 표시</li></ul><h2 id="tips-for-use-case-modeling" tabindex="-1"><a class="header-anchor" href="#tips-for-use-case-modeling"><span>Tips for Use Case Modeling</span></a></h2><ul><li>각 Use Case가 domain experts(도메인 전문가)와 프로그래머 모두 이해할 수 있는 system 사용의 중요한 chunk(부분)을 설명하도록 보장</li><li>Use Case를 텍스트로 정의할 때, noun(명사)과 verb(동사)를 정확하고 일관되게 사용하여 interaction diagrams을 위한 objects와 message 도출에 도움</li><li>여러 Use Case에 필요한 공통 usage(사용)을 Factor out(분리) <ul><li>usage이 required(필수적)이면 사용</li><li>Base Use Case가 완전하고 usage이 optional일 수 있다면 사용 고려</li></ul></li><li>Use Case diagram은 <ul><li>동일한 level of abstraction(추상화 수준)의 Use Case만 포함해야 함</li><li>필요한 Actor만 포함해야 함</li></ul></li><li>많은 수의 Use Case는 packages(패키지)로 구성해야 함</li></ul><h1 id="class-diagrams" tabindex="-1"><a class="header-anchor" href="#class-diagrams"><span>Class Diagrams</span></a></h1><h2 id="class-diagrams-1" tabindex="-1"><a class="header-anchor" href="#class-diagrams-1"><span>Class Diagrams</span></a></h2><ul><li>Description of static structure <ul><li>Showing the types of objects ...</li></ul></li><li>(다이어그램 구성 요소)</li><li>Class Name(클래스 이름)</li><li>Class Attributes(클래스 속성)</li><li>Class Operations(클래스 오퍼레이션)</li><li>Association</li><li>Multiplicity(다중성)</li><li>Generalization(일반화)</li><li>Guard(가드)</li><li>&quot;...&quot;는 요소가 더 있을 수 있음을 의미</li><li>공백은 &quot;알 수 없음&quot; 또는 &quot;멤버 없음&quot;을 의미</li><li>Static structure(정적 구조)에 대한 설명</li><li>System 내 object의 type(유형)과 그들 간의 relationship(관계) 표시</li></ul><p><img src="'+t+'" alt="alt text"></p><h2 id="classes" tabindex="-1"><a class="header-anchor" href="#classes"><span>Classes</span></a></h2><ul><li>사각형 세 개를 쌓아놓은 형태로 표현</li><li>모든 Object-Oriented system의 가장 중요한 building block(구성 요소)</li><li>Object set(집합)에 대한 설명</li><li>Entity의 추상화</li><li>problem/solution 도메인에 존재함</li></ul><p><img src="'+n+'" alt="alt text"></p><h2 id="attributes-and-operations" tabindex="-1"><a class="header-anchor" href="#attributes-and-operations"><span>Attributes and Operations</span></a></h2><ul><li>Attributes(속성) <ul><li>모델링되는 대상의 property(속성)을 표현</li><li>Syntax(구문): attributeName: Type</li></ul></li><li>Operations <ul><li>Class의 object로부터 요청된 service(서비스)의 구현</li><li>Syntax: operationName(param1:type, param2:type, ...) : Result</li></ul></li></ul><h2 id="association-and-multiplicity" tabindex="-1"><a class="header-anchor" href="#association-and-multiplicity"><span>Association and Multiplicity</span></a></h2><ul><li>Association <ul><li>Class instance(인스턴스) 간의 connection(연결)을 명시하는 Class 간의 relationship</li><li>Association의 이름은 주로 동사를 씀.</li></ul></li><li>Multiplicity <ul><li>다른 Class의 <em>하나</em>(ONE)의 instance와 관련된 한 Class의 instance 수</li></ul></li><li>예: &quot;팀(Team)은 0명 이상의 농구 선수(Basketball Player)를 고용(employ)한다.&quot;</li></ul><h2 id="aggregations-and-compositions" tabindex="-1"><a class="header-anchor" href="#aggregations-and-compositions"><span>Aggregations and Compositions</span></a></h2><ul><li>Aggregation(집합) <ul><li>Element 간의 Weak(약한) &quot;whole-part&quot;(전체-부분) relationship</li><li>예: 공항(Airport)은 많은 비행기(Airplane)를 가짐.</li></ul></li><li>Composition(복합) <ul><li>Element 간의 Strong(강한) &quot;whole-part&quot; relationship</li><li>예: 창문(Window)은 스크롤바(Scrollbar)를 &#39;contains&#39;.</li></ul></li></ul><p><img src="'+r+'" alt="alt text"></p><h2 id="inheritance-상속" tabindex="-1"><a class="header-anchor" href="#inheritance-상속"><span>Inheritance 상속</span></a></h2><ul><li>Superclass와 subclasses 간의 relationship</li><li>Superclass의 모든 Attributes와 Operations는 subclasses의 일부가 됨.</li></ul><p><img src="'+o+'" alt="alt text"></p><h2 id="tips-for-class-modeling" tabindex="-1"><a class="header-anchor" href="#tips-for-class-modeling"><span>Tips for Class Modeling</span></a></h2><ul><li>Class(클래스) 찾기 <ul><li>저장되거나 분석되어야 할 data가 있는가?</li><li>External system(외부 시스템)이 있는가?</li><li>External system은 Class로 모델링됨.</li><li>pattern(패턴), class libraries(클래스 라이브러리), component 등이 있는가?</li><li>System이 처리해야 할 device(장치)가 있는가?</li></ul></li><li>가능할 때마다 명시적인 traceability(추적성) 확보 <ul><li>Use Case의 noun로부터 Class/Attributes를, verb로부터 Operations를 도출하려 노력</li><li>항상 어떤 형태의 behavioral diagrams(행위 다이어그램)과 함께 Class diagram 작성</li></ul></li></ul><h1 id="sequence-diagrams" tabindex="-1"><a class="header-anchor" href="#sequence-diagrams"><span>Sequence Diagrams</span></a></h1><h2 id="sequence-diagrams-1" tabindex="-1"><a class="header-anchor" href="#sequence-diagrams-1"><span>Sequence Diagrams</span></a></h2><ul><li>System 내 instance 간의 message(&quot;interaction&quot;) sequence 표시</li><li>time ordering(시간 순서) 강조</li><li>(다이어그램 구성 요소)</li><li>Lifeline(생명선)</li><li>Message name(메시지 이름)</li><li>Messages line(메시지 라인)</li><li>ReferenceFrame(참조 프레임)</li><li>Sequence DiagramName(시퀀스 다이어그램 이름)</li></ul><p><img src="'+c+'" alt="alt text"></p><h2 id="lifelines" tabindex="-1"><a class="header-anchor" href="#lifelines"><span>Lifelines</span></a></h2><ul><li>일정 기간 동안 interaction에 참여하는 개별 participant(참여자)</li><li>Subsystem(서브시스템) / object / Class</li><li>Actor</li><li>표기: <code>Instance name (object) : Type name (class)</code></li></ul><h2 id="messages" tabindex="-1"><a class="header-anchor" href="#messages"><span>Messages</span></a></h2><ul><li>두 object 간의 One-way communication</li><li>Value를 전달하는 parameter를 가질 수 있음.</li><li>(Asynchronous message(비동기 메시지), Synchronous message(동기 메시지))</li></ul><p><img src="'+d+'" alt="alt text"></p><h2 id="combined-fragment-frame" tabindex="-1"><a class="header-anchor" href="#combined-fragment-frame"><span>Combined Fragment Frame</span></a></h2><ul><li>Interaction fragments(프래그먼트)의 표현식 정의</li><li>Interaction operators(연산자)는 내용이 behavior를 어떻게 기술하는지 정의</li><li>Alt: 각 섹션이 하나의 <strong>alternative</strong>(대안). 예: <code>alt [a&gt;0]</code></li><li>Ref: 다른 Use Case <strong>참조</strong></li><li>Loop: <strong>반복</strong>되는 behavior sequence 명시. 예: <code>loop [1,5]</code>, <code>loop [6]</code><img src="'+h+'" alt="alt text"></li></ul><h2 id="referencing" tabindex="-1"><a class="header-anchor" href="#referencing"><span>Referencing</span></a></h2><ul><li>이미 존재하는 sequence diagram 재사용</li><li>불필요한 duplication(중복) 방지</li></ul><p><img src="'+u+'" alt="alt text"></p><h2 id="tips-for-sequence-diagram" tabindex="-1"><a class="header-anchor" href="#tips-for-sequence-diagram"><span>Tips for Sequence Diagram</span></a></h2><ul><li>Interaction의 context(컨텍스트) 설정 <ul><li>예: 하나의 Use Case</li></ul></li><li>Flow(흐름)을 왼쪽에서 오른쪽으로, 위에서 아래로 표현</li><li>Active(활성) instance는 왼쪽/위에, passive(수동) instance는 오른쪽/아래에 배치</li><li>여러 object의 behavior를 보고 싶다면 각 Use Case에 대한 sequence diagram 작성</li></ul><h1 id="activity-and-swimlane-diagrams" tabindex="-1"><a class="header-anchor" href="#activity-and-swimlane-diagrams"><span>Activity and Swimlane Diagrams</span></a></h1><h2 id="activity-diagram" tabindex="-1"><a class="header-anchor" href="#activity-diagram"><span>Activity Diagram</span></a></h2><ul><li>특정 scenario(시나리오) 내 interaction의 flow를 graphical representation(그래픽 표현)으로 제공하여 Use Case 보충</li><li>Activity diagram(활동 다이어그램)은 flow-chart(순서도)와 유사 <img src="'+m+'" alt="alt text"> <img src="'+p+'" alt="alt text"></li></ul><h2 id="swimlane-diagrams" tabindex="-1"><a class="header-anchor" href="#swimlane-diagrams"><span>Swimlane Diagrams</span></a></h2><ul><li>modeler(모델러)가 어떤 Actor가 action에 대한 responsibility(책임)이 있는지 표시하도록 허용 <img src="'+g+'" alt="alt text"></li></ul><h1 id="state-machine-diagrams-10-30-목" tabindex="-1"><a class="header-anchor" href="#state-machine-diagrams-10-30-목"><span>State Machine Diagrams [10.30.(목)]</span></a></h1><h2 id="state-machine-diagrams" tabindex="-1"><a class="header-anchor" href="#state-machine-diagrams"><span>State Machine Diagrams</span></a></h2><ul><li>각 Class의 object lifecycle을 모델링하여 시간에 따른 object의 동적인 동작 기술</li><li>표시 항목 <ul><li>한 State에서 다른 state로의 transition를 유발하는 사건</li><li>State 변경으로 인한 action <img src="'+b+'" alt="alt text"></li></ul></li></ul><h2 id="states-상태" tabindex="-1"><a class="header-anchor" href="#states-상태"><span>States 상태</span></a></h2><ul><li>State: object의 수명 동안의 condition(조건) 또는 situation(상황)</li><li>어떤 condition을 만족하거나, 어떤 activity를 수행하거나, 어떤 event를 기다림</li></ul><h2 id="event-and-action" tabindex="-1"><a class="header-anchor" href="#event-and-action"><span>Event and Action</span></a></h2><ul><li>Event: Object가 State를 변경하도록 유발하는 Stimulus(자극)</li><li>Action: Signal 또는 operation call의 Output <img src="'+y+'" alt="alt text"></li></ul><h2 id="transition" tabindex="-1"><a class="header-anchor" href="#transition"><span>Transition</span></a></h2><ul><li>Event에 의해 촉발되어 한 state에서 다른 state로의 변경</li><li>Guard Condition이 true일 때만 발생</li><li>Syntax: <code>event(arguments)[condition]/action</code><img src="'+f+'" alt="alt text"></li></ul><h2 id="internal-activities" tabindex="-1"><a class="header-anchor" href="#internal-activities"><span>Internal Activities</span></a></h2><ul><li>State는 transition 없이 event에 반응 가능</li><li>Event, Guard, activity를 state box 내부에 배치</li><li>두 가지 특별한 activity <ul><li>Entry(진입) 및 exit(진출) activity</li></ul></li><li>Internal activity는 self-transition와 유사</li><li>그러나 Internal activity는 entry 및 exit activity를 촉발하지 않음.</li></ul><table><thead><tr><th>Typing</th></tr></thead><tbody><tr><td><code>entry/highlight all</code><br><code>exit/update field</code><br><code>character/ handle character</code><br><code>help[verbose]/ open help page</code><br><code>help[quiet]/ update status bar</code></td></tr></tbody></table><h2 id="activity-states" tabindex="-1"><a class="header-anchor" href="#activity-states"><span>Activity States</span></a></h2><ul><li>Regular activities <ul><li>Instantaneous(순간적인) behavior</li><li>Interrupt(중단)될 수 없음.</li></ul></li><li>Normal state는 조용하며 다음 event를 기다린 후 무언가를 수행</li><li>Do-activities(수행-활동) <ul><li>Finite time(유한 시간) 소요</li><li>Interrupt될 수 있음. (멈출 수 있음.)</li></ul></li><li>Activity state(활동 상태)는 on-going work(진행 중인 작업)을 수행 중</li></ul><p><img src="'+x+'" alt="alt text"></p><h2 id="superstates" tabindex="-1"><a class="header-anchor" href="#superstates"><span>Superstates</span></a></h2><ul><li>여러 State가 공통의 transition 및 Internal activity를 공유</li><li>공유된 behavior를 superstate로 이동</li><li>Behavior가 modular(모듈식)/hierarchical(계층적) 방식으로 표현될 수 있음.</li></ul><p><img src="'+v+'" alt="alt text"></p><h1 id="deployment-diagrams" tabindex="-1"><a class="header-anchor" href="#deployment-diagrams"><span>Deployment Diagrams</span></a></h1><h2 id="deployment-diagrams-1" tabindex="-1"><a class="header-anchor" href="#deployment-diagrams-1"><span>Deployment Diagrams</span></a></h2><ul><li>Architecture 내 device, execution environment(실행 환경), artifact의 runtime architecture 표시</li><li>System topology의 물리적인 설명</li><li>Hardware unit의 구조와 각 유닛에서 실행되는 소프트웨어 기술</li></ul><p><img src="'+S+'" alt="alt text"></p><ul><li>Node <ul><li>Artifact가 실행을 위해 배포될 수 있는 Computational resource(컴퓨팅 자원)</li></ul></li><li>Communication path <ul><li>Node 간의 connection 표시</li><li>Stereotype은 통신 protocol이나 사용되는 network에 사용 가능</li></ul></li><li>Artifact <ul><li>Software development process 또는 system의 배포 및 운영에 의해 사용되거나 생성되는 물리적 piece of information의 Specification(명세, 사양)</li><li>예: 모델 파일, 소스 파일, 스크립트, 바이너리 실행 파일, 데이터베이스 시스템의 table, 개발 결과물, 워드 프로세싱 문서, 메일 message</li></ul></li></ul>',105)])])}const w=a(C,[["render",A]]),M=JSON.parse('{"path":"/se/9-UML.html","title":"9. Unified Modelling Language","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1762085426000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":2,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"d83fc4a25cd5d5561807c9b76848bd32cf88f34b","time":1762085426000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"docs: 수정된 좌표 표기법 및 UML 의존성 설명 개선"},{"hash":"446e2468e21d03cdcaaa9a90a015c7c7947590ec","time":1762074910000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Refactor code structure for improved readability and maintainability"}]},"filePathRelative":"se/9-UML.md"}');export{w as comp,M as data};
