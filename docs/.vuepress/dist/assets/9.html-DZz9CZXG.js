import{_ as s,c as n,a as e,o as l}from"./app-roWsHDGr.js";const i={};function t(p,a){return l(),n("div",null,[...a[0]||(a[0]=[e(`<h1 id="_9-memory-management-2" tabindex="-1"><a class="header-anchor" href="#_9-memory-management-2"><span>9. Memory Management (2)</span></a></h1><h2 id="structure-of-the-page-table" tabindex="-1"><a class="header-anchor" href="#structure-of-the-page-table"><span>Structure of the Page Table</span></a></h2><ul><li>Hierarchical Paging <ul><li>논리 주소 공간을 여러 페이지 테이블로 분할</li></ul></li><li>Hashed Page Tables</li><li>Inverted Page Tables</li></ul><h2 id="two-level-page-table-scheme-hierarchical-paging" tabindex="-1"><a class="header-anchor" href="#two-level-page-table-scheme-hierarchical-paging"><span>Two-Level Page-Table Scheme (Hierarchical Paging)</span></a></h2><ul><li>문제: 프로그램이 큰 주소 공간을 가짐 <ul><li>32비트 주소와 4KB (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>) 페이지 크기일 때 (m = 32, n = 12)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">m - n = 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span>, 즉 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>개의 논리 페이지</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>개의 페이지 테이블 항목</li><li>페이지 테이블 크기 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span> 바이트 (4MB, 각 항목이 4바이트일 경우)</li><li>4MB 페이지 테이블을 저장하려면, 프로세스당 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup><mo>=</mo><mn>1</mn><mi>K</mi></mrow><annotation encoding="application/x-tex">2^{10} = 1K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>개의 페이지 프레임 필요</li></ul></li><li>해결: <ul><li>전체 페이지 테이블을 디스크에 저장</li><li>페이지 테이블 자체도 페이지 단위로 요청 시 로딩 → 페이지 테이블을 위한 페이지 테이블 필요</li></ul></li></ul><h2 id="two-level-page-table-scheme" tabindex="-1"><a class="header-anchor" href="#two-level-page-table-scheme"><span>Two-Level Page-Table Scheme</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">      outer-page</span>
<span class="line">        table</span>
<span class="line">          ↓</span>
<span class="line">     -+       -+       -+</span>
<span class="line">     |    1     |-&gt; |   500    |       |   page   | → 메모리 내 실제 페이지</span>
<span class="line">     |    2     |-&gt; |   100    | →     |   100    |</span>
<span class="line">     |    3     |       |   300    |       |   page   |</span>
<span class="line">     |   ...    |       |   600    |       |   table  |</span>
<span class="line">     -+       -+       -+</span>
<span class="line"></span>
<span class="line">(어디에 논리 페이지에 대한 물리 페이지 번호를 저장하는 페이지 테이블 프레임이 있는가?)</span>
<span class="line">(어디에 논리 페이지에 해당하는 실제 물리 페이지가 있는가?)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="two-level-paging-example" tabindex="-1"><a class="header-anchor" href="#two-level-paging-example"><span>Two-Level Paging Example</span></a></h2><ul><li>논리 주소 (32비트 머신, 4KB 페이지 크기 기준)는 다음과 같이 나뉨: <ul><li>페이지 번호 (20비트)</li><li>페이지 오프셋 (12비트)</li></ul></li><li>페이지 번호는 두 부분으로 다시 나뉨: <ul><li>10비트 외부 페이지 번호: outer-page table에 접근</li><li>10비트 내부 페이지 번호: page table 내에 접근</li></ul></li><li>즉, 논리 주소 구성:</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">page number                page offset</span>
<span class="line">   p₁       p₂                 d</span>
<span class="line">   10       10                12</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>여기서: <ul><li>p₁: outer-page table 내 인덱스</li><li>p₂: 내부 page table에서의 displacement</li></ul></li></ul><h2 id="address-translation-scheme" tabindex="-1"><a class="header-anchor" href="#address-translation-scheme"><span>Address-Translation Scheme</span></a></h2><ul><li>2단계 32비트 페이징 구조의 주소 변환 방식:</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">logical address:   p₁ | p₂ | d</span>
<span class="line">                       ↓</span>
<span class="line">                outer-page table</span>
<span class="line">                       ↓</span>
<span class="line">                 page of page table</span>
<span class="line">                       ↓</span>
<span class="line">                       d</span>
<span class="line"></span>
<span class="line">&lt;Forward-mapped page table&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="multilevel-paging-and-performance" tabindex="-1"><a class="header-anchor" href="#multilevel-paging-and-performance"><span>Multilevel Paging and Performance</span></a></h2><ul><li>더 큰 주소 공간의 경우, <ul><li>세 번째 페이지는 (B-트리처럼) 데이터 블록이 아닌, 또 다른 레벨의 페이지 테이블</li><li>각 레벨이 메모리에 별도로 저장되므로, 논리 주소를 실제 주소로 변환할 때 최대 4회의 메모리 접근이 필요함</li></ul></li><li>메모리 접근 시간이 5배로 증가하더라도, TLB를 통해 성능은 합리적인 수준으로 유지됨 <ul><li>4단계 페이지 테이블에서도 TLB 히트율이 98%일 경우,<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mn>0.98</mn><mo>×</mo><mn>120</mn><mo>+</mo><mn>0.02</mn><mo>×</mo><mn>520</mn><mo>=</mo><mn>128</mn><mtext> nanoseconds</mtext></mrow><annotation encoding="application/x-tex"> EAT = 0.98 \\times 120 + 0.02 \\times 520 = 128~\\text{nanoseconds} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.98</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">120</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.02</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">520</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">128</span><span class="mspace nobreak"> </span><span class="mord text"><span class="mord">nanoseconds</span></span></span></span></span></span></p> (메모리 접근 시간이 100ns일 때, TLB 접근 시간 = 20ns)</li></ul></li><li>하지만 64비트 주소 체계에서는 6단계 페이징이 요구됨 <ul><li>현실적으로 부적절함</li><li>현대 64비트 운영체제에서는 48비트 주소를 사용하므로, 보통 4단계 페이징 사용</li></ul></li></ul><h2 id="hashed-page-tables" tabindex="-1"><a class="header-anchor" href="#hashed-page-tables"><span>Hashed Page Tables</span></a></h2><ul><li>주소 공간이 32비트보다 클 경우에 적합</li><li>가상 페이지 번호를 해시 함수로 페이지 테이블에 매핑 <ul><li>이 테이블은 동일 해시 위치에 대응하는 항목들의 체인으로 구성됨</li><li>체인 내부에서 가상 페이지 번호와 일치하는 항목을 찾으면 해당 물리 주소를 반환</li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">logical address (P | d)</span>
<span class="line">   ↓</span>
<span class="line">[hash function]</span>
<span class="line">   ↓</span>
<span class="line">[hash table] → [p1→p2→...] → 비교 → 일치 → [physical address]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="inverted-page-table" tabindex="-1"><a class="header-anchor" href="#inverted-page-table"><span>Inverted Page Table</span></a></h2><ul><li>문제: 페이지 테이블이 너무 큼 <ul><li>페이지 테이블의 크기는 전체 페이지 수에 비례</li><li>논리 페이지마다 하나의 테이블 항목이 필요</li><li>그러나 실제로는 동시에 적은 수의 페이지만 메모리에 존재함</li></ul></li><li>해결: 논리 페이지가 아닌 물리적 페이지 프레임당 하나의 테이블 항목만 유지 <ul><li>각 항목은 프로세스 ID 포함</li><li>하나의 시스템 전역 페이지 테이블 사용</li><li>필요한 항목 수는 물리 프레임 수와 동일</li><li>모든 프로세스가 공유하는 구조</li></ul></li></ul><h2 id="inverted-page-table-architecture" tabindex="-1"><a class="header-anchor" href="#inverted-page-table-architecture"><span>Inverted Page Table Architecture</span></a></h2><ul><li>단점: <ul><li>테이블 전체를 검색해야 함</li><li>페이지 공유 불가능</li></ul></li><li>해결책: <ul><li>해시 테이블을 사용해 검색 범위 제한 (한 번의 메모리 조회)</li><li>TLB와 병행 사용하여 속도 향상</li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">CPU</span>
<span class="line"> ↓</span>
<span class="line">[logical address] → [search]</span>
<span class="line">                         ↓</span>
<span class="line">                  → [page table]</span>
<span class="line">                  |             ↓</span>
<span class="line">[hash table]--+         [physical address]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="segmentation" tabindex="-1"><a class="header-anchor" href="#segmentation"><span>Segmentation</span></a></h2><ul><li>사용자의 메모리 관점을 지원하는 메모리 관리 기법</li><li>프로그램은 다양한 길이의 세그먼트들로 구성됨</li><li>세그먼트는 논리적 단위 (예: main(), 함수, 전역 변수, 스택, 심볼 테이블, 배열 등)</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">User&#39;s view of a program:</span>
<span class="line"></span>
<span class="line">--+</span>
<span class="line">| subroutine   |</span>
<span class="line">--+</span>
<span class="line">| stack        |</span>
<span class="line">--+</span>
<span class="line">| symbol table |</span>
<span class="line">--+</span>
<span class="line">| main program |</span>
<span class="line">--+</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="segmentation-architecture" tabindex="-1"><a class="header-anchor" href="#segmentation-architecture"><span>Segmentation Architecture</span></a></h2><ul><li>논리 주소 구조: <code>&lt;segment-number, offset&gt;</code></li><li>세그먼트 테이블 <ul><li>논리 주소를 물리 주소로 매핑</li><li>각 항목은 다음 포함: <ul><li>base: 세그먼트가 위치한 시작 물리 주소</li><li>limit: 세그먼트의 길이</li></ul></li></ul></li><li>STBR (Segment-table base register): <ul><li>세그먼트 테이블의 물리 위치를 가리킴</li></ul></li><li>STLR (Segment-table length register): <ul><li>사용 가능한 세그먼트 수를 나타냄</li><li>유효한 세그먼트 번호 조건: segment number &lt; STLR</li></ul></li></ul><h2 id="example-of-segmentation" tabindex="-1"><a class="header-anchor" href="#example-of-segmentation"><span>Example of Segmentation</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">User&#39;s view:</span>
<span class="line"></span>
<span class="line">--+    --+</span>
<span class="line">| subroutine   |    | segment 0    |</span>
<span class="line">--+    --+</span>
<span class="line">| stack        |    | segment 3    |</span>
<span class="line">--+    | segment 4    |</span>
<span class="line">| symbol table |    | segment 1    |</span>
<span class="line">--+    | segment 2    |</span>
<span class="line">| main program |    | segment 5    |</span>
<span class="line">--+    | segment 6    |</span>
<span class="line">| segment 1    |    | segment 7    |</span>
<span class="line">| segment 2    |    --+</span>
<span class="line">                   physical memory</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>세그먼트 테이블:</p><ul><li>segment 0 → base: 1400, limit: 1000</li><li>segment 1 → base: 6300, limit: 400</li><li>segment 2 → base: 4300, limit: 400 ...</li></ul><h2 id="segmentation-hardware" tabindex="-1"><a class="header-anchor" href="#segmentation-hardware"><span>Segmentation Hardware</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">logical address = (s, d)</span>
<span class="line"></span>
<span class="line">          --+       -+</span>
<span class="line">CPU &gt; |   s    |-&gt; |  segment table |</span>
<span class="line">          --+       -+</span>
<span class="line">                             |      |</span>
<span class="line">                             v      v</span>
<span class="line">                          limit    base</span>
<span class="line">                             |      |</span>
<span class="line">                             v      v</span>
<span class="line">                       if d &lt; limit?</span>
<span class="line">                             | yes</span>
<span class="line">                             v</span>
<span class="line">                        physical address = base + d</span>
<span class="line">                             |</span>
<span class="line">                             v</span>
<span class="line">                        physical memory</span>
<span class="line"></span>
<span class="line">else → trap (addressing error)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>보호 (Protection) <ul><li>세그먼트 테이블 항목마다 다음을 포함: <ul><li>valid/invalid bit = 0 → illegal segment</li><li>RWX 권한 비트</li></ul></li></ul></li><li>공유 (Sharing) <ul><li>세그먼트 수준에서 공유가 발생</li><li>공유 세그먼트의 경우, 모든 프로세스가 동일한 세그먼트 번호를 사용해야 함 <ul><li>예: 자기참조 코드가 segment number와 offset으로 자신을 참조</li></ul></li></ul></li><li>할당 (Allocation) <ul><li>세그먼트의 길이는 가변적이므로, 메모리 할당은 동적 할당 문제</li><li>first fit / best fit 전략 사용</li><li>외부 단편화 발생, 내부 단편화는 없음</li></ul></li></ul><h2 id="sharing-of-segments" tabindex="-1"><a class="header-anchor" href="#sharing-of-segments"><span>Sharing of Segments</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Process P1:</span>
<span class="line">  segment 0 = editor</span>
<span class="line">  segment 1 = data1</span>
<span class="line"></span>
<span class="line">Process P2:</span>
<span class="line">  segment 0 = editor</span>
<span class="line">  segment 1 = data2</span>
<span class="line"></span>
<span class="line">→ physical memory에서 editor는 공유되고,</span>
<span class="line">   data1, data2는 각자 분리되어 저장됨</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="segmentation-with-paging" tabindex="-1"><a class="header-anchor" href="#segmentation-with-paging"><span>Segmentation with Paging</span></a></h2><ul><li>외부 단편화 문제는 세그먼트를 페이지로 나누는 것으로 해결 가능</li><li>이 방식은 순수 segmentation과 다름: <ul><li>세그먼트 테이블 항목은 세그먼트의 base 주소가 아니라, page table의 base 주소를 포함</li></ul></li><li>가상 주소 형식:</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Segment number s | Page number p | Displacement d</span>
<span class="line">→ Virtual address V = (s, p, d)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="segmentation-with-paging-address-translation" tabindex="-1"><a class="header-anchor" href="#segmentation-with-paging-address-translation"><span>Segmentation with Paging: Address Translation</span></a></h2><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">logical address = (s, p, d)</span>
<span class="line"></span>
<span class="line">   ↓</span>
<span class="line">[STBR]</span>
<span class="line">   ↓</span>
<span class="line">segment table</span>
<span class="line">   ↓</span>
<span class="line">segment length, page-table base</span>
<span class="line"></span>
<span class="line">   ↓</span>
<span class="line">if p &lt; segment length?</span>
<span class="line">   ↓</span>
<span class="line">yes → page table → frame → +d → physical address → memory</span>
<span class="line">no  → trap (addressing error)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="segmentation-with-paging-tlb-incorporated" tabindex="-1"><a class="header-anchor" href="#segmentation-with-paging-tlb-incorporated"><span>Segmentation with Paging (TLB incorporated)</span></a></h2><ul><li>가상 주소 구조:<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>p</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> v = (s, p, d) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span></span></p><ul><li>s: 세그먼트 번호</li><li>p: 페이지 번호</li><li>d: 변위 (offset)</li></ul></li><li>흐름 요약:</li></ul><ol><li>세그먼트 테이블 시작점 레지스터가 주소 b를 가리킴</li><li>세그먼트 번호 s를 더해 해당 세그먼트 항목 주소 b + s로 접근</li><li>세그먼트 테이블에서: <ul><li>페이지 사상표(page table)의 시작 주소 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo mathvariant="normal">′</mo></mrow><annotation encoding="application/x-tex">s\\prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">s</span><span class="mord">′</span></span></span></span>를 얻음</li></ul></li><li>(s, p) 쌍이 TLB(연관 저장 장치)에 있는지 먼저 확인 <ul><li>있으면 TLB에 저장된 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo mathvariant="normal">′</mo></mrow><annotation encoding="application/x-tex">p\\prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">′</span></span></span></span> 값으로 바로 매핑</li><li>없으면: <ul><li>페이지 사상표에서 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>를 인덱스로 사용하여 페이지 프레임 번호 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo mathvariant="normal">′</mo></mrow><annotation encoding="application/x-tex">p\\prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">′</span></span></span></span>를 조회</li><li>TLB에 새 항목으로 저장 가능</li></ul></li></ul></li><li>페이지 프레임 번호 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo mathvariant="normal">′</mo></mrow><annotation encoding="application/x-tex">p\\prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">′</span></span></span></span>와 변위 d를 더해 실제 주소 r을 계산<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mo>=</mo><mi>p</mi><mo mathvariant="normal">′</mo><mo>+</mo><mi>d</mi></mrow><annotation encoding="application/x-tex"> r = p\\prime + d </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">′</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></span></p></li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">가상주소 v = (s, p, d)</span>
<span class="line">    ↓</span>
<span class="line">TLB에서 (s, p) 조회</span>
<span class="line">   ├─ 있으면 → $p\\prime$ 얻음</span>
<span class="line">   └─ 없으면</span>
<span class="line">       └─ 세그먼트 테이블 시작 주소 b + s 접근</span>
<span class="line">           └─ 세그먼트 s의 page table 주소 $s\\prime$ 획득</span>
<span class="line">               └─ page table에서 p 인덱스로 $p\\prime$ 조회</span>
<span class="line">                   └─ TLB에 (s, p) → $p\\prime$ 저장</span>
<span class="line"></span>
<span class="line">p\\prime + d → 실주소 r</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="filesystem" tabindex="-1"><a class="header-anchor" href="#filesystem"><span>FileSystem</span></a></h1><h2 id="페이지-테이블의-한계" tabindex="-1"><a class="header-anchor" href="#페이지-테이블의-한계"><span>페이지 테이블의 한계</span></a></h2><ul><li>하나의 page table이 너무 커질 경우, 연속적인 메모리 공간을 차지하기 어려움</li><li>1024개의 entry가 필요할 경우, 각각의 entry는 4KB frame으로 구성됨</li></ul><h2 id="다단계-페이지-테이블" tabindex="-1"><a class="header-anchor" href="#다단계-페이지-테이블"><span>다단계 페이지 테이블</span></a></h2><ul><li>페이지 테이블을 계층 구조로 나누어 관리</li><li>Outer Page Table → Inner Page Table → Data Page</li><li>각 테이블은 하나의 frame에 1024개 entry를 가짐</li><li>Logical Address: 상위 10비트 (outer index), 중간 10비트 (inner index), 하위 12비트 (offset)</li></ul><h2 id="주소-변환-방식" tabindex="-1"><a class="header-anchor" href="#주소-변환-방식"><span>주소 변환 방식</span></a></h2><ol><li>Logical Address를 10/10/12 비트로 나눔</li><li>Outer index → inner page table의 위치</li><li>Inner index → data page의 위치</li><li>offset을 더해서 최종 physical address 계산</li></ol><h2 id="_64비트-주소-체계" tabindex="-1"><a class="header-anchor" href="#_64비트-주소-체계"><span>64비트 주소 체계</span></a></h2><ul><li>너무 많은 entry로 인해 현실적으로 사용 어려움</li><li>실제 구현에서는 48비트만 사용 (4레벨 구조)</li><li>TLB가 이 과정을 캐시하여 성능 저하 방지</li></ul><h1 id="inverted-page-table-1" tabindex="-1"><a class="header-anchor" href="#inverted-page-table-1"><span>Inverted Page Table</span></a></h1><h2 id="개념" tabindex="-1"><a class="header-anchor" href="#개념"><span>개념</span></a></h2><ul><li>기존 page table이 logical → physical 변환이라면,</li><li>Inverted page table은 physical → logical 변환</li><li>전체 물리 메모리를 기준으로 하나의 page table만 유지</li></ul><h2 id="장점" tabindex="-1"><a class="header-anchor" href="#장점"><span>장점</span></a></h2><ul><li>프로세스마다 page table을 만들지 않아도 됨</li><li>메모리 절약 가능</li></ul><h2 id="문제점" tabindex="-1"><a class="header-anchor" href="#문제점"><span>문제점</span></a></h2><ul><li>associative search 필요 → 성능 저하</li><li>공유 어려움 (PID 기반 매칭 필요)</li><li>Sharing에 제약 많고 탐색시간이 증가함</li></ul><h2 id="해결-시도" tabindex="-1"><a class="header-anchor" href="#해결-시도"><span>해결 시도</span></a></h2><ul><li>Hashing 기반 탐색 구조 사용</li><li>Chain이 없는 hash function 설계가 핵심</li></ul><h1 id="segmentation-1" tabindex="-1"><a class="header-anchor" href="#segmentation-1"><span>Segmentation</span></a></h1><h2 id="개념-1" tabindex="-1"><a class="header-anchor" href="#개념-1"><span>개념</span></a></h2><ul><li>메모리를 의미 단위(함수, 라이브러리, 스택 등)로 나눔</li><li>Logical address = segment 번호 + offset</li><li>주소 변환 시 base address + offset 방식</li></ul><h2 id="장점-1" tabindex="-1"><a class="header-anchor" href="#장점-1"><span>장점</span></a></h2><ul><li>의미 단위 공유 가능</li><li>다양한 protection level 부여 가능</li></ul><h2 id="단점" tabindex="-1"><a class="header-anchor" href="#단점"><span>단점</span></a></h2><ul><li>연속적 메모리 요구 → external fragmentation 발생 가능</li></ul><h1 id="segmentation-with-paging-1" tabindex="-1"><a class="header-anchor" href="#segmentation-with-paging-1"><span>Segmentation with Paging</span></a></h1><h2 id="개념-2" tabindex="-1"><a class="header-anchor" href="#개념-2"><span>개념</span></a></h2><ul><li>Segmentation을 기반으로, 각 segment 안에 paging 기법 적용</li><li>각 segment는 paging 기법을 통해 내부 주소 공간 관리</li></ul><h2 id="장점-2" tabindex="-1"><a class="header-anchor" href="#장점-2"><span>장점</span></a></h2><ul><li>공유 단위 유지 (segment)</li><li>paging을 통해 내부 fragmentation 해결</li></ul><h2 id="주소-변환-방식-1" tabindex="-1"><a class="header-anchor" href="#주소-변환-방식-1"><span>주소 변환 방식</span></a></h2><ol><li>Logical address = segment 번호 + offset</li><li>segment 번호 → 해당 segment의 page table 주소</li><li>offset → page index + page offset</li><li>최종적으로 frame 번호 + offset으로 physical address 계산</li></ol><h1 id="정리-주소-변환-과정" tabindex="-1"><a class="header-anchor" href="#정리-주소-변환-과정"><span>정리: 주소 변환 과정</span></a></h1><h2 id="전체-흐름" tabindex="-1"><a class="header-anchor" href="#전체-흐름"><span>전체 흐름</span></a></h2><ul><li>CPU가 logical address 생성 (seg#, page#, offset)</li><li>TLB 실패 시 → segment table/page table 탐색</li><li>frame 번호 획득 후 offset 더하여 physical address 생성</li></ul><h1 id="결론" tabindex="-1"><a class="header-anchor" href="#결론"><span>결론</span></a></h1><ul><li>Multi-level paging, inverted page table, segmentation, segmentation with paging은 각기 다른 상황에서 trade-off를 가지는 메모리 관리 기법</li><li>효율적인 메모리 사용과 공유, 보호 수준 제공을 위한 다양한 구조적 시도</li></ul>`,84)])])}const r=s(i,[["render",t]]),c=JSON.parse('{"path":"/os/9.html","title":"9. Memory Management (2)","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1764506597000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":7,"url":"https://github.com/kmbzn"},{"name":"김병준","username":"","email":"kmbzn24@hanyang.ac.kr","commits":1}],"changelog":[{"hash":"4997c37eb1d4ad491f033600ca10151bd286506e","time":1764506597000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"탭 개편"},{"hash":"f81f9042e7888855a506f92261c74aaa2d86aa2a","time":1764305376000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update npm"},{"hash":"d83fc4a25cd5d5561807c9b76848bd32cf88f34b","time":1762085426000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"docs: 수정된 좌표 표기법 및 UML 의존성 설명 개선"},{"hash":"7dfc10ae87be9ce0083cb39d24d30b15e77a0371","time":1749897692000,"email":"kmbzn24@hanyang.ac.kr","author":"김병준","message":"directory name change"},{"hash":"0bcd31829c652a9bbf03564b05b0c23bda2af518","time":1749486934000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update 요약"},{"hash":"03cd770d5fee5783f5cf264e71aab51bd9333c96","time":1749482620000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update"},{"hash":"227ebf829b5a9903d4340b2d69a0f85f5fe3b601","time":1748840888000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update file name"},{"hash":"21eb54832113279f03578ae6f740db3f7338cf13","time":1748840663000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update os"}]},"filePathRelative":"os/9.md"}');export{r as comp,c as data};
