import{_ as a,c as n,a as e,o as t}from"./app-BV4FAx4-.js";import"./vendor-bWEtUbjf.js";/* empty css                 */const i={};function l(p,s){return t(),n("div",null,[...s[0]||(s[0]=[e(`<h1 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree"><span>B+tree</span></a></h1><h2 id="b-tree-operation-deletion" tabindex="-1"><a class="header-anchor" href="#b-tree-operation-deletion"><span>B+tree Operation : Deletion</span></a></h2><ul><li>Function <code>delete(value K, pointer P)</code><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mtext> </mtext><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(K,~P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span>를 포함하는 leaf node <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>을 탐색</li><li><code>delete_entry(L, K, P)</code> 호출</li></ul></li></ul><div class="language-pseudocode line-numbers-mode" data-highlighter="prismjs" data-ext="pseudocode"><pre><code class="language-pseudocode"><span class="line">function delete(value K, pointer P)</span>
<span class="line">    find the leaf node L that contains (K, P)</span>
<span class="line">    delete_entry(L, K, P)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Function <code>delete_entry(node N, value K, pointer P)</code><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>에서 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mtext> </mtext><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(K,~P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span> 제거</li><li>If (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>이 root이고 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>이 하나의 child만 가질 경우) <ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>의 child를 tree의 새 root로 설정하고 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>을 삭제</li></ul></li><li>Else if (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>이 너무 적은 value/pointer를 가질 경우) <ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">N&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>을 <code>parent(N)</code>의 이전 또는 다음 child로 설정</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>을 <code>parent(N)</code>에서 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>과 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">N&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> pointer 사이의 value로 설정</li><li>If (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>과 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">N&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>의 entries가 단일 node에 맞을 수 있는 경우) /* Coalesce nodes */ <ul><li>...</li></ul></li><li>Else /* Redistribution: borrow an entry from N&#39; */ <ul><li>...</li></ul></li></ul></li></ul></li></ul><div class="language-pseudocode line-numbers-mode" data-highlighter="prismjs" data-ext="pseudocode"><pre><code class="language-pseudocode"><span class="line">function delete_entry(node N, value K, pointer P)</span>
<span class="line">    remove (K, P) from N</span>
<span class="line">    if (N is the root and N has only one remaining child)</span>
<span class="line">        then make the child of N the new root of the tree and delete N</span>
<span class="line">    else if (N has too few values/pointers) then begin</span>
<span class="line">        Let N&#39; be the previous or next child of parent(N)</span>
<span class="line">        Let K&#39; be the value between pointers N and N&#39; in parent(N)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>에서 entry <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mtext> </mtext><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(K,~P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span>를 제거</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>이 entry 제거 후 underflow (너무 적은 수의 value/pointer) 상태인지 확인</li><li>Underflow 상태라면, <code>parent(N)</code>에서 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>의 형제 node <code>N&#39;</code> (이전 또는 다음)와 그 사이의 key <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>를 찾음</li></ul><div class="language-pseudocode line-numbers-mode" data-highlighter="prismjs" data-ext="pseudocode"><pre><code class="language-pseudocode"><span class="line">        if (entries in N and N&#39; can fit in a single node)</span>
<span class="line">            then begin /* Coalesce nodes */</span>
<span class="line">                if (N is a predecessor of N&#39; ) then swap_variables(N, N&#39;)</span>
<span class="line">                if (N is not a leaf)</span>
<span class="line">                    then append K&#39; and all pointers and values in N to N&#39;</span>
<span class="line">                else append all (K_i, P_i) pairs in N to N&#39; ; set N&#39;.P_n = N.P_n</span>
<span class="line">                delete_entry(parent(N), K&#39;, N); delete node N</span>
<span class="line">            end</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>delete_entry</code>의 <code>Coalesce nodes</code> (병합) 과정 <ul><li><code>if (N is a predecessor of N&#39;) ...</code>: 제일 왼쪽 node일 경우 오른쪽 형제 node와 <code>swap</code></li><li><code>if (N is not a leaf) ...</code>: 형제 node에 이정표가 되는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 값을 삽입하고 자신의 key 개수만큼 형제 node에 key값과 pointer를 삽입. 옮겨진 pointer들이 참조하는 node들의 부모 node는 모두 형제 node를 가리켜야 함</li><li><code>else (N is a leaf) ...</code>: 형제 node에 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 값 삽입 과정을 생략하고, 자신의 key 개수만큼 형제 node에 key값과 pointer를 삽입한 다음 마지막 pointer가 자신이 가리키던 형제 node를 가리키도록 함</li></ul></li></ul><div class="language-pseudocode line-numbers-mode" data-highlighter="prismjs" data-ext="pseudocode"><pre><code class="language-pseudocode"><span class="line">        else begin /* Redistribution: borrow an entry from N&#39; */</span>
<span class="line">            if (N&#39; is a predecessor of N) then begin</span>
<span class="line">                if (N is a nonleaf node) then begin</span>
<span class="line">                    let m be such that N&#39;.P_m is the last pointer in N&#39;</span>
<span class="line">                    remove (N&#39;.K_{m-1},~N&#39;.P_m ) from N&#39;</span>
<span class="line">                    insert (N&#39;.P_m,~K&#39; ) as the first pointer and value in N,</span>
<span class="line">                         by shifting other pointers and values right</span>
<span class="line">                    replace K&#39; in parent(N) by N&#39;.K_{m-1}</span>
<span class="line">                end</span>
<span class="line">                else begin</span>
<span class="line">                    let m be such that (N&#39;.P_m,~N&#39;.K_m ) is the last pointer/value pair in N&#39;</span>
<span class="line">                    remove (N&#39;.P_m,~N&#39;.K_m) from N&#39;</span>
<span class="line">                    insert (N&#39;.P_m,~N&#39;.K_m ) as the first pointer and value in N,</span>
<span class="line">                         by shifting other pointers and values right</span>
<span class="line">                    replace K&#39; in parent(N) by N&#39;.K_m</span>
<span class="line">                end</span>
<span class="line">            end</span>
<span class="line">            else ... symmetric to the then case ...</span>
<span class="line">        end</span>
<span class="line">    end</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>delete_entry</code>의 Redistribution (재분배) 과정 <ul><li><code>if (N&#39; is a predecessor of N)</code> 경우 (왼쪽 형제 node <code>N&#39;</code>에서 빌려오는 경우) <ul><li><code>if (N is a nonleaf node) ...</code>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> node의 key값과 pointer 배열 값을 한 칸씩 뒤로 미룸. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>의 <code>pointer[0]</code>이 왼쪽 형제 node에서 제일 오른쪽에 위치한 pointer가 가리키던 자식 node를 가리키도록 하고 부모 node 재설정. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>의 가장 왼쪽에 위치한 key값은 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 값으로 새로운 이정표 역할. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>의 부모 node 이정표 값은 형제 node에서 제일 오른쪽에 위치한 key값이 이정표 역할</li><li><code>else (N is a leaf node) ...</code>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> node의 key값과 pointer 배열 값을 한 칸씩 뒤로 미룸. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>의 왼쪽 형제 node에서 제일 오른쪽에 위치한 key값과 pointer 배열 값을 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>의 제일 왼쪽 위치로 이동시키고 가리키는 부모 node 재설정</li></ul></li></ul></li></ul><h2 id="질문-만약-node가-이미-제일-왼쪽인-상태에서-key-rotation을-해야하는-상황이라면" tabindex="-1"><a class="header-anchor" href="#질문-만약-node가-이미-제일-왼쪽인-상태에서-key-rotation을-해야하는-상황이라면"><span>(질문) 만약 node가 이미 제일 왼쪽인 상태에서 Key Rotation을 해야하는 상황이라면?</span></a></h2><ul><li><p><code>N</code>이 가장 왼쪽 node인 경우, &quot;previous&quot; (왼쪽) 형제 node가 없음</p></li><li><p><code>delete_entry</code> logic의 <code>Let N&#39; be the previous or next child...</code> 부분에 따라, <code>N&#39;</code>은 &quot;next&quot; (오른쪽) 형제 node로 설정됨</p></li><li><p>이 상황은 Redistribution (재분배) logic의 <code>else ... symmetric to the then case ...</code> 부분에 해당함</p></li><li><p>즉, 왼쪽 형제 node (<code>N&#39;</code>)에서 마지막 entry를 가져오는 <code>if (N&#39; is a predecessor of N)</code> case 대신, 오른쪽 형제 node (<code>N&#39;</code>)에서 <em>첫 번째</em> entry를 가져오는 (symmetric) logic이 수행됨</p></li><li><p>Non-leaf node의 경우:</p><ul><li><code>parent(N)</code>의 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 값을 <code>N</code>의 <em>마지막</em> key로 가져옴</li><li><code>N&#39;</code> (오른쪽 형제)의 <em>첫 번째</em> pointer (<code>N&#39;.P_0</code>)를 <code>N</code>의 <em>마지막</em> pointer로 가져옴</li><li><code>N&#39;</code>의 <em>첫 번째</em> key (<code>N&#39;.K_0</code>)를 <code>parent(N)</code>의 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 자리로 이동시킴</li><li><code>N&#39;</code>에서 (<code>N&#39;.K_0</code>, <code>N&#39;.P_0</code>)를 제거</li></ul></li><li><p>Leaf node의 경우:</p><ul><li><code>N&#39;</code> (오른쪽 형제)의 <em>첫 번째</em> entry (<code>N&#39;.K_0</code>, <code>N&#39;.P_0</code>)를 <code>N</code>의 <em>마지막</em> entry로 가져옴</li><li><code>N&#39;</code>에서 (<code>N&#39;.K_0</code>, <code>N&#39;.P_0</code>)를 제거</li><li><code>parent(N)</code>의 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">K&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 값을 <code>N&#39;</code>의 <em>새로운 첫 번째</em> key (기존 <code>N&#39;.K_1</code>) 값으로 update함</li></ul></li></ul>`,13)])])}const r=a(i,[["render",l]]),h=JSON.parse('{"path":"/db/LAB08.html","title":"B+tree","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1762074910000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":1,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"446e2468e21d03cdcaaa9a90a015c7c7947590ec","time":1762074910000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Refactor code structure for improved readability and maintainability"}]},"filePathRelative":"db/LAB08.md"}');export{r as comp,h as data};
