import{_ as e,c as i,a as r,o as a}from"./app-roWsHDGr.js";const o="/assets/image-61-DY-08zAk.png",n="/assets/image-62-BrFeDYk5.png",l="/assets/image-63-DYQmNUpf.png",s={};function c(d,t){return a(),i("div",null,[...t[0]||(t[0]=[r('<h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Homework #1-2</mtext></mrow><annotation encoding="application/x-tex">\\text{Homework \\#1-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Homework #1-2</span></span></span></span></span></span></a></h1><ul><li>Software Engineering (10780)</li><li>학번: 2021024057</li><li>이름: 김병준</li></ul><h2 id="_1-과제-분석-및-사용-design-pattern" tabindex="-1"><a class="header-anchor" href="#_1-과제-분석-및-사용-design-pattern"><span>1. 과제 분석 및 사용 Design Pattern</span></a></h2><p><strong>Homework #1-2</strong>의 주요한 목표는 소프트웨어의 유연성, 확장성, 유지보수성을 높이는 세 가지 design pattern을 적용하는 것입니다.</p><table><thead><tr><th>#</th><th>요구사항</th><th>Design Pattern</th><th>Design Principle</th></tr></thead><tbody><tr><td><strong>P1</strong></td><td><code>java.io.Writer/Reader</code>에 암호화/복호화 기능 추가</td><td>Decorator Pattern</td><td>OCP</td></tr><tr><td><strong>P2</strong></td><td>다양한 암호화 알고리즘 지원 기능 추가</td><td>Strategy Pattern</td><td>SRP</td></tr><tr><td><strong>P3</strong></td><td>Directory 구조에서 keyword 검색 기능 구현</td><td>Visitor Pattern</td><td>OCP and DIP</td></tr></tbody></table><h2 id="_2-design-pattern-implementation-and-argument" tabindex="-1"><a class="header-anchor" href="#_2-design-pattern-implementation-and-argument"><span>2. Design Pattern Implementation and Argument</span></a></h2><h3 id="_2-1-p1-decorator-pattern-기반-encryptwriter-및-decryptreader-구현" tabindex="-1"><a class="header-anchor" href="#_2-1-p1-decorator-pattern-기반-encryptwriter-및-decryptreader-구현"><span>2.1. <strong>P1</strong>: Decorator Pattern 기반 <code>EncryptWriter</code> 및 <code>DecryptReader</code> 구현</span></a></h3><blockquote><p><strong>Decorator UML class diagram</strong>[1]<br><img src="'+o+'" alt="alt text"></p></blockquote><ul><li>Decorator Pattern은 객체의 기능에 새로운 responsibility를 동적으로 추가하는 구조적인 패턴입니다.</li><li>Subclassing 대신 객체 구성을 통해 기능을 확장하는 대안을 제공합니다.</li><li>적용: 기존의 I/O 스트림 class(Writer, Reader)를 수정하지 않고, 그 위에 <code>EncryptWriter</code>와 <code>DecryptReader</code>라는 Decorator를 씌워 암호화/복호화 기능을 추가합니다.</li><li>Design Pattern <ul><li><code>EncryptWriter</code>는 내부적으로 다른 Writer 객체를 참조하며, <code>write()</code>가 호출될 때 Caesar cipher (3칸 왼쪽 rotation)를 적용한 후, wrapping된 객체의 <code>write()</code>를 호출하여 데이터를 전달하게 됩니다.</li><li><code>DecryptReader</code>는 wrapping된 Reader 객체에서 데이터를 읽어온 후, 역변환을 수행하여 복호화된 문자를 반환합니다.</li></ul></li><li>이 구현은 OCP (Open-Closed Principle)를 만족시키게 됩니다. 기존의 <code>java.io</code> 스트림 class는 수정에 대해 closed되면서도, Decorator라는 새로운 wrapping class를 통해 암호화라는 새로운 기능을 확장에 대해 open되었습니다.</li></ul><h3 id="_2-2-p2-strategy-pattern을-활용한-알고리즘-확장" tabindex="-1"><a class="header-anchor" href="#_2-2-p2-strategy-pattern을-활용한-알고리즘-확장"><span>2.2. <strong>P2</strong>: Strategy Pattern을 활용한 알고리즘 확장</span></a></h3><blockquote><p><strong>Strategy Pattern UML diagram</strong>[2]<br><img src="'+n+'" alt="alt text"></p></blockquote><ul><li>Strategy Pattern은 알고리즘군을 정의하고, 각 알고리즘을 encapsulization한 후, 이들을 상호 교환 가능하게 만드는 behavior pattern입니다.</li><li>Strategy Design Pattern은 유연하고 재사용 가능한 객체 지향 소프트웨어를 설계하기 위해 반복되는 디자인 문제를 해결하는 방법</li><li>&quot;객체는 구현, 변경, 테스트, 재사용이 쉬워야 한다&quot;의 내용을 포함한 23가지 GoF(Gang of Four) 디자인 패턴들 중 하나입니다.</li><li><strong>P1</strong>에서 구현된 <code>EncryptWriter</code>와 <code>DecryptReader</code>가 고정된 Ceaser 암호 알고리즘 대신 실행 시점에 (원하는) 암호화 방식을 선택할 수 있도록 유연성을 강화하였습니다.</li><li>Design Pattern <ul><li>Strategy: <code>EncryptionStrategy</code> 인터페이스를 정의하고, 모든 암호화 알고리즘이 이를 구현하도록 강제하고 있습니다.</li><li>Concrete Strategy: <code>CaesarCipherStrategy</code>와 <code>CaseSwapStrategy</code>가 여기에 해당합니다.</li><li>Context: <code>EncryptWriter</code>와 <code>DecryptReader</code>는 <code>EncryptionStrategy</code> 객체를 필드로 유지하며, 실제 암호화/복호화 logic을 이 객체에 위임합니다.</li></ul></li><li>관련된 design principles <ol><li>SRP: <code>EncryptWriter</code>는 더 이상 &quot;데이터 쓰기&quot; 책임과 &quot;암호화 알고리즘&quot; 책임을 동시에 가지지 않게 됩니다. 알고리즘의 로직은 <code>Strategy</code> class로 분리되어 SRP를 만족합니다.</li><li>OCP: 새로운 암호화 방식이 추가되어도 (like <code>SHA</code> or <code>AES</code>), Strategy 인터페이스를 구현하는 새로운 class만 추가하면 되고, 핵심 class인 <code>EncryptWriter</code>의 코드를 수정할 필요가 없을 것입니다.</li></ol></li></ul><h3 id="_2-3-p3-visitor-pattern-기반-findvisitor-구현" tabindex="-1"><a class="header-anchor" href="#_2-3-p3-visitor-pattern-기반-findvisitor-구현"><span>2.3. <strong>P3</strong>: Visitor Pattern 기반 <code>FindVisitor</code> 구현</span></a></h3><blockquote><p><strong>Visitor Pattern UML diagram</strong>[3]<br><img src="'+l+'" alt="alt text"></p></blockquote><ul><li>Visitor Pattern은 객체 구조(Directory 구조)를 변경하지 않고, 구조의 Element들에 대해 수행할 새로운 연산(Operation)을 정의할 수 있도록 하는 behavior pattern입니다.</li><li>적용: 파일 시스템의 Element (File 및 Directory) class에 keyword 검색이라는 새로운 기능을 추가합니다.</li><li>Design Pattern <ul><li>Element: Entry (File 및 Directory 의 상위 추상 class)는 <code>accept(Visitor v)</code> method를 정의하여 방문자를 받아들입니다.</li><li>Visitor: <code>Visitor</code> interface는 <code>visit(File)</code>과 <code>visit(Directory)</code>와 같이 각 Element 유형별 연산을 정의합니다.</li><li>Concrete Visitor: <code>FindVisitor</code>는 이 Visitor를 구현하여 visit method 내에서 이름에 keyword가 포함되어 있는지 검사하는 검색 logic을 수행합니다. Directory를 방문할 때는 재귀적으로 자식 Entry에 대해 <code>accept()</code>를 호출하여 구조 전체를 탐색합니다.</li></ul></li><li>관련된 design principles <ol><li>OCP: 파일과 Directory를 나타내는 Element class에 별도의 수정 없이 <code>FindVisitor</code>라는 새로운 기능을 추가할 수 있습니다. <ul><li>e.g., 추후에 &#39;용량 계산&#39;이라는 기능이 필요하게 되어도 <code>SizeVisitor</code>만 추가하면 될 것입니다.</li></ul></li><li>DIP: Element class는 detail한 <code>FindVisitor</code> class가 아닌 Visitor라는 추상화된 인터페이스에 의존합니다. <ul><li>이는 상위 모듈이 하위 모듈의 detail한 구현에 의존하는 것을 방지하여 의존성을 inversion시킵니다.</li></ul></li></ol></li></ul><h2 id="_3-conclusion" tabindex="-1"><a class="header-anchor" href="#_3-conclusion"><span>3. Conclusion</span></a></h2><ul><li><strong>Homework #1-2</strong>에서는 Design Pattern의 적절한 사용을 통해 소프트웨어 품질을 향상시키는 방법을 다루고 있습니다.</li><li>각 패턴들이 제공한 장점들 <ol><li>Decorator Pattern &amp; Strategy Pattern <ul><li>Loose Coupling: I/O 처리와 암호화 로직을 분리하였고, 암호화 로직과 알고리즘을 분리하여 결합도를 최소화했습니다.</li></ul></li><li>Visitor Pattern <ul><li>High Cohesion: 파일 시스템 순회 로직과 keyword 검색 로직을 분리하여 각 class의 응집도를 높였습니다.</li></ul></li><li>OCP/SRP/DIP 준수 <ul><li>요구사항 변경 시 기존 코드의 수정 없이 새로운 기능을 확장할 수 있는 design을 확립했습니다.</li></ul></li></ol></li><li>각 패턴들은 상호보완적으로 작용하여 <ol><li>모듈화된</li><li>유연한</li></ol></li><li>시스템을 구축하는 데 기여할 수 있었습니다.</li><li>이러한 이유로, 구현한 코드들은 design goal를 달성하였으며, design principle들을 준수한 객체 지향 solution이라고 할 수 있습니다.</li></ul><h2 id="_4-works-cited" tabindex="-1"><a class="header-anchor" href="#_4-works-cited"><span>4. Works Cited</span></a></h2><ul><li><p>[1] Wikipedia, &quot;Decorator pattern&quot; <a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Decorator_pattern</a></p></li><li><p>[2] Wikipedia, &quot;Strategy pattern&quot; <a href="https://en.wikipedia.org/wiki/Strategy_pattern" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Strategy_pattern</a></p></li><li><p>[3] Wikipedia, &quot;Visitor pattern&quot; <a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Visitor_pattern</a></p></li></ul>',19)])])}const g=e(s,[["render",c]]),m=JSON.parse('{"path":"/se/wiki-2.html","title":"","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1764082059000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":2,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"3234ac40491dbff8d82fcbb9da5da9823ffbd763","time":1764082059000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"md title level lessen"},{"hash":"eccceaaadcd967d6c9ccd932a5897280a0f9ecdf","time":1764081817000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Add homework documentation for Software Engineering course, including design pattern analysis and implementation details"}]},"filePathRelative":"se/wiki-2.md"}');export{g as comp,m as data};
