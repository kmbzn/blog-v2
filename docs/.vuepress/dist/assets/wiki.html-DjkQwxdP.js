import{_ as t}from"./image-47-B1ghMqws.js";import{_ as i,c as o,a as s,o as n}from"./app-CFlH2mst.js";const l="/assets/image-58-CBfevXUh.png",r="/assets/image-59-Clowmk2K.png",a="/assets/image-60-CXChkqeA.png",c={};function d(p,e){return n(),o("div",null,[...e[0]||(e[0]=[s('<h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Homework #1-1</mtext></mrow><annotation encoding="application/x-tex">\\text{Homework \\#1-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Homework #1-1</span></span></span></span></span></span></a></h1><ul><li>Software Engineering (10780)</li><li>학번: 2021024057</li><li>이름: 김병준</li></ul><h2 id="_1-디자인-분석" tabindex="-1"><a class="header-anchor" href="#_1-디자인-분석"><span>1. 디자인 분석</span></a></h2><blockquote><p><strong>Design A</strong><img src="'+l+'" alt="alt text"></p></blockquote><blockquote><p><strong>Design B</strong><img src="'+r+'" alt="alt text"></p></blockquote><ul><li>위에 제시된 두 디자인은 모두 고객(<code>Customor</code>) 정보를 관리하는 시스템의 Class diagram을 나타내고 있습니다.</li><li>특히 <code>CustomerList</code> class에서 고객 정보가 변경될 때 다른 부분(<code>MarketingLetters</code>, <code>CustomerManagementDialog</code>)으로 <strong>변경되었음을 전달</strong>하는 방식에 차이가 있음을 확인할 수 있었습니다.</li></ul><table><thead><tr><th>특징</th><th><strong>Design A</strong></th><th><strong>Design B</strong></th></tr></thead><tbody><tr><td>변경 알림 방식</td><td><code>CustomerList</code>가 직접 다른 class의 method를 호출</td><td>Observer Pattern 기반의 간접 호출</td></tr><tr><td><code>CustomerList</code>의 역할</td><td>고객 데이터 관리 및 UI/마케팅 로직 직접 처리</td><td>고객 데이터 관리 및 event 알림 역할만 수행</td></tr><tr><td>Coupling(결합도)</td><td><code>CustomerList</code>가 <code>MarketingLetters</code>와 <code>CustomerManagementDialog</code>에 직접 결합</td><td><code>CustomerList</code>가 <code>CustomerEventHandler</code> interface에만 간접 결합</td></tr><tr><td>확장/유지보수</td><td>새로운 기능을 추가하려면 <code>CustomerList</code>를 수정해야 함</td><td>새로운 Listener를 추가하여 기능 확장 가능</td></tr></tbody></table><h2 id="_2-design-principle-and-pattern-based-argue" tabindex="-1"><a class="header-anchor" href="#_2-design-principle-and-pattern-based-argue"><span>2. Design principle and pattern-based argue</span></a></h2><h3 id="_2-1-design-pattern-observer-pattern" tabindex="-1"><a class="header-anchor" href="#_2-1-design-pattern-observer-pattern"><span>2.1. (Design Pattern) Observer Pattern</span></a></h3><blockquote><p>Observer Pattern (a.k.a. &quot;Publish-Subscribe&quot;)<br><em>&quot;객체 간 일대다 종속성을 정의하여, 객체의 상태가 변경될 때 모든 종속 객체가 자동으로 통지받고 업데이트되도록 한다.&quot;</em> [1] <img src="'+t+'" alt="alt text"></p></blockquote><ul><li><strong>Design B</strong>는 observer pattern을 명확하게 반영하고 있습니다. <ul><li>Subject: <code>CustomerList</code> (이벤트 발생 시 observer들에게 알림)</li><li>Observer: <code>CustomerEventHandler</code> interface를 구현하는 <code>MarketingLetters</code>와 <code>CustomerListListener</code> (이벤트 수신 및 처리)</li><li><code>CustomerList</code>는 어떤 class가 자신의 이벤트를 수신하게 되는지 알 필요가 없습니다.</li><li>Event를 <code>handler</code>에게 전파하기만 하면 됩니다. <ul><li>이는 Loose Coupling 조건을 충족합니다.</li></ul></li></ul></li></ul><h3 id="_2-2-design-principle-single-responsibility-principle-srp" tabindex="-1"><a class="header-anchor" href="#_2-2-design-principle-single-responsibility-principle-srp"><span>2.2. (Design Principle) Single Responsibility Principle(SRP)</span></a></h3><blockquote><p>&quot;<em>객체 지향 프로그래밍에서 <strong>단일 책임 원칙</strong>(single responsibility principle)이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다.</em>&quot; [2]</p></blockquote><ul><li><strong>Design A</strong><ul><li><code>CustomerList</code>가 가지고 있는 responsibility들 <ol><li>고객 리스트 관리 (<code>customers.add(customer)</code>)</li><li>마케팅 편지 발송 처리 (<code>marketing.customerAdded(customer)</code>)</li><li>UI 리스트 업데이트 처리 (<code>gui.list.add(customer.name)</code>)</li></ol></li><li>이는 SRP 위반에 해당합니다.</li></ul></li><li><strong>Design B</strong><ul><li><code>CustomerList</code>는 고객 리스트 관리 및 이벤트 발생 알림이라는 single responsibility만 가집니다.</li><li>마케팅 관련 책임은 <code>MarketingLetters</code>에, UI 업데이트 관련 책임은 <code>CustomerListListener</code>를 구현하는 class에 분리되어 있습니다.</li><li>이는 SRP를 만족시킨다고 할 수 있습니다.</li></ul></li></ul><h3 id="_2-3-design-pattern-open-closed-principle-ocp" tabindex="-1"><a class="header-anchor" href="#_2-3-design-pattern-open-closed-principle-ocp"><span>2.3. (Design Pattern) Open-Closed Principle (OCP)</span></a></h3><blockquote><p>&quot;<em>개방-폐쇄 원칙(OCP, Open-Closed Principle)은 &#39;소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다&#39;는 프로그래밍 원칙이다.</em>&quot; [3]</p></blockquote><ul><li><strong>Design A</strong><ul><li>고객 추가 시 다른 작업을 추가하려면 (<code>Accounting</code> 모듈에 알림 보내기 등), <code>CustomerList</code> class의 <code>addCustomer()</code> method를 수정해야 합니다. (기능 추가에 대해 closed되지 않음)</li></ul></li><li><strong>Design B</strong><ul><li>새로운 listener(예: <code>AccountingListener</code>)를 추가하고 <code>CustomerList</code>에 등록하기만 하면 됩니다.</li><li><code>CustomerList</code> 자체의 코드는 수정할 필요가 없습니다. (확장에 대해 open, 수정에 대해 closed)</li><li>이는 OCP를 만족시킨다고 할 수 있습니다.</li></ul></li></ul><h3 id="_2-4-design-principle-dependency-inversion-principle-dip" tabindex="-1"><a class="header-anchor" href="#_2-4-design-principle-dependency-inversion-principle-dip"><span>2.4. (Design Principle) Dependency Inversion Principle (DIP)</span></a></h3><blockquote><p>&quot;<em>의존관계 역전 원칙은 소프트웨어 모듈들을 분리하는 특정 형식을 지칭한다. 이 원칙을 따르면, 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다. 이 원칙은 다음과 같은 내용을 담고 있다.</em>&quot; [4]</p><ol><li>상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.</li><li>추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.</li></ol></blockquote><p><img src="'+a+'" alt="alt text"></p><ul><li><strong>Design A</strong><ul><li>High-level module인 <code>CustomerList</code>가 low-level moudule인 detail한 <code>MarketingLetters</code>와 <code>CustomerManagementDialog</code>에 직접 의존하고 있습니다. (detail한 것에 의존)</li></ul></li><li><strong>Design B</strong><ul><li><code>CustomerList</code>는 추상화된 <code>CustomerEventHandler</code> interface에만 의존합니다.</li><li>detail한 구현체(Listener)에 대한 의존성을 역전시킵니다. (추상적인 것에 의존)</li><li>이는 DIP를 만족시킨다고 할 수 있습니다.</li></ul></li></ul><h2 id="_3-conclusion" tabindex="-1"><a class="header-anchor" href="#_3-conclusion"><span>3. Conclusion</span></a></h2><ul><li><strong>Design B</strong>는 observer pattern을 사용하여 SRP, OCP, DIP와 같은 핵심 디자인 원칙을 준수하고 있습니다.</li><li>이를 통해 <ol><li>결합도는 낮추고 (느슨한 결합, low coupling)</li><li>응집도는 높이며</li><li>확장성과 유연성을 극대화하여</li></ol></li><li>시스템의 유지보수성을 향상시킬 수 있습니다.</li></ul><blockquote><p>이러한 이유로, <strong>Design B</strong>가 더 우수한 소프트웨어 디자인이라고 평가할 수 있습니다.</p></blockquote><h2 id="_4-works-cited" tabindex="-1"><a class="header-anchor" href="#_4-works-cited"><span>4. Works Cited</span></a></h2><p>[1] 수업 강의자료, Design Patterns (https://learning.hanyang.ac.kr/courses/181214/modules/items/8362823?return_url=/courses/181214/external_tools/140)</p><p>[2] Wikipedia, &quot;Single-Responsibility Principle&quot; (https://en.wikipedia.org/wiki/Single-responsibility_principle)</p><p>[3] Wikipedia, &quot;Open-Closed Principle&quot; (https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)</p><p>[4] Wikipedia, &quot;Dependency Inversion Principle&quot; (https://en.wikipedia.org/wiki/Dependency_inversion_principle)</p>',29)])])}const m=i(c,[["render",d]]),h=JSON.parse('{"path":"/se/wiki.html","title":"","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1764081817000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":1,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"eccceaaadcd967d6c9ccd932a5897280a0f9ecdf","time":1764081817000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Add homework documentation for Software Engineering course, including design pattern analysis and implementation details"}]},"filePathRelative":"se/wiki.md"}');export{m as comp,h as data};
