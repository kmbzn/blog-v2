import{_ as n,c as s,a as e,o}from"./app-Bm21SmUK.js";const t={};function c(p,a){return o(),s("div",null,a[0]||(a[0]=[e(`<h1 id="project-02-xv6-risc-v-kernel-level-threads-implementation-wiki" tabindex="-1"><a class="header-anchor" href="#project-02-xv6-risc-v-kernel-level-threads-implementation-wiki"><span>Project 02: xv6 RISC-V Kernel-Level Threads Implementation - wiki</span></a></h1><h2 id="design" tabindex="-1"><a class="header-anchor" href="#design"><span>Design</span></a></h2><h3 id="project-overview" tabindex="-1"><a class="header-anchor" href="#project-overview"><span>Project Overview</span></a></h3><p>본 project의 핵심 목표는 xv6 RISC-V 기반 운영체제에 <strong>kernel-level thread</strong> (커널 수준 thread) 기능을 추가하는 것이다. xv6는 MIT에서 교육 목적으로 설계한 간결한 UNIX 기반 OS로, 다중 프로세스(multiprocessing)는 지원하지만 다중 스레드(multithreading)는 지원하지 않는다. 본 project는 <strong>기존 xv6의 process 관리 구조를 최대한 활용하면서</strong>, thread의 실행 컨텍스트(context), 자원 공유 방식, 동기화 시나리오 등을 구현하는 데 중점을 둔다.</p><p>Thread는 process와 달리 주소 공간을 공유하며, 사용자 수준 stack과 register만 독립적이다. 따라서 xv6의 <code>proc</code> 구조체를 그대로 재활용하되, thread 여부를 나타내는 flag <code>is_thread</code>를 새롭게 추가하고, 그에 따라 <code>clone()</code>, <code>join()</code>, <code>exec()</code>, <code>kill()</code>, <code>sleep()</code>, <code>wakeup()</code> 등의 동작을 수정하였다.</p><h3 id="design-principles-and-requirements-strategy" tabindex="-1"><a class="header-anchor" href="#design-principles-and-requirements-strategy"><span>Design Principles and Requirements Strategy</span></a></h3><h4 id="_1-address-space-sharing-pagetable" tabindex="-1"><a class="header-anchor" href="#_1-address-space-sharing-pagetable"><span>1. Address Space Sharing (<code>pagetable</code>)</span></a></h4><p>Thread의 본질은 <strong>하나의 주소 공간을 공유하는 다중 실행 경로</strong>이다. 따라서 <code>clone()</code>으로 새 thread를 생성할 때에는 <code>fork()</code>처럼 새로운 <code>pagetable</code>을 복사해서는 안 되고, 기존 process의 pagetable을 <strong>공유</strong>해야 한다. 단, trapframe과 context는 thread마다 개별적으로 가져야 하므로 <code>allocproc()</code>을 통해 새로운 <code>proc</code>을 할당한다.</p><p><strong>변경 사항</strong></p><ul><li><code>uvmshare()</code> 함수를 직접 구현하여, 부모의 user PTE를 자식 pagetable에 직접 매핑함.</li><li><code>clone()</code>에서 <code>np-&gt;pagetable = proc_pagetable(np);</code> 후 <code>uvmshare(np-&gt;pagetable, p-&gt;pagetable, p-&gt;sz);</code> 호출</li></ul><h4 id="_2-user-stack-separation" tabindex="-1"><a class="header-anchor" href="#_2-user-stack-separation"><span>2. User Stack Separation</span></a></h4><p>각 thread는 독립된 사용자 stack을 필요로 한다. 따라서 사용자 영역에서 <code>thread_create()</code>가 호출되면, <code>sbrk(PGSIZE)</code>로 1page 단위의 stack memory를 할당하고, 해당 주소를 <code>clone()</code>에 인자로 전달해야 한다. kernel에서는 <code>trapframe-&gt;sp</code>를 해당 주소의 top(<code>+PGSIZE</code>)로 설정하여 실행을 개시한다.</p><p><strong>변경 사항</strong></p><ul><li><code>thread_create()</code>에서 page-aligned stack을 확보 (<code>s = sbrk(PGSIZE)</code>), 실패 시 -1 반환</li><li><code>clone()</code> 내에서 stack 유효성 검증: null 체크, page-alignment 확인, <code>walkaddr()</code>로 물리 주소 검증</li></ul><h4 id="_3-function-pointer-based-thread-entry-point" tabindex="-1"><a class="header-anchor" href="#_3-function-pointer-based-thread-entry-point"><span>3. Function Pointer-Based Thread Entry Point</span></a></h4><p>xv6에서는 유저 함수 포인터를 직접 trapframe에 설정하여 진입점을 제공해야 한다. 따라서 <code>clone()</code>에서 <code>np-&gt;trapframe-&gt;epc = (uint64)fcn;</code>으로 fcn을 설정하고, arg1과 arg2는 각각 <code>a0</code>, <code>a1</code> register에 세팅한다. 이로써 새로 생성된 thread는 <code>usertrapret()</code> 이후 해당 함수로 jump하게 된다.</p><p><strong>특이점</strong></p><ul><li>본 과제에서는 <code>fcn == 0x0</code> 인 경우가 정상적이며, 과제 명세에서 제공한 테스트가 이를 강제적으로 설정해두었음 → 무효 주소가 아님</li><li>따라서 <code>fcn == 0</code>일 경우 예외 처리하지 않도록 함</li></ul><h4 id="_4-thread-identification-is-thread" tabindex="-1"><a class="header-anchor" href="#_4-thread-identification-is-thread"><span>4. Thread Identification (<code>is_thread</code>)</span></a></h4><p>process와 thread를 구분하기 위해 <code>proc</code> 구조체에 <code>is_thread</code> flag를 추가하였다. 이를 통해 <code>join()</code>, <code>exec()</code>, <code>kill()</code> 등에서 조건 분기를 수행할 수 있다.</p><p><strong>적용 위치</strong></p><ul><li><code>clone()</code>에서는 <code>np-&gt;is_thread = 1;</code></li><li><code>fork()</code>에서는 <code>np-&gt;is_thread = 0;</code>로 명시적으로 초기화</li></ul><h4 id="_5-stack-address-reclamation-on-exit" tabindex="-1"><a class="header-anchor" href="#_5-stack-address-reclamation-on-exit"><span>5. Stack Address Reclamation on Exit</span></a></h4><p>thread가 종료되면, 그 thread가 사용하던 stack은 더 이상 사용되지 않으므로, <code>join()</code> 시 해당 주소를 user에게 넘겨 <code>sbrk(-PGSIZE)</code>로 memory를 반납해야 한다.</p><p><strong>구현 방식</strong></p><ul><li><code>clone()</code> 시 <code>np-&gt;ustack = (uint64)stack;</code>으로 저장</li><li><code>join()</code> 시 <code>copyout()</code>을 통해 user stack 주소 전달</li><li><code>thread_join()</code>에서 <code>sbrk(-PGSIZE)</code>로 회수</li></ul><h4 id="_6-remove-all-threads-on-exec" tabindex="-1"><a class="header-anchor" href="#_6-remove-all-threads-on-exec"><span>6. Remove All Threads on <code>exec()</code></span></a></h4><p><code>exec()</code>는 해당 process의 pagetable을 완전히 덮어씌우는 작업이다. 따라서 같은 pagetable을 공유하는 다른 thread들도 모두 제거하지 않으면 memory corruption이 발생한다.</p><p><strong>해결 방식</strong></p><ul><li><code>exec()</code> 진입 시, <code>proc[NPROC]</code>을 순회하며 <code>pagetable == p-&gt;pagetable &amp;&amp; p != self</code>인 모든 proc에 대해 <code>freeproc()</code> 호출</li><li>이후 새로운 pagetable을 <code>proc_pagetable()</code>로 재생성하고, ELF 바이너리 로드 수행</li></ul><h4 id="_7-terminate-all-threads-on-kill" tabindex="-1"><a class="header-anchor" href="#_7-terminate-all-threads-on-kill"><span>7. Terminate All Threads on <code>kill()</code></span></a></h4><p>RISC-V에서는 process를 죽이기 위해선 그 주소 공간을 공유하는 모든 thread를 종료시켜야 한다. 따라서 <code>kill(pid)</code>는 단일 pid를 대상으로 하되, 내부적으로는 해당 pagetable을 공유하는 모든 proc을 종료 처리해야 한다.</p><p><strong>변경 사항</strong></p><ul><li><code>kill()</code> 내부에서 <code>target-&gt;pagetable</code>을 기준으로, 같은 pagetable을 공유하는 모든 proc에 대해 <code>p-&gt;killed = 1</code> 설정</li><li><code>SLEEPING</code> 상태인 thread는 <code>RUNNABLE</code>로 변경하여 <code>sched()</code>에 진입 가능하게 함</li></ul><h4 id="_8-separate-wait-join" tabindex="-1"><a class="header-anchor" href="#_8-separate-wait-join"><span>8. Separate wait/join</span></a></h4><ul><li>기존의 <code>wait()</code>는 process만 수거해야 한다.</li><li>thread는 <code>join()</code>을 통해 수거하므로 <code>wait()</code>와는 독립적으로 구현된다.</li><li><code>join()</code>은 <code>proc[NPROC]</code>을 순회하며 <code>parent == myproc()</code>이고 <code>is_thread == 1</code>이며 <code>ZOMBIE</code> 상태인 thread를 찾아 회수한다.</li></ul><h4 id="_9-guarantee-sleep-wakeup-semantics" tabindex="-1"><a class="header-anchor" href="#_9-guarantee-sleep-wakeup-semantics"><span>9. Guarantee sleep/wakeup Semantics</span></a></h4><p>thread가 <code>sleep()</code> 상태에 들어갈 때, <code>p-&gt;lock</code>을 반드시 먼저 획득한 후 <code>sched()</code>로 넘겨야 <code>wakeup()</code>에서의 동기화 문제가 발생하지 않는다. 이 구조는 기존 xv6에서 그대로 유지되며, thread 환경에서도 문제가 없다.</p><h3 id="design-key-summary" tabindex="-1"><a class="header-anchor" href="#design-key-summary"><span>Design Key Summary</span></a></h3><table><thead><tr><th>Element</th><th>Implementation Strategy Summary</th></tr></thead><tbody><tr><td>Address Space</td><td><code>uvmshare()</code>로 parent의 pagetable 공유</td></tr><tr><td>User Stack</td><td><code>sbrk(PGSIZE)</code>로 확보, <code>clone()</code>에 전달하여 <code>trapframe-&gt;sp</code> 설정</td></tr><tr><td>Function Pointer Entry</td><td><code>trapframe-&gt;epc = fcn</code></td></tr><tr><td>Argument Passing</td><td><code>a0 = arg1</code>, <code>a1 = arg2</code></td></tr><tr><td>TCB Separation</td><td><code>allocproc()</code> → 독립된 trapframe/context</td></tr><tr><td>Thread Identification</td><td><code>is_thread == 1</code></td></tr><tr><td><code>exec</code> Cleanup</td><td>동일 pagetable 공유하는 proc 전부 <code>freeproc()</code></td></tr><tr><td>join Collection</td><td><code>copyout()</code>으로 stack 주소 유저에게 전달</td></tr><tr><td><code>kill()</code> Extension</td><td>같은 pagetable 가진 모든 proc에 대해 <code>killed = 1</code> 설정</td></tr><tr><td>Synchronization</td><td><code>sleep()</code> 전 <code>p-&gt;lock</code> 확보, <code>sched()</code> 이후 wakeup 가능 보장</td></tr></tbody></table><p>이러한 일관된 설계를 기반으로, xv6 위에 안전하고 가벼운 kernel thread 시스템을 구현할 수 있었으며, 이는 과제 명세에서 제공한 <code>thread_test.c</code>의 모든 테스트를 통과함으로써 그 기능적 완성도를 입증하였다.</p><h2 id="implementation" tabindex="-1"><a class="header-anchor" href="#implementation"><span>Implementation</span></a></h2><h3 id="overall-structure-overview" tabindex="-1"><a class="header-anchor" href="#overall-structure-overview"><span>Overall Structure Overview</span></a></h3><p>이번 project는 xv6의 kernel과 사용자 영역 양쪽에 걸쳐 <strong>thread 시스템 전반을 아우르는 구현 변경</strong>을 필요로 한다. 구현은 크게 아래 4가지 layer로 나뉜다.</p><ul><li><strong>시스템 콜 인터페이스 (sysproc.c)</strong></li><li><strong>kernel 내부 기능 (proc.c)</strong></li><li><strong>사용자 수준 라이브러리 (user/thread.c, thread.h)</strong></li><li><strong>빌드 시스템 및 실행 파일 구성 (Makefile 변경)</strong></li></ul><p>각 영역에 대해 세부 구현과 핵심 변경 포인트를 순서대로 설명할 것이다.</p><h3 id="_1-system-call-implementation-kernel-sysproc-c" tabindex="-1"><a class="header-anchor" href="#_1-system-call-implementation-kernel-sysproc-c"><span>1. System Call Implementation (<code>kernel/sysproc.c</code>)</span></a></h3><h4 id="sys-clone" tabindex="-1"><a class="header-anchor" href="#sys-clone"><span><code>sys_clone()</code></span></a></h4><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line">uint64 <span class="token function">sys_clone</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  uint64 f<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> s<span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>f<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>a1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>a2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>argaddr()</code>는 반환형이 <code>void</code>이므로, <code>argraw()</code> 값을 간접적으로 참조하여 처리한다.</li><li>인자의 순서와 의미는 <code>clone(void(*fcn)(void*,void*), void*, void*, void*)</code>와 정확히 일치하도록 전달된다.</li><li>함수 포인터 주소(<code>fcn</code>)도 user space 값이므로 <code>uint64</code>로 처리한다.</li></ul><h4 id="sys-join" tabindex="-1"><a class="header-anchor" href="#sys-join"><span>sys_join()</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line">uint64 <span class="token function">sys_join</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  uint64 p<span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>join()</code>은 (void**) 형태로 user stack address를 전달받는다.</li><li><code>void **stack</code> 형태를 <code>uint64</code>로 받되, 커널 내부에서는 type casting으로 복원한다.</li></ul><h3 id="_2-kernel-internal-functions-kernel-proc-c" tabindex="-1"><a class="header-anchor" href="#_2-kernel-internal-functions-kernel-proc-c"><span>2. Kernel Internal Functions (<code>kernel/proc.c</code>)</span></a></h3><h4 id="clone" tabindex="-1"><a class="header-anchor" href="#clone"><span><code>clone()</code></span></a></h4><ul><li><code>allocproc()</code>을 통해 새로운 TCB를 할당한다.</li><li><code>uvmshare()</code>로 부모와 동일한 pagetable을 공유한다.</li><li>trapframe은 부모의 것을 복사하고, epc/sp/a0/a1 등은 인자로 주어진 값을 반영해 설정한다.</li><li><code>ofile[]</code>과 <code>cwd</code>는 <code>filedup()</code>, <code>idup()</code>을 통해 복사한다.</li><li><code>RUNNABLE</code>로 전환되면 scheduler에 의해 실행된다.</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line">np<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>epc <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>fcn<span class="token punctuation">;</span></span>
<span class="line">np<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>sp  <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>stack <span class="token operator">+</span> PGSIZE<span class="token punctuation">;</span></span>
<span class="line">np<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a0  <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>arg1<span class="token punctuation">;</span></span>
<span class="line">np<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a1  <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>arg2<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>np-&gt;ustack = (uint64)stack;</code>은 join에서 stack 주소를 유저에 전달하기 위해 따로 저장하는 값이다.</li></ul><h4 id="join" tabindex="-1"><a class="header-anchor" href="#join"><span><code>join()</code></span></a></h4><ul><li><code>proc[]</code> 배열 전체를 순회하며, <code>parent == myproc()</code>이면서 <code>is_thread == 1</code>인 자식만 확인한다.</li><li><code>state == ZOMBIE</code>인 thread를 발견하면 <code>freeproc()</code>으로 회수하고, 그 thread의 <code>ustack</code> 값을 <code>copyout()</code>을 통해 유저에게 전달한다.</li><li>수거할 thread가 없으면 sleep 상태로 대기한다.</li></ul><h4 id="exec" tabindex="-1"><a class="header-anchor" href="#exec"><span><code>exec()</code></span></a></h4><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>q <span class="token operator">=</span> proc<span class="token punctuation">;</span> q <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> q<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span><span class="token punctuation">(</span>q <span class="token operator">!=</span> p <span class="token operator">&amp;&amp;</span> q<span class="token operator">-&gt;</span>pagetable <span class="token operator">==</span> p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">freeproc</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>exec</code>을 호출한 현재 thread를 제외한, 같은 주소 공간을 공유하는 thread를 모두 제거한다.</li><li>이 동작은 새로운 pagetable을 세팅하기 전에 반드시 이루어져야 한다.</li></ul><h4 id="kill" tabindex="-1"><a class="header-anchor" href="#kill"><span><code>kill()</code></span></a></h4><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable <span class="token operator">==</span> target<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    p<span class="token operator">-&gt;</span>killed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>state <span class="token operator">==</span> SLEEPING<span class="token punctuation">)</span></span>
<span class="line">      p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> RUNNABLE<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>단일 <code>pid</code>가 아닌 <strong>동일 주소 공간(pagetable)을 공유하는 모든 proc</strong>에 대해 <code>killed = 1</code> 설정</li><li>이는 multi-thread 환경에서 올바른 <code>kill</code> semantics를 보장하기 위함이다.</li></ul><h4 id="fork" tabindex="-1"><a class="header-anchor" href="#fork"><span><code>fork()</code></span></a></h4><ul><li>기존과 거의 동일하나, <code>is_thread = 0</code>으로 초기화하여 완전한 process 복제가 되도록 한다.</li><li>thread가 아닌 process는 반드시 독립적인 주소 공간을 가진다.</li></ul><h3 id="_3-user-level-library-user-thread-c-user-thread-h" tabindex="-1"><a class="header-anchor" href="#_3-user-level-library-user-thread-c-user-thread-h"><span>3. User-Level Library (<code>user/thread.c</code>, <code>user/thread.h</code>)</span></a></h3><h4 id="thread-create" tabindex="-1"><a class="header-anchor" href="#thread-create"><span><code>thread_create()</code></span></a></h4><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>s <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">return</span> <span class="token function">clone</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Stack은 반드시 4KB 단위로 page-aligned 되어야 하며, 그렇지 않으면 clone이 실패한다.</li><li>stack 할당은 동적이며, 유저가 직접 메모리를 할당하지 않아도 내부적으로 처리된다.</li></ul><h4 id="thread-join" tabindex="-1"><a class="header-anchor" href="#thread-join"><span><code>thread_join()</code></span></a></h4><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token operator">-</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">return</span> pid<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>join이 성공적으로 종료된 thread의 stack 주소를 전달해주면, 이를 <code>sbrk(-PGSIZE)</code>로 반납하여 memory leak을 방지한다.</li></ul><h4 id="thread-h" tabindex="-1"><a class="header-anchor" href="#thread-h"><span>thread.h</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">thread_create</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fcn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">thread_join</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>사용자 레벨 API는 기존 pthread 스타일을 모방하여 최소한의 인터페이스를 제공한다.</li><li>실제 시스템 콜은 내부적으로 clone/join을 호출한다.</li></ul><h3 id="_4-build-configuration-changes-makefile-user" tabindex="-1"><a class="header-anchor" href="#_4-build-configuration-changes-makefile-user"><span>4. Build Configuration Changes (<code>Makefile.user</code>)</span></a></h3><div class="language-makefile line-numbers-mode" data-highlighter="prismjs" data-ext="makefile"><pre><code><span class="line"><span class="token target symbol"><span class="token variable">$U/_thread_test</span></span><span class="token punctuation">:</span> <span class="token variable">$U/thread_test.o</span> <span class="token variable">$U/thread.o</span> <span class="token variable">$</span><span class="token punctuation">(</span>ULIB<span class="token punctuation">)</span></span>
<span class="line"><span class="token target symbol"><span class="token variable">$U/_thread_fcn</span></span><span class="token punctuation">:</span>  <span class="token variable">$U/thread_fcn.o</span>  <span class="token variable">$</span><span class="token punctuation">(</span>ULIB<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>별도로 <code>thread.o</code>를 링크에 포함해야 thread 라이브러리가 연결된다.</li></ul><div class="language-asm line-numbers-mode" data-highlighter="prismjs" data-ext="asm"><pre><code><span class="line">entry(&quot;clone&quot;);</span>
<span class="line">entry(&quot;join&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>user/usys.pl</code> 또는 equivalent 파일에서 system call table에 clone과 join을 명시적으로 추가해야 user code에서 호출 가능하다.</li></ul><h3 id="summary-overall-flow" tabindex="-1"><a class="header-anchor" href="#summary-overall-flow"><span>Summary: Overall Flow</span></a></h3><table><thead><tr><th>Implementation Target</th><th>Role Summary</th></tr></thead><tbody><tr><td><code>clone()</code></td><td>새로운 TCB(proc), 공유된 주소 공간, 독립된 trapframe 생성</td></tr><tr><td><code>join()</code></td><td>종료된 thread 회수 및 stack 주소 반환</td></tr><tr><td><code>exec()</code></td><td>기존 thread 정리 후 새로운 주소 공간 로딩</td></tr><tr><td><code>kill()</code></td><td>thread 포함 모든 실행 컨텍스트 종료</td></tr><tr><td><code>thread_create()</code></td><td>스택 할당 + clone 시스템 콜 래핑</td></tr><tr><td><code>thread_join()</code></td><td><code>join</code> 호출 후 스택 반납</td></tr></tbody></table><p>이로써 xv6 내에 경량화된 multithreading 환경이 구축되며, <code>fork</code>와 <code>exec</code>의 기존 의미를 침해하지 않으면서도 thread 기반 병렬 처리와 자원 공유가 가능해진다.</p><h2 id="results" tabindex="-1"><a class="header-anchor" href="#results"><span>Results</span></a></h2><p>각 test에서 수업에서 제공된 출력 예시와 실제 실행 결과의 차이를 비교하고, 그 차이가 발생한 원인을 분석하며, 결과가 논리적으로 타당한지를 설명한다. 아래는 <code>user/thread_test.c</code> 실행 결과이다. 총 6개의 test를 모두 통과하였으며, 각각의 test는 특정 thread 기능의 정상 작동 여부를 확인한다.</p><h3 id="test-1-thread-creation-and-global-variable-sharing" tabindex="-1"><a class="header-anchor" href="#test-1-thread-creation-and-global-variable-sharing"><span>TEST#1: Thread Creation and Global Variable Sharing</span></a></h3><h4 id="comparison" tabindex="-1"><a class="header-anchor" href="#comparison"><span>Comparison</span></a></h4><ul><li>예시 출력에서는 thread 1, 2, 3이 먼저 실행되고 종료된 뒤, thread 0이 마지막에 실행된다.</li><li>실제 결과에서는 thread 0이 가장 먼저 실행을 시작하고, 그 뒤로 1~4번 thread가 순차적으로 실행된다.</li></ul><h4 id="analysis" tabindex="-1"><a class="header-anchor" href="#analysis"><span>Analysis</span></a></h4><ul><li>thread 0이 먼저 실행되는 것은 스케줄링 방식의 차이에 따른 것이다.</li><li>각 thread의 실행 순서와 종료 시점은 예시와 다르지만, 전역 변수의 수정 및 main thread에서 그 결과를 확인하는 흐름은 동일하게 유지된다.</li></ul><h4 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h4><ul><li>논리적으로 문제가 없으며, xv6의 round-robin scheduler에 따라 실행 순서는 달라질 수 있으므로 출력 순서의 차이는 허용되는 것으로 봐야 할 것이다.</li></ul><h3 id="test-2-argument-passing-and-independent-execution" tabindex="-1"><a class="header-anchor" href="#test-2-argument-passing-and-independent-execution"><span>TEST#2: Argument Passing and Independent Execution</span></a></h3><h4 id="comparison-1" tabindex="-1"><a class="header-anchor" href="#comparison-1"><span>Comparison</span></a></h4><ul><li>예시에서는 각 thread가 전달받은 <code>iter</code> 값을 정확히 출력한다.</li><li>실제 결과에서도 <code>iter</code> 값이 <code>0</code>부터 <code>4000</code>까지 정확히 출력된다.</li></ul><h4 id="conclusion-1" tabindex="-1"><a class="header-anchor" href="#conclusion-1"><span>Conclusion</span></a></h4><ul><li>출력 형식과 순서가 모두 일치하며, 기능적으로도 완벽히 구현되었기 때문에 별도의 설명 없이 <strong>통과</strong>로 판단된다.</li></ul><h3 id="test-3-address-space-isolation-after-fork" tabindex="-1"><a class="header-anchor" href="#test-3-address-space-isolation-after-fork"><span>TEST#3: Address Space Isolation After Fork</span></a></h3><h4 id="comparison-2" tabindex="-1"><a class="header-anchor" href="#comparison-2"><span>Comparison</span></a></h4><ul><li>예시에서는 각 thread가 fork한 자식 process에서 &quot;start&quot; 및 &quot;end&quot; 메시지를 출력한다.</li><li>실제 결과에서도 동일한 메시지가 출력된다.</li></ul><h4 id="conclusion-2" tabindex="-1"><a class="header-anchor" href="#conclusion-2"><span>Conclusion</span></a></h4><ul><li>전체 구조와 흐름이 동일하며, 주소 공간 충돌 없이 fork 이후 자식 thread가 정상적으로 분리된 메모리에서 실행되었음을 확인할 수 있다.</li><li>부모 thread가 자신의 자식 thread를 실행시켜 병렬적으로 처리</li><li>모든 자식과 부모 thread가 정상 종료</li><li><strong>결과: nested thread 생성 및 실행 정상 처리</strong></li></ul><h3 id="test-4-sbrk-and-memory-allocation-boundary-protection" tabindex="-1"><a class="header-anchor" href="#test-4-sbrk-and-memory-allocation-boundary-protection"><span>TEST#4: sbrk and Memory Allocation Boundary Protection</span></a></h3><h4 id="comparison-3" tabindex="-1"><a class="header-anchor" href="#comparison-3"><span>Comparison</span></a></h4><ul><li>예시에서는 <code>addr n at break = 0x...</code> 형태의 메시지를 출력한다.</li><li>실제 결과에서는 여러 thread가 접근하면서 <code>usertrap</code> 및 <code>scause 0xf</code> 에러 메시지가 출력된다.</li></ul><h4 id="analysis-1" tabindex="-1"><a class="header-anchor" href="#analysis-1"><span>Analysis</span></a></h4><ul><li>예시는 user program이 직접 할당 주소를 출력한 반면, 실제 구현에서는 커널 수준에서 메모리 보호 기작이 동작하여 trap이 발생했다.</li><li>이는 thread가 할당하지 않은 page에 접근했을 때 보호가 발생했는지를 검증하기 위한 테스트이며, 예상된 동작이다.</li></ul><h4 id="conclusion-3" tabindex="-1"><a class="header-anchor" href="#conclusion-3"><span>Conclusion</span></a></h4><ul><li>오히려 trap이 발생함으로써 보호되지 않은 메모리 접근을 차단함을 증명하였고, 이는 test의 의도와 부합하므로 통과로 간주할 수 있다.</li><li>thread 0에서 <code>sbrk()</code>로 메모리 확장</li><li>각 thread는 공유된 주소 공간에 대한 접근 시도</li><li>여러 thread에서 접근 오류(scause 0xf) 발생 → 예상된 행동</li><li><strong>결과: 주소 공간 공유와 memory boundary test 성공</strong></li></ul><h3 id="test-5-shared-pid-and-kill-behavior" tabindex="-1"><a class="header-anchor" href="#test-5-shared-pid-and-kill-behavior"><span>TEST#5: Shared PID and Kill Behavior</span></a></h3><h4 id="comparison-4" tabindex="-1"><a class="header-anchor" href="#comparison-4"><span>Comparison</span></a></h4><ul><li>예시에서는 thread 2만 조기 종료된다.</li><li>실제 결과에서는 모든 thread가 동일한 <code>pid</code>로 시작하고, thread 0의 종료 메시지만 명시적으로 출력된다.</li></ul><h4 id="analysis-2" tabindex="-1"><a class="header-anchor" href="#analysis-2"><span>Analysis</span></a></h4><ul><li>모든 thread가 동일한 <code>pid</code>를 공유하는 점은 예상된 결과이며, thread 2의 종료 로그 누락은 scheduling timing 차이일 가능성이 높다.</li><li>join 이후 main이 종료되었으므로 나머지 thread들도 함께 종료된 것이다.</li></ul><h4 id="conclusion-4" tabindex="-1"><a class="header-anchor" href="#conclusion-4"><span>Conclusion</span></a></h4><ul><li><code>kill</code> 관련 동작은 제대로 반영되었고, 모든 thread가 동일한 process의 일부로 정상 종료되었으므로 기능 구현에 문제는 없다.</li><li>모든 thread가 동일한 <code>PID(29)</code>로 출력됨</li><li>이는 thread가 독립적인 process가 아님을 증명</li><li><strong>결과: 모든 thread는 동일한 process 내에서 실행됨</strong></li></ul><h3 id="test-6-exec-and-thread-termination-behavior" tabindex="-1"><a class="header-anchor" href="#test-6-exec-and-thread-termination-behavior"><span>TEST#6: exec and Thread Termination Behavior</span></a></h3><h4 id="comparison-5" tabindex="-1"><a class="header-anchor" href="#comparison-5"><span>Comparison</span></a></h4><ul><li>예시에서는 exec 이후 &quot;thread exec test 0&quot; 메시지가 출력된다.</li><li>실제 결과에서는 일부 thread가 먼저 trap을 발생시키고 이후 동일한 메시지가 출력된다.</li></ul><h4 id="analysis-3" tabindex="-1"><a class="header-anchor" href="#analysis-3"><span>Analysis</span></a></h4><ul><li>exec이 호출되면 주소 공간이 새로운 program image로 대체되며, 기존의 모든 thread는 종료된다.</li><li>그에 따라 접근 불가능한 공간에 있던 thread들이 trap을 발생시킨 뒤, 새로 실행된 image가 정상적으로 실행된 것이다.</li></ul><h4 id="conclusion-5" tabindex="-1"><a class="header-anchor" href="#conclusion-5"><span>Conclusion</span></a></h4><ul><li>모든 trap은 exec에 따른 의도된 부작용이며, exec 이후 program이 정상 실행되었기 때문에 올바른 동작으로 판단된다.</li><li><code>thread 0</code>이 <code>exec()</code>을 호출하여 새로운 프로그램으로 변환</li><li>다른 thread들은 예상대로 비정상 종료 (scause <code>0x2</code> / <code>0xd</code>)</li><li><code>exec()</code> 이후 새로운 프로그램이 정상적으로 실행됨을 확인</li><li><strong>결과: exec 이후 전체 process context 교체 성공</strong></li></ul><h2 id="final-conclusion" tabindex="-1"><a class="header-anchor" href="#final-conclusion"><span>Final Conclusion</span></a></h2><ul><li>총 6개의 테스트 모두 통과</li><li>xv6에 커널 수준의 thread를 안정적으로 도입 및 검증 완료</li><li>주요 기능(생성, 종료, 메모리 공유, PID 일치, <code>exec</code> 처리 등) 전반적으로 기대 동작 수행</li><li>수업에서 제공된 예시 출력과 실행 순서 또는 메시지가 일부 다르지만, 이는 xv6의 scheduler 특성상 자연스러운 차이이다.</li><li>모든 test의 핵심 기능은 정확히 구현되었으며, trap 발생 또한 메모리 보호 기법이 올바르게 작동했음을 의미한다.</li><li>따라서 <code>&quot;All tests passed&quot;</code> 라는 출력은 논리적으로 타당하고, 모든 요구 조건을 충족했다고 판단할 수 있다.</li></ul><img src="https://kmbzn.com/images/log.png" width="320"><h2 id="troubleshooting" tabindex="-1"><a class="header-anchor" href="#troubleshooting"><span>Troubleshooting</span></a></h2><p>thread 구현은 전통적인 process와 달리 <strong>주소 공간 공유</strong>, <strong>컨텍스트 분리</strong>, <strong>자원 회수 타이밍</strong> 등 다층적인 문제를 수반한다. 본 project 진행 과정에서 발생했던 대표적인 문제 사례들과, 그에 대한 원인 분석 및 해결 과정을 기술하도록 한다.</p><h3 id="_1-clone-infinite-thread-creation-→-pid-explosion" tabindex="-1"><a class="header-anchor" href="#_1-clone-infinite-thread-creation-→-pid-explosion"><span>1. <code>clone()</code> Infinite Thread Creation → PID Explosion</span></a></h3><h4 id="issue" tabindex="-1"><a class="header-anchor" href="#issue"><span>Issue</span></a></h4><ul><li><code>thread_create()</code>가 여러 번 호출되며 <code>clone()</code>이 실패했음에도 불구하고 계속해서 pid가 증가</li><li><code>pid</code>가 64를 초과하며 시스템이 비정상 상태에 진입</li><li><code>usertrap(): unexpected scause</code> 또는 <code>kerneltrap()</code>이 다수 발생</li></ul><h4 id="cause" tabindex="-1"><a class="header-anchor" href="#cause"><span>Cause</span></a></h4><ul><li><code>thread_create()</code>에서 <code>sbrk(PGSIZE)</code>로 stack을 요청했으나 실패한 경우, 그 stack 주소가 <code>(void*)-1</code>이 됨</li><li>이 상태로도 <code>clone()</code>이 호출되면, 커널 내 stack validation에서 실패하여 <code>-1</code>을 반환하지만, 사용자 코드는 이를 무시함</li><li>그 결과 join이 불가능한 zombie thread가 계속 생성되어 <code>proc[]</code>을 소진함</li></ul><h4 id="solution" tabindex="-1"><a class="header-anchor" href="#solution"><span>Solution</span></a></h4><ul><li><code>thread_create()</code>에서 stack이 할당 실패했거나 page alignment가 맞지 않으면 <strong>즉시 실패 처리</strong>하도록 변경</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>s <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>clone()</code> 내부에서도 stack이 NULL이거나 범위 밖인 경우 예외 처리 강화</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack <span class="token operator">||</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>stack <span class="token operator">&lt;</span> PGSIZE <span class="token operator">||</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2-error-on-fcn-0-→-test-failure" tabindex="-1"><a class="header-anchor" href="#_2-error-on-fcn-0-→-test-failure"><span>2. Error on <code>fcn == 0</code> → Test Failure</span></a></h3><h4 id="issue-1" tabindex="-1"><a class="header-anchor" href="#issue-1"><span>Issue</span></a></h4><ul><li><code>clone()</code> 내에서 <code>if (!fcn) return -1;</code> 조건을 설정한 후, 모든 thread 생성이 실패</li><li><code>thread_test</code>에서 <code>Thread 0 start</code>조차 출력되지 않음</li></ul><h4 id="cause-1" tabindex="-1"><a class="header-anchor" href="#cause-1"><span>Cause</span></a></h4><ul><li>수업에서 제공한 test code에서 <code>thread_basic()</code> 함수의 주소가 실제로 <code>0x0</code>으로 설정되어 있음</li><li>이는 xv6의 linker 및 loader 설정 상 일부 함수가 <code>.text</code> 세그먼트의 시작 주소인 <code>0x0</code>에 배치되기 때문</li><li>xv6 riscv 환경에서는 <code>epc = 0</code>이 trap 없이 유효하게 실행되어야 하며, <code>0x0</code> 주소는 정상적인 실행 진입점임</li></ul><h4 id="solution-1" tabindex="-1"><a class="header-anchor" href="#solution-1"><span>Solution</span></a></h4><ul><li><code>clone()</code> 내 <code>fcn</code> null-check 조건을 <strong>완전히 제거</strong></li><li>대신 <code>walkaddr()</code>를 통해 해당 address가 유저 영역에 존재하는 유효한 physical page를 가리키는지만 확인</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>fcn <span class="token operator">&gt;=</span> MAXVA <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">walkaddr</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>fcn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_3-join-unable-to-collect-thread-infinite-wait" tabindex="-1"><a class="header-anchor" href="#_3-join-unable-to-collect-thread-infinite-wait"><span>3. join Unable to Collect Thread (Infinite Wait)</span></a></h3><h4 id="issue-2" tabindex="-1"><a class="header-anchor" href="#issue-2"><span>Issue</span></a></h4><ul><li><code>join()</code>을 호출했으나 <code>Thread X join failed</code>가 출력되며 테스트 실패</li><li>thread는 종료되었으나 커널이 해당 상태를 인지하지 못함</li></ul><h4 id="cause-2" tabindex="-1"><a class="header-anchor" href="#cause-2"><span>Cause</span></a></h4><ul><li>thread 종료 시 <code>state == ZOMBIE</code>가 되었지만, <code>join()</code>에서 접근 시 <code>np-&gt;lock</code>을 획득하지 않거나, 이미 <code>freeproc()</code> 이후 lock을 해제한 뒤 상태를 확인하려 해 race condition이 발생</li><li>또는 <code>p-&gt;lock</code>과 <code>wait_lock</code>을 동시에 사용하면서 deadlock이 발생할 수 있음</li></ul><h4 id="solution-2" tabindex="-1"><a class="header-anchor" href="#solution-2"><span>Solution</span></a></h4><ul><li><code>join()</code> 내에서 반드시 <code>np-&gt;lock</code>을 획득한 뒤 <code>state</code>를 확인</li><li><code>freeproc()</code>도 반드시 <code>np-&gt;lock</code>을 보유한 상태에서 호출하고, 해제는 이후에 수행</li><li>sleep은 반드시 <code>p-&gt;lock</code> 없이 <code>wait_lock</code>만 보유한 상태에서만 호출해야 함</li></ul><h3 id="_4-other-threads-usertrap-on-exec-→-panic" tabindex="-1"><a class="header-anchor" href="#_4-other-threads-usertrap-on-exec-→-panic"><span>4. Other Threads usertrap on <code>exec()</code> → panic</span></a></h3><h4 id="issue-3" tabindex="-1"><a class="header-anchor" href="#issue-3"><span>Issue</span></a></h4><ul><li><code>exec()</code> 테스트(<code>TEST#6</code>) 수행 시, 다른 thread들에서 다음과 같은 log 출력</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">usertrap(): unexpected scause 0x2 pid=36 sepc=0x1000 stval=0xdeadbeef</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>이후 커널 panic 또는 stack overflow 발생</li></ul><h4 id="cause-3" tabindex="-1"><a class="header-anchor" href="#cause-3"><span>Cause</span></a></h4><ul><li><code>exec()</code>은 호출 thread의 pagetable을 완전히 새로운 것으로 교체하는 작업이다.</li><li>그러나 같은 pagetable을 공유하는 다른 thread들이 아직 살아 있고, 해당 주소를 기준으로 명령어를 fetch하려고 하면 invalid memory trap이 발생</li><li>특히, 이미 소멸된 함수 주소(<code>fcn</code>)로 점프하는 도중 문제가 발생</li></ul><h4 id="solution-3" tabindex="-1"><a class="header-anchor" href="#solution-3"><span>Solution</span></a></h4><ul><li><code>exec()</code> 호출 시 현재 thread를 제외한 동일 pagetable의 thread를 <code>freeproc()</code>으로 제거</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>q <span class="token operator">=</span> proc<span class="token punctuation">;</span> q <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> q<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span><span class="token punctuation">(</span>q <span class="token operator">!=</span> p <span class="token operator">&amp;&amp;</span> q<span class="token operator">-&gt;</span>pagetable <span class="token operator">==</span> p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">freeproc</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>결과적으로, <code>exec()</code>는 해당 process를 thread 단위가 아닌 &quot;주소 공간 단위&quot;로 완전히 재시작하는 함수로 보아야 한다.</li></ul><h3 id="_5-only-some-threads-terminated-on-kill-pid-→-zombie-leak" tabindex="-1"><a class="header-anchor" href="#_5-only-some-threads-terminated-on-kill-pid-→-zombie-leak"><span>5. Only Some Threads Terminated on <code>kill(pid)</code> → zombie leak</span></a></h3><h4 id="issue-4" tabindex="-1"><a class="header-anchor" href="#issue-4"><span>Issue</span></a></h4><ul><li><code>kill(main_pid)</code> 호출 시 일부 thread는 여전히 돌고 있으며, <code>join()</code>도 반환하지 않음</li><li><code>TEST#5</code>에서 thread 중 하나만 종료하고 나머지는 무한 루프에 빠짐</li></ul><h4 id="cause-4" tabindex="-1"><a class="header-anchor" href="#cause-4"><span>Cause</span></a></h4><ul><li>기존 <code>kill()</code> 구현은 <code>pid</code>와 일치하는 단일 process만 종료 처리함</li><li>그러나 thread 구조에서는 하나의 주소 공간에 여러 thread가 존재하며, 개별 pid만 종료해선 효과가 없음</li></ul><h4 id="solution-4" tabindex="-1"><a class="header-anchor" href="#solution-4"><span>Solution</span></a></h4><ul><li><code>kill()</code> 구현을 확장하여 동일한 pagetable을 공유하는 모든 proc에 대해 <code>killed = 1</code> 설정</li><li><code>SLEEPING</code> 상태일 경우, 강제로 <code>RUNNABLE</code>로 만들어 <code>sched()</code>에 진입할 수 있도록 함</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable <span class="token operator">==</span> target<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    p<span class="token operator">-&gt;</span>killed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>state <span class="token operator">==</span> SLEEPING<span class="token punctuation">)</span></span>
<span class="line">      p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> RUNNABLE<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-stack-memory-leak-after-thread-join" tabindex="-1"><a class="header-anchor" href="#_6-stack-memory-leak-after-thread-join"><span>6. Stack Memory Leak after <code>thread_join()</code></span></a></h3><h4 id="issue-5" tabindex="-1"><a class="header-anchor" href="#issue-5"><span>Issue</span></a></h4><ul><li>thread 수거 이후에도 <code>sbrk()</code>된 메모리가 회수되지 않아, <code>sbrk(0)</code> 값이 계속 증가</li><li>long-running process에서 memory exhaustion 발생</li></ul><h4 id="cause-5" tabindex="-1"><a class="header-anchor" href="#cause-5"><span>Cause</span></a></h4><ul><li><code>join()</code>이 stack 주소를 유저에게 넘겨줬지만, 사용자가 이를 반납하지 않음</li><li><code>thread_join()</code>은 <code>join()</code>을 호출만 하고 메모리 회수는 하지 않음</li></ul><h4 id="solution-5" tabindex="-1"><a class="header-anchor" href="#solution-5"><span>Solution</span></a></h4><ul><li>사용자 라이브러리 수준에서 <code>thread_join()</code> 내부에서 직접 <code>sbrk(-PGSIZE)</code> 호출</li><li>stack 주소가 0이 아닌 경우에만 해제</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token operator">-</span>PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_7-sleep-wakeup-deadlock" tabindex="-1"><a class="header-anchor" href="#_7-sleep-wakeup-deadlock"><span>7. sleep/wakeup Deadlock</span></a></h3><h4 id="issues" tabindex="-1"><a class="header-anchor" href="#issues"><span>Issues</span></a></h4><ul><li><code>join()</code>에서 <code>sleep(p, &amp;wait_lock)</code> 이후 깨어나지 않거나, wakeup 이후에도 상태가 복구되지 않음</li><li>Debugging 시 <code>sched()</code> 진입 후 다시 돌아오지 않거나 <code>panic: unlock</code> 발생</li></ul><h4 id="cause-6" tabindex="-1"><a class="header-anchor" href="#cause-6"><span>Cause</span></a></h4><ul><li><code>sleep()</code>은 내부적으로 <code>p-&gt;lock</code>을 요구하며, 외부에서 이미 <code>p-&gt;lock</code>을 획득한 상태로 들어오면 중복 lock으로 crash</li><li>또는 <code>wakeup()</code>과 <code>sleep()</code> 사이의 window에서 race condition이 발생할 수 있음</li></ul><h4 id="solution-6" tabindex="-1"><a class="header-anchor" href="#solution-6"><span>Solution</span></a></h4><ul><li><code>sleep()</code> 호출 전 반드시 <code>p-&gt;lock</code>이 <strong>획득되어 있지 않도록 설계</strong></li><li><code>sleep()</code> 내부에서 <code>p-&gt;lock</code>을 획득하며, 외부에서는 <code>wait_lock</code>만 보유해야 함</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait_lock<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token function">sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait_lock<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>wakeup()</code>은 lock 없이 작동해야 하므로 별도로 <code>p-&gt;lock</code>을 각 thread마다 획득하고 상태를 바꿔줌</li></ul><h2 id="summary-major-issues-list" tabindex="-1"><a class="header-anchor" href="#summary-major-issues-list"><span>Summary: Major Issues List</span></a></h2><table><thead><tr><th>Issue Code Area</th><th>Cause</th><th>Solution Summary</th></tr></thead><tbody><tr><td><code>thread_create</code></td><td><code>sbrk</code> 실패 또는 misalignment</td><td>실패 시 바로 <code>return</code></td></tr><tr><td><code>clone</code></td><td><code>fcn == 0</code> 주소 거부</td><td><code>fcn</code> null-check 제거, <code>walkaddr</code>만으로 유효성 확인</td></tr><tr><td><code>join</code></td><td>lock 보호 미흡</td><td>lock 순서 및 <code>freeproc()</code> 내부 동기화 보강</td></tr><tr><td><code>exec</code></td><td>다른 thread가 trap 발생</td><td>동일 pagetable 공유 thread 전부 제거</td></tr><tr><td><code>kill</code></td><td>일부 thread만 종료됨</td><td>pagetable 기준 전체 <code>killed</code> 처리</td></tr><tr><td><code>thread_join</code></td><td>stack 회수 누락</td><td>내부에서 <code>sbrk(-PGSIZE)</code> 호출 추가</td></tr><tr><td><code>sleep/wakeup</code></td><td>deadlock 또는 race condition</td><td>lock 순서 및 <code>wakeup</code> 시점 조정</td></tr></tbody></table><p>이와 같은 반복적 debugging과 코드 개선을 통해, xv6에 안정적이고 정확한 kernel 수준 thread 시스템을 구현할 수 있었다.</p><h2 id="additional-content" tabindex="-1"><a class="header-anchor" href="#additional-content"><span>Additional Content</span></a></h2><h3 id="reference-notes-for-thread-implementation-in-xv6-risc-v" tabindex="-1"><a class="header-anchor" href="#reference-notes-for-thread-implementation-in-xv6-risc-v"><span>Reference Notes for Thread Implementation in xv6 RISC-V</span></a></h3><ul><li><p>본 project는 <strong>xv6 RISC-V 버전</strong>을 기반으로 하며, x86 기반 구현 예제들과는 구조적으로 다르다.</p><ul><li>특히 <code>ptable[]</code>이 존재하지 않고, <code>proc[NPROC]</code> 배열과 spinlock으로만 동기화를 수행한다.</li><li>따라서 x86의 <code>switchuvm()</code>, <code>loaduvm()</code> 등의 동작 방식과 달리, RISC-V에서는 <code>walk()</code> 및 <code>pagetable_t</code>에 직접 접근하는 방식이 필요했다.</li></ul></li><li><p>xv6의 trapframe, context, scheduler 등은 thread-safe하지 않으므로, thread마다 반드시 독립된 <code>trapframe</code>, <code>context</code>, <code>ustack</code>을 사용해야 한다.</p></li><li><p><code>uvmshare()</code>는 기존 <code>uvmcopy()</code>를 변형하여 구현한 함수로, <code>PTE_U</code> 비트가 설정된 사용자 영역 page에 대해서만 공유(reference mapping)하도록 설계하였다.</p><ul><li>이는 read-only 세그먼트에 대해서도 문제가 없으며, exec이나 fork와는 다른 동작을 보장한다.</li></ul></li><li><p><code>thread_fcn.c</code>, <code>thread_test.c</code>는 과제 명세에서 제공한 채점 기준 파일이다.</p><ul><li>이 파일의 구조나 <code>fcn = 0x0</code> 형태의 호출 방식은 정상 동작이며, panic 유발 요소가 아니다.</li></ul></li><li><p>모든 thread 구현은 xv6의 기존 기능과 완전히 호환되어야 하며, 특히 다음과 같은 system call들과 연동 가능해야 한다.</p><ul><li><code>fork()</code>, <code>exec()</code>, <code>exit()</code>, <code>wait()</code>, <code>kill()</code>, <code>sleep()</code>, <code>pipe()</code></li></ul></li></ul><h3 id="additional-useful-references" tabindex="-1"><a class="header-anchor" href="#additional-useful-references"><span>Additional Useful References</span></a></h3><p>https://github.com/mit-pdos/xv6-riscv<br> https://pdos.csail.mit.edu/6.828/2022/xv6/book-riscv-rev3.pdf</p><p>실습 중 참고한 StackOverflow thread:</p><ul><li>https://stackoverflow.com/questions/78141535/threading-using-jmp-buf-array-in-c-test-in-xv6 (x86 중심이므로 구조는 참조용)</li></ul><p>이상으로 본 project의 기술적 배경과 연관된 모든 핵심 요소들을 포함하였다.</p>`,203)]))}const i=n(t,[["render",c]]),d=JSON.parse('{"path":"/os/wiki.html","title":"Project 02: xv6 RISC-V Kernel-Level Threads Implementation - wiki","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1749897692000,"contributors":[{"name":"김병준","username":"","email":"kmbzn24@hanyang.ac.kr","commits":3},{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":4,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"7dfc10ae87be9ce0083cb39d24d30b15e77a0371","time":1749897692000,"email":"kmbzn24@hanyang.ac.kr","author":"김병준","message":"directory name change"},{"hash":"a252038f4134056a57e1ccb57f0544c087383854","time":1748436181000,"email":"kmbzn@example.com","author":"kmbzn","message":"update wiki 2242"},{"hash":"3d21c1a0507ecef201d7ad84472c982f6e8a0f7c","time":1748435567000,"email":"kmbzn@example.com","author":"kmbzn","message":"update wiki and image"},{"hash":"31037533276f4a884e73afd5ba3b5f73944722bb","time":1748433268000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"update wiki"},{"hash":"34eb550181a05aaac4a32d0a56f0e45e2ce3042e","time":1748431694000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Update wiki.md"},{"hash":"89b5da5b5be7545c2c438cee66c9836d8f073614","time":1748321650000,"email":"kmbzn24@hanyang.ac.kr","author":"김병준","message":"update wiki (2)"},{"hash":"708fdd63f1bb64949a70aaff6b247db64ecf2f65","time":1748320849000,"email":"kmbzn24@hanyang.ac.kr","author":"김병준","message":"update wiki"}]},"filePathRelative":"os/wiki.md"}');export{i as comp,d as data};
