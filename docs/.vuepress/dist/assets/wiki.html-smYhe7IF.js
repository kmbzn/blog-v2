import{_ as n,c as s,a,o as i}from"./app-DVb85zHU.js";const l={};function c(d,e){return i(),s("div",null,[...e[0]||(e[0]=[a(`<h1 id="assignment-3-implementing-augmented-b-tree-wiki" tabindex="-1"><a class="header-anchor" href="#assignment-3-implementing-augmented-b-tree-wiki"><span>Assignment 3. Implementing Augmented B+tree - wiki</span></a></h1><p>2021024057 김병준</p><h2 id="_1-design" tabindex="-1"><a class="header-anchor" href="#_1-design"><span>1. Design</span></a></h2><h3 id="_1-1-overall-architecture" tabindex="-1"><a class="header-anchor" href="#_1-1-overall-architecture"><span>1.1. Overall Architecture</span></a></h3><p>해당 과제에서는 Disk-based B+tree를 구현하였다. 모든 노드는 4KB 크기의 page 단위로 디스크에 저장되며, <code>Header Page</code>, <code>Free Page</code>, <code>Internal Page</code>, <code>Leaf Page</code>의 네 가지 타입을 가진다.</p><ul><li>In-Memory Logic vs On-Disk Structure: 메모리 상의 포인터 대신 파일 내의 <code>offset</code>을 사용하여 페이지 간의 연결(Link)을 구현하였다. <code>open_table</code> 호출 시 <code>fd</code>(File Descriptor)를 전역으로 관리하며, <code>pread</code>/<code>pwrite</code> system call을 사용하여 페이지 단위의 I/O를 수행한다.</li></ul><h3 id="_1-2-data-structures" tabindex="-1"><a class="header-anchor" href="#_1-2-data-structures"><span>1.2. Data Structures</span></a></h3><ul><li>Page Structure: <code>4096 Bytes</code> 고정 크기. Header(<code>128B</code>)와 Body(Record/Internal Entry)로 구성된다.</li><li>Leaf Page: Key와 <code>120B</code> 크기의 Value를 저장하는 <code>record</code> 배열을 가진다. Order(Branching Factor)는 32이다.</li><li>Internal Page: Key와 자식 페이지의 Offset을 저장하는 <code>inter_record</code> 배열을 가진다. Order는 249이다.</li><li>Bitmap for Logical Deletion (<code>bptree2</code>): <code>bptree2</code>에서는 물리적 삭제 대신 논리적 삭제를 지원하기 위해, <code>page</code> 구조체의 <code>reserved[104]</code> 영역을 Bitmap으로 활용하였다. <code>reserved[i] == 1</code>인 경우 해당 인덱스의 레코드는 삭제된 것으로 간주한다.</li></ul><h2 id="_2-implement" tabindex="-1"><a class="header-anchor" href="#_2-implement"><span>2. Implement</span></a></h2><h3 id="_2-1-normal-b-tree-bptree1" tabindex="-1"><a class="header-anchor" href="#_2-1-normal-b-tree-bptree1"><span>2.1. Normal B+ tree (<code>bptree1</code>)</span></a></h3><p>기본적인 B+ tree의 삽입, 삭제, 탐색 연산을 구현하였다.</p><ul><li><p>Insertion &amp; Splitting: Leaf Page가 가득 찬 상태(<code>LEAF_MAX = 31</code>)에서 삽입 시 <code>insert_into_leaf_after_splitting</code>이 호출된다. 임시 배열을 생성하여 기존 레코드와 새 레코드를 정렬한 후, 중간 지점(<code>cut</code>)을 기준으로 두 개의 페이지로 분할한다. 이후 새 페이지의 첫 번째 Key를 부모로 올리는(<code>insert_into_parent</code>) 재귀적 logic을 구현하였다.</p></li><li><p>Deletion &amp; Merging/Redistribution: <code>db_delete</code>는 레코드를 물리적으로 제거(<code>memmove</code>)한다. 삭제 후 Key의 개수가 최소 조건 미만(Underflow)이 되면 <code>get_neighbor_index</code>를 통해 형제 노드를 탐색한다.</p><ul><li>Redistribution: 형제 노드에 여유가 있다면 Key를 하나 빌려와 균형을 맞춘다.</li><li>Coalesce (Merge): 형제 노드도 여유가 없다면 두 노드를 병합하고, 부모 노드에서 해당 포인터를 제거(<code>delete_entry</code>)하는 과정을 재귀적으로 수행한다.</li></ul></li></ul><h3 id="_2-2-logical-deletion-applied-b-tree-bptree2" tabindex="-1"><a class="header-anchor" href="#_2-2-logical-deletion-applied-b-tree-bptree2"><span>2.2. Logical Deletion Applied B+ tree (<code>bptree2</code>)</span></a></h3><p><code>bptree1</code>의 code를 기반으로 하되, 삭제 정책과 구조를 변경하였다.</p><ul><li><p>Logical Deletion (<code>db_delete</code>)</p><ul><li>물리적인 데이터 이동이나 병합(Merge) 과정을 제거하였다.</li><li>대신 해당 레코드의 인덱스 <code>i</code>에 대해 <code>page-&gt;reserved[i] = 1</code>로 마킹하고 페이지를 디스크에 저장한다.</li><li>이로 인해 삭제 연산의 비용이 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\\log N) + O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>로 크게 감소하였다.</li></ul></li><li><p>Revival on Insertion (<code>db_insert</code>)</p><ul><li>이미 존재하는 Key에 대한 삽입 요청이 들어왔을 때, 해당 Key가 논리적으로 삭제된 상태(<code>reserved == 1</code>)라면 새로운 레코드를 추가하는 대신 기존 위치의 Value를 갱신하고 <code>reserved = 0</code>으로 변경하여 데이터를 &#39;부활&#39;시킨다.</li></ul></li><li><p>Visibility Check (<code>db_find</code>)</p><ul><li>탐색 시 Key가 존재하더라도 <code>reserved == 1</code>이라면 <code>NULL</code>을 반환하여 사용자에게는 삭제된 것처럼 보이도록 구현하였다.</li></ul></li></ul><h2 id="_3-result" tabindex="-1"><a class="header-anchor" href="#_3-result"><span>3. Result</span></a></h2><h3 id="_3-1-test-environment" tabindex="-1"><a class="header-anchor" href="#_3-1-test-environment"><span>3.1. Test Environment</span></a></h3><ul><li>OS: Ubuntu 24.04 LTS</li><li>Compiler: gcc</li><li>Tools: Make</li></ul><h3 id="_3-2-bptree1-execution" tabindex="-1"><a class="header-anchor" href="#_3-2-bptree1-execution"><span>3.2. <code>bptree1</code> Execution</span></a></h3><ol><li>Insert &amp; Find: Key <code>100</code>, <code>50</code>, <code>150</code>을 순서대로 삽입 후 조회 시 정렬되어 출력됨을 확인하였다.</li><li>Split: 32개 이상의 레코드 삽입 시 Leaf Page가 분할되고, 새로운 Root가 생성되어 트리의 높이가 증가함을 확인하였다.</li><li>Delete (Merge): 대량 삭제 수행 시 Page Merge가 발생하고, Root가 다시 Leaf로 내려오거나 변경되는 과정을 확인하였다.</li></ol><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">kmbzn@p31:~/workspace/Assignment3_2021024057/bptree1$ <span class="token function">rm</span> <span class="token parameter variable">-f</span> *.db</span>
<span class="line">kmbzn@p31:~/workspace/Assignment3_2021024057/bptree1$ ./main</span>
<span class="line">i <span class="token number">1</span> A</span>
<span class="line">i <span class="token number">2</span> B</span>
<span class="line">i <span class="token number">3</span> C</span>
<span class="line">i <span class="token number">4</span> D</span>
<span class="line">i <span class="token number">5</span> E</span>
<span class="line">i <span class="token number">6</span> F</span>
<span class="line">i <span class="token number">7</span> G</span>
<span class="line">i <span class="token number">8</span> H</span>
<span class="line">i <span class="token number">9</span> I</span>
<span class="line">i <span class="token number">10</span> J</span>
<span class="line">i <span class="token number">11</span> K</span>
<span class="line">i <span class="token number">12</span> L</span>
<span class="line">i <span class="token number">13</span> M</span>
<span class="line">i <span class="token number">14</span> N</span>
<span class="line">i <span class="token number">15</span> O</span>
<span class="line">i <span class="token number">16</span> P</span>
<span class="line">i <span class="token number">17</span> Q</span>
<span class="line">i <span class="token number">18</span> R</span>
<span class="line">i <span class="token number">19</span> S</span>
<span class="line">i <span class="token number">20</span> T</span>
<span class="line">i <span class="token number">21</span> U</span>
<span class="line">i <span class="token number">22</span> V</span>
<span class="line">i <span class="token number">23</span> W</span>
<span class="line">i <span class="token number">24</span> X</span>
<span class="line">i <span class="token number">25</span> Y</span>
<span class="line">i <span class="token number">26</span> Z</span>
<span class="line">i <span class="token number">27</span> AA</span>
<span class="line">i <span class="token number">28</span> BB</span>
<span class="line">i <span class="token number">29</span> CC</span>
<span class="line">i <span class="token number">30</span> DD</span>
<span class="line">i <span class="token number">31</span> EE</span>
<span class="line">i <span class="token number">32</span> FF</span>
<span class="line">f <span class="token number">1</span></span>
<span class="line">Key: <span class="token number">1</span>, Value: A</span>
<span class="line">f <span class="token number">32</span></span>
<span class="line">Key: <span class="token number">32</span>, Value: FF</span>
<span class="line">d <span class="token number">1</span></span>
<span class="line">d <span class="token number">2</span></span>
<span class="line">d <span class="token number">3</span></span>
<span class="line">d <span class="token number">4</span></span>
<span class="line">d <span class="token number">5</span></span>
<span class="line">d <span class="token number">6</span></span>
<span class="line">d <span class="token number">7</span></span>
<span class="line">d <span class="token number">8</span></span>
<span class="line">d <span class="token number">9</span></span>
<span class="line">d <span class="token number">10</span></span>
<span class="line">d <span class="token number">11</span></span>
<span class="line">d <span class="token number">12</span></span>
<span class="line">d <span class="token number">13</span></span>
<span class="line">d <span class="token number">14</span></span>
<span class="line">d <span class="token number">15</span></span>
<span class="line">d <span class="token number">16</span></span>
<span class="line">d <span class="token number">17</span></span>
<span class="line">f <span class="token number">17</span></span>
<span class="line">Not Exists</span>
<span class="line">f <span class="token number">18</span></span>
<span class="line">Key: <span class="token number">18</span>, Value: R</span>
<span class="line">q</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-bptree2-execution-logical-deletion" tabindex="-1"><a class="header-anchor" href="#_3-3-bptree2-execution-logical-deletion"><span>3.3. <code>bptree2</code> Execution (Logical Deletion)</span></a></h3><ol><li>Logical Delete: <code>d 100</code> 수행 후 <code>f 100</code> 시 &quot;Not Exists&quot; 출력 확인하였다. 하지만 물리적 file 크기는 줄어들지 않는다.</li><li>Revival: 삭제된 Key 100에 대해 <code>i 100 world</code> 수행 시, 새로운 공간을 할당하지 않고 기존 슬롯을 재활용하여 값이 갱신됨을 확인하였다.</li><li>Reorganization: <code>q</code>를 눌러 종료 시 <code>db_reorganize</code>가 호출되어, 삭제된 데이터가 정리된 상태로 DB 파일이 갱신됨을 확인하였다.</li></ol><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">kmbzn@p31:~/workspace/Assignment3_2021024057/bptree2$ <span class="token function">rm</span> <span class="token parameter variable">-f</span> *.db</span>
<span class="line">kmbzn@p31:~/workspace/Assignment3_2021024057/bptree2$ ./main</span>
<span class="line">i <span class="token number">100</span> hello</span>
<span class="line">d <span class="token number">100</span></span>
<span class="line">f <span class="token number">100</span></span>
<span class="line">Not Exists</span>
<span class="line">i <span class="token number">100</span> world</span>
<span class="line">f <span class="token number">100</span></span>
<span class="line">Key: <span class="token number">100</span>, Value: world</span>
<span class="line">q</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-troubleshooting" tabindex="-1"><a class="header-anchor" href="#_4-troubleshooting"><span>4. TroubleShooting</span></a></h2><h3 id="_4-1-get-neighbor-index-segmentation-fault" tabindex="-1"><a class="header-anchor" href="#_4-1-get-neighbor-index-segmentation-fault"><span>4.1. <code>get_neighbor_index</code> Segmentation Fault</span></a></h3><ul><li>문제: <code>bptree1</code>의 삭제 연산 중, Internal Page가 병합되어 빈 페이지(<code>num_of_keys == 0</code>)가 된 상태에서 부모를 탐색할 때 <code>parent-&gt;b_f[0]</code>에 접근하여 Segmentation Fault가 발생하였다.</li><li>원인: <code>num_of_keys</code>가 0인 경우 <code>b_f</code> 배열이 유효하지 않음에도 접근을 시도하였다.</li><li>해결: <code>parent-&gt;num_of_keys &gt; 0</code> 조건을 추가하여, 키가 있을 때만 <code>b_f[0]</code>를 확인하도록 로직을 수정하여 해결하였다.</li></ul><h3 id="_4-2-db-reorganize-trace-trap-error" tabindex="-1"><a class="header-anchor" href="#_4-2-db-reorganize-trace-trap-error"><span>4.2. <code>db_reorganize</code> Trace Trap Error</span></a></h3><ul><li>문제: <code>bptree2</code>에서 재구성(Reorganize) 실행 시 프로그램이 비정상 종료(<code>Trace Trap</code>)되었다.</li><li>원인: <code>open_table</code> 함수 내부에서 전역 변수 <code>DB_PATH</code>를 <code>memset</code>으로 초기화하는데 <code>db_reorganize</code>에서 <code>open_table(DB_PATH)</code> 형태로 자기 자신을 argument로 넘기면서 포인터 참조 오류가 발생하였다.</li><li>해결: <code>db_reorganize</code> 함수 초입에서 <code>DB_PATH</code>를 로컬 변수 <code>original_path</code>에 <code>strncpy</code>로 복사해둔 뒤 이 복사본을 사용하여 <code>open_table</code>을 호출하도록 수정하였다.</li></ul><h2 id="_5-consideration-on-db-reorganize" tabindex="-1"><a class="header-anchor" href="#_5-consideration-on-db-reorganize"><span>5. Consideration on <code>db_reorganize</code></span></a></h2><h3 id="_5-1-구현-목표" tabindex="-1"><a class="header-anchor" href="#_5-1-구현-목표"><span>5.1. 구현 목표</span></a></h3><p><code>db_reorganize</code>는 논리적으로 삭제된 레코드(Fragmentation)를 제거하고, B+ tree를 물리적으로 재구성하여 검색 성능과 공간 효율성을 최적화하는 것을 목표로 한다.</p><h3 id="_5-2-채택한-알고리즘" tabindex="-1"><a class="header-anchor" href="#_5-2-채택한-알고리즘"><span>5.2. 채택한 알고리즘</span></a></h3><p>기존 파일 내에서 빈 공간을 찾아 데이터를 이동시키는 방식(In-place compaction) 대신, 새로운 DB 파일을 생성하여 유효한 데이터만 migrate시키는 방식을 사용하기로 결정하였다.</p><ol><li>Rename: 현재 사용 중인 DB 파일을 <code>backup.db</code>로 이름을 변경한다.</li><li>Create New: 원래 이름으로 새로운 빈 DB 파일을 생성한다 (<code>open_table</code>).</li><li>Migrate: <ul><li><code>backup.db</code>를 Read-only로 열고, Root부터 시작하여 모든 Leaf Page를 순회한다.</li><li>Leaf Page 내에서 <code>reserved == 0</code>인(삭제되지 않은) 유효한 레코드만 추출한다.</li><li>추출된 레코드를 새 DB에 <code>db_insert</code> 한다.</li></ul></li><li>Cleanup: 작업 완료 후 <code>backup.db</code>를 삭제(<code>unlink</code>)한다.</li></ol><h3 id="_5-3-성능상의-이점" tabindex="-1"><a class="header-anchor" href="#_5-3-성능상의-이점"><span>5.3. 성능상의 이점</span></a></h3><ul><li>이 방식이 갖는 장점들 <ul><li>Sequential I/O: 기존 트리를 순차적으로 읽고(Sequential Read), 새 트리에 순차적으로 씀(Append-only Write)으로써 디스크 헤드 이동을 최소화할 수 있다.</li><li>Fragmentation 제거: 새로 생성된 트리는 중간에 빈 공간 없이 꽉 채워지므로(Compacted), 디스크 공간 낭비가 0에 수렴한다고 볼 수 있다.</li><li>안전성: 작업 도중 실패하더라도 원본(<code>backup.db</code>)이 보존된 상태이므로 복구가 용이하다.</li></ul></li></ul>`,37)])])}const o=n(l,[["render",c]]),r=JSON.parse('{"path":"/db/wiki.html","title":"Assignment 3. Implementing Augmented B+tree - wiki","lang":"ko-KR","frontmatter":{},"git":{"updatedTime":1763644668000,"contributors":[{"name":"kmbzn","username":"kmbzn","email":"kmbzn24@gmail.com","commits":5,"url":"https://github.com/kmbzn"}],"changelog":[{"hash":"3abf20ba32f746af427949e9e0ec821f4aebd2ff","time":1763644668000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Remove unnecessary .DS_Store file and update wiki documentation with execution examples and troubleshooting details"},{"hash":"f5be8501c77bc7d73cad74e340f5cf90eaed99e2","time":1763642791000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"Refactor wiki documentation for B+ tree implementation"},{"hash":"db59f13412c70dbd49dd7fa6dd23398d0d3044bc","time":1763626450000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"bpt code update"},{"hash":"31dabd91062ae4097bbcb6f7bebeb609ae905ae8","time":1761263576000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"위키 문서 수정: 데이터베이스 시스템 응용 제목 형식 변경 및 데모 영상 링크 추가"},{"hash":"8600b20ab0a31871d0a8ab1f33077cca06e672d9","time":1761260557000,"email":"kmbzn24@gmail.com","author":"kmbzn","message":"위키 문서 추가: 도서 관리 시스템 구현 및 인증 기능에 대한 상세 설명 포함"}]},"filePathRelative":"db/wiki.md"}');export{o as comp,r as data};
