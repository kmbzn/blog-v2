# 03. Cryptographic Tools

## Contents
- Symmetric Encryption
- Message Confidentiality
- Secure Hash Function
- Public Key Encryption

## Encryption and Message authentication
- Encryption (암호화): 데이터 보호를 위해 암호화 필요
  - Confidentiality (기밀성) 및 Integrity (무결성) 제공 가능
  - Symmetric encryption (대칭 암호) 및 Asymmetric encryption (비대칭 암호)
- Message authentication (메시지 인증)
  - Integrity는 제공 가능하지만, confidentiality는 제공 불가

## Symmetric Encryption
- 전송되거나 저장된 데이터에 confidentiality를 제공하기 위한 보편적인 기술
- Conventional encryption (관용 암호) 또는 single-key encryption (단일키 암호)라고도 함
- 안전한 사용을 위한 두 가지 요구사항:
  - 강력한 암호화 알고리즘 필요
  - 송신자와 수신자는 안전한 방식으로 secret key (비밀키) 사본을 획득하고 키를 안전하게 유지해야 함
- Public-key encryption (공개키 암호) 이전인 1970년대까지 유일한 대안
- 여전히 가장 널리 사용되는 대안
- 5가지 구성 요소:
  - Plaintext (평문)
  - Encryption algorithm (암호화 알고리즘)
  - Secret key (비밀키)
  - Ciphertext (암호문)
  - Decryption algorithm (복호화 알고리즘)

## Cryptography
- 세 가지 독립적인 차원으로 분류됨:
  - Plaintext를 ciphertext로 변환하는 데 사용되는 연산 유형
    - Substitution (치환): plaintext의 각 요소가 다른 요소로 매핑됨
    - Transposition (전치): plaintext의 요소가 재배열됨
  - 사용되는 키의 수
    - 송신자와 수신자가 동일한 키 사용 – symmetric (대칭)
    - 송신자와 수신자가 각각 다른 키 사용 – asymmetric (비대칭)
  - Plaintext가 처리되는 방식
    - Block cipher (블록 암호): 한 번에 한 블록의 요소를 처리
    - Stream cipher (스트림 암호): 입력 요소를 연속적으로 처리

## Cryptanalytic Attacks
- Cryptanalytic Attack
  - 의존하는 것:
    - 알고리즘의 특성
    - plaintext의 일반적인 특성에 대한 일부 지식
    - 일부 plaintext-ciphertext 쌍 샘플
  - 알고리즘의 특성을 이용하여 특정 plaintext 또는 사용 중인 키를 추론 시도
  - 성공 시, 해당 키로 암호화된 모든 미래 및 과거 메시지가 손상됨
- Brute-Force Attack (전사 공격)
  - 일부 ciphertext에 대해 해독 가능한 plaintext 번역이 얻어질 때까지 모든 가능한 키를 시도
  - 성공을 위해 평균적으로 모든 가능한 키의 절반을 시도해야 함

## Cryptanalysis
- 공격 유형
  - Cryptanalyst (암호 분석가)에게 알려진 정보

## Computationally Secure Encryption Schemes
- 암호화는 다음과 같은 경우 computationally secure (계산적으로 안전)함:
  - 암호 해독 비용이 정보의 가치를 초과
  - 암호 해독에 필요한 시간이 정보의 유효 수명을 초과
- 일반적으로 해독에 필요한 노력의 양을 추정하기 매우 어려움
- Brute-force attack의 시간/비용은 추정 가능

## Attacking Symmetric Encryption
- Brute-Force Attack
  - 일부 ciphertext에 대해 해독 가능한 plaintext 번역이 얻어질 때까지 모든 가능한 키를 시도
  - 성공을 위해 평균적으로 모든 가능한 키의 절반을 시도해야 함
  - Average Time Required for Exhaustive Key Search (전수 키 탐색에 필요한 평균 시간)

## Figure 2.2 Time to Break a Code
- (10^6 decryptions/ms 가정 시)
- 그래프는 symmetric encryption 알고리즘이 모든 가능한 키를 시도하는 brute-force 방식으로 공격받는다고 가정함

## Table 2.2 Comparison of Three Popular Symmetric Encryption Algorithms
- 세 가지 유명 대칭 암호화 알고리즘 비교

## Feistel Cipher Structure

## Block Cipher Structure
- Symmetric block cipher는 다음으로 구성됨:
  - A sequence of rounds (라운드의 연속)
  - 키에 의해 제어되는 substitutions 및 permutations (치환 및 순열)
- 매개변수 및 설계 특징:
  - Block size (블록 크기)
  - Key size (키 크기)
  - Number of rounds (라운드 수)
  - Subkey generation algorithm (서브키 생성 알고리즘)
  - Round function (라운드 함수)
  - Fast software encryption/decryption (빠른 소프트웨어 암호화/복호화)
  - Ease of analysis (분석의 용이성)

## Data Encryption Standard (DES)
- 가장 널리 사용되었던 암호화 방식
  - FIPS PUB 46
  - Data Encryption Algorithm (DEA)라고도 함
  - Feistel network의 사소한 변형
  - 64-bit plaintext block과 56-bit key를 사용하여 64-bit ciphertext block 생성
- 강도에 대한 우려:
  - 알고리즘에 대한 우려
  - DES는 현존하는 가장 많이 연구된 암호화 알고리즘
  - 56-bit key의 사용
  - Electronic Frontier Foundation (EFF)는 1998년 7월 DES 암호화를 해독했다고 발표

## Triple DES (3DES)
- 기본 DES 알고리즘을 두 개 또는 세 개의 고유한 키를 사용하여 세 번 반복
- 장점:
  - 168-bit 키 길이는 DES의 brute-force attack에 대한 취약점을 극복
  - 기본 암호화 알고리즘이 DES와 동일
- 단점:
  - 알고리즘이 소프트웨어에서 느림
  - 64-bit 블록 크기를 사용
- 처음에는 금융 애플리케이션에서 사용됨
- 1999년 DES FIPS PUB 46-3 표준에 포함
- 세 개의 키와 세 번의 DES 실행을 사용:
  - $C = E(K_3, D(K_2, E(K_1, P)))$
- 복호화는 키를 역순으로 사용하여 동일하게 수행
- 두 번째 단계에서 복호화를 사용하여 기존 DES 사용자와의 호환성 제공
- 유효 168-bit 키 길이, 느리지만 안전함
- AES가 결국 3DES를 대체할 것임

## Advanced Encryption Standard (AES)
- 3DES를 대체할 필요성 발생
  - 3DES는 장기적인 사용에 합리적이지 않았음
- NIST는 1997년 새로운 AES를 위한 제안을 요청
  - 3DES와 동등하거나 더 나은 보안 강도를 가져야 함
  - 효율성이 크게 향상되어야 함
- Symmetric block cipher
  - 128-bit 데이터 및 128/192/256-bit 키
- 2001년 11월 Rijndael을 선정
- FIPS 197로 발표됨

## AES Round Structure

## Table 20.2 (a) S-box

## Table 20.2(b) Inverse S-box

## Shift Rows
- 암호화 시 State의 각 행을 각각 0, 1, 2, 3 바이트씩 왼쪽으로 회전
- 복호화는 반대로 수행
- 개별 바이트를 한 열에서 다른 열로 이동시키고 바이트를 열에 걸쳐 분산시키기 위함

## Mix Columns and Add Key
- Mix columns
  - 각 열에 대해 개별적으로 작동
  - 각 바이트를 해당 열의 네 바이트 모두의 함수인 새 값으로 매핑
  - 유한체 상의 방정식을 사용
  - 열 내 바이트의 좋은 혼합을 제공하기 위함
- Add round key
  - 단순히 State를 확장된 키의 비트들과 `XOR` 연산
  - 라운드 키 확장 및 AES의 다른 단계의 복잡성으로부터 보안성 확보

## Practical Security Issues
- 일반적으로 symmetric encryption은 단일 64-bit 또는 128-bit 블록보다 큰 데이터 단위에 적용됨
- Electronic codebook (ECB) 모드는 다중 블록 암호화에 대한 가장 간단한 접근 방식
- 각 plaintext 블록은 동일한 키를 사용하여 암호화됨
- Cryptanalyst가 plaintext의 규칙성을 악용할 수 있음
- Modes of operation (운영 모드)
  - 긴 시퀀스에 대한 symmetric block encryption의 보안을 높이기 위해 개발된 대안 기술
  - ECB의 약점을 극복

## Modes of Operation

## Electronic Codebook (ECB)
- 가장 간단한 모드
- Plaintext는 b 비트 단위로 처리되며 각 블록은 동일한 키를 사용하여 암호화됨
- 각 plaintext 블록에 대해 고유한 ciphertext 값이 있으므로 "코드북"이라 불림
- 반복되는 plaintext가 반복되는 ciphertext에서 보이기 때문에 긴 메시지에 대해 안전하지 않음
- 보안 결함을 극복하기 위해 동일한 plaintext 블록이 반복될 경우 다른 ciphertext 블록을 생성하는 기술이 필요

## Cipher Block Chaining (CBC)

## Cipher Feedback (CFB)

## Counter (CTR)

## Block Cipher Encryption Stream Encryption

## Block & Stream Ciphers
- Block Cipher
  - 한 번에 한 블록의 요소를 처리
  - 각 입력 블록에 대해 출력 블록을 생성
  - 키를 재사용할 수 있음
  - 더 일반적
- Stream Cipher
  - 입력 요소를 연속적으로 처리
  - 한 번에 한 요소씩 출력을 생성
  - 주요 장점은 거의 항상 더 빠르고 훨씬 적은 코드를 사용한다는 점
  - Plaintext를 한 번에 한 바이트씩 암호화
  - Pseudorandom stream (의사 난수 스트림)은 입력 키를 모르면 예측할 수 없는 스트림
  - 설계 고려 사항:
    - 암호화 시퀀스는 긴 주기를 가져야 함
    - Keystream은 난수 속성에 근사해야 함
    - 충분히 긴 키를 사용

## Speed Comparisons of Symmetric Ciphers on a Pentium 4
- 출처: [http://www.cryptopp.com/benchmarks.html](http://www.cryptopp.com/benchmarks.html)

## Message Authentication
- Active attack (능동적 공격)으로부터 보호
- 수신된 메시지가 진짜인지 확인
  - 내용이 변경되지 않았음
  - 신뢰할 수 있는 출처로부터 옴
  - 시기적절하고 올바른 순서임
- Conventional encryption 사용 가능
  - 송신자와 수신자만이 키를 공유

## Message Authentication Codes

## Secure Hash Functions

## Figure 2.6 Message Authentication Using a One-Way Hash Function
- 단방향 해시 함수를 이용한 메시지 인증

## Hash Function Requirements
- 임의 크기의 데이터 블록에 적용 가능
- 고정 길이 출력 생성
- 주어진 $x$에 대해 $H(x)$ 계산이 비교적 쉬움
- One-way (단방향성) 또는 pre-image resistant (역상 저항성)
  - $H(x) = h$를 만족하는 $x$를 찾는 것이 계산적으로 불가능
- Second pre-image resistant (제2 역상 저항성) 또는 weak collision resistant (약한 충돌 저항성)
  - $H(y) = H(x)$를 만족하는 $y \ne x$를 찾는 것이 계산적으로 불가능
- Collision resistant (충돌 저항성) 또는 strong collision resistance (강한 충돌 저항성)
  - $H(x) = H(y)$를 만족하는 임의의 쌍 $(x, y)$를 찾는 것이 계산적으로 불가능

## Security of Hash Functions
- Secure hash function을 공격하는 두 가지 접근 방식:
  - Cryptanalysis: 알고리즘의 논리적 약점 이용
  - Brute-force attack: 해시 함수의 강도는 전적으로 알고리즘이 생성하는 해시 코드의 길이에 의존
- SHA는 가장 널리 사용되는 해시 알고리즘
- 추가적인 secure hash function 응용 분야:
  - Passwords (비밀번호): 운영 체제는 비밀번호의 해시를 저장
  - Intrusion detection (침입 탐지): 시스템의 각 파일에 대해 $H(F)$를 저장하고 해시 값을 보호

## Secure Hash Algorithm (SHA)
- SHA는 본래 NIST에 의해 개발됨
- 1993년 FIPS 180으로 발표됨
- 1995년 SHA-1으로 개정됨
  - 160-bit 해시 값 생성
- NIST는 2002년 개정된 FIPS 180-2를 발표
  - 3가지 추가 버전의 SHA 추가
  - SHA-256, SHA-384, SHA-512
  - 256/384/512-bit 해시 값
  - SHA-1과 동일한 기본 구조이지만 보안성이 더 높음
- 2005년 NIST는 SHA-1 승인을 단계적으로 중단하고 2010년까지 다른 SHA 버전에 의존하는 것으로 전환할 의사를 발표

## Table 21.1 Comparison of SHA Parameters
- SHA 매개변수 비교

## SHA-512 Structure

## SHA-3
- SHA-1은 안전하지 않은 것으로 간주되어 SHA-2로 단계적으로 대체됨
- SHA-2는 이전 버전과 동일한 구조와 수학적 연산을 공유하여 우려를 야기
- SHA-2가 취약해질 경우 교체에 필요한 시간 때문에, NIST는 2007년 SHA-3를 생산하기 위한 경쟁을 발표
- 요구사항:
  - 224, 256, 384, 512 비트의 해시 값 길이를 지원해야 함
  - 알고리즘은 전체 메시지를 처리하기 전에 메모리에 버퍼링할 필요 없이 한 번에 작은 블록을 처리해야 함

## SHA-3 Evaluation Criteria
- SHA-2가 지원하는 주요 응용 프로그램에 대한 요구 사항을 반영하도록 설계됨
  - Digital signatures (디지털 서명), hashed message authentication codes (해시 메시지 인증 코드), key generation (키 생성), pseudorandom number generation (의사 난수 생성)
- Security (보안성)
  - 강도는 다양한 필수 해시 크기와 preimage resistance 및 collision resistance 모두에 대해 이론적 최대치에 가까워야 함
  - SHA-2 함수에 대한 잠재적으로 성공적인 모든 공격에 저항하도록 설계되어야 함
- Cost (비용)
  - 다양한 하드웨어 플랫폼에서 시간 및 메모리 효율적이어야 함
- Algorithm and implementation characteristics (알고리즘 및 구현 특성)
  - 유연성 및 단순성과 같은 특성을 고려
- NIST는 2015년 SHA-3를 발표

## HMAC
- 암호학적 해시 코드에서 파생된 MAC (메시지 인증 코드) 개발에 관심이 있었음
  - 암호학적 해시 함수는 일반적으로 더 빠르게 실행됨
  - 라이브러리 코드가 널리 사용 가능함
- SHA-1은 secret key에 의존하지 않기 때문에 MAC으로 사용되도록 설계되지 않음
- RFC2014로 발표됨
- IP security (IP 보안)를 위한 의무 구현 MAC으로 선택됨
- Transport Layer Security (TLS) 및 Secure Electronic Transaction (SET)과 같은 다른 인터넷 프로토콜에서 사용됨

## HMAC Design Objectives
- 사용 가능한 해시 함수를 수정 없이 사용하기 위함
- 더 빠르거나 더 안전한 해시 함수가 발견되거나 필요할 경우 내장된 해시 함수를 쉽게 교체할 수 있도록 허용
- 심각한 성능 저하 없이 해시 함수의 원래 성능을 보존
- 간단한 방식으로 키를 사용하고 처리
- 내장된 해시 함수에 대한 합리적인 가정을 기반으로 한 인증 메커니즘의 강도에 대한 잘 이해된 암호학적 분석을 갖춤

## HMAC Structure

## Security of HMAC
- 보안은 기본 해시 함수의 암호학적 강도에 따라 달라짐
- HMAC에 대한 성공적인 공격 확률은 내장된 해시 함수에 대한 다음 공격 중 하나와 동일함:
  - 공격자가 임의의 비밀 IV를 가지고도 출력을 계산
    - Brute force key $O(2^n)$, 또는 birthday attack (생일 공격) 사용
  - 또는 공격자가 IV가 임의이고 비밀일 때도 해시 함수에서 충돌을 찾음
    - 즉, $H(M) = H(M')$인 $M$과 $M'$을 찾음
    - Birthday attack $O(2^{n/2})$

## Public-Key Encryption Structure
- 1976년 Diffie와 Hellman에 의해 공개적으로 제안됨
- 수학적 함수에 기반
- Asymmetric
  - 두 개의 개별 키 사용
  - Public key (공개키) 및 private key (개인키)
  - Public key는 다른 사람들이 사용하도록 공개됨
  - 배포를 위해 어떤 형태의 프로토콜이 필요

## Public-Key Encryption
- Plaintext
  - 알고리즘에 입력으로 제공되는 읽을 수 있는 메시지 또는 데이터
- Encryption algorithm
  - plaintext에 변환을 수행
- Public and private key
  - 암호화를 위한 키와 복호화를 위한 키 한 쌍
- Ciphertext
  - 출력으로 생성되는 뒤섞인 메시지
- Decryption key
  - 원본 plaintext를 생성

## Applications for Public-Key Cryptosystems
- 공개키 암호 시스템의 응용

## Requirements for Public-Key Cryptosystems
- 키 쌍을 생성하기 쉬움 (계산적으로)
- 공개키를 아는 송신자가 메시지를 암호화하기 쉬움 (계산적으로)
- 개인키를 아는 수신자가 암호문을 복호화하기 쉬움 (계산적으로)
- 공격자가 공개키로부터 개인키를 결정하기 불가능함 (계산적으로)
- 공격자가 다른 방법으로 원본 메시지를 복구하기 불가능함 (계산적으로)
- 어느 키든 각 역할에 사용할 수 있다면 유용함

## Asymmetric Encryption Algorithms
- RSA (Rivest, Shamir, Adleman)
  - 1977년 개발
  - 가장 널리 인정받고 구현된 public-key encryption 접근 방식
  - Plaintext와 ciphertext가 어떤 n에 대해 0과 n-1 사이의 정수인 block cipher
- Diffie-Hellman
  - Key exchange (키 교환) 알고리즘
  - 두 사용자가 메시지의 후속 대칭 암호화를 위한 secret key로 사용할 수 있는 공유 비밀에 안전하게 합의할 수 있도록 함
  - 키 교환에만 국한됨
- Digital Signature Standard (DSS)
  - SHA-1과 함께 digital signature 기능만 제공
  - 암호화나 키 교환에는 사용할 수 없음
- Elliptic curve cryptography (ECC)
  - RSA와 유사한 보안성을 가지면서도 훨씬 작은 키 사용

## RSA Public-Key Encryption
- 1977년 MIT의 Rivest, Shamir & Adleman에 의해 개발
- 가장 잘 알려져 있고 널리 사용되는 public-key 알고리즘
- 소수를 법으로 하는 정수의 거듭제곱을 사용
- 암호화: $C = M^e \mod n$
- 복호화: $M = C^d \mod n = (M^e)^d \mod n = M$
- 송신자와 수신자 모두 $n$과 $e$의 값을 앎
- 수신자만 $d$의 값을 앎
- Public key $PU = \{e, n\}$와 private key $PR = \{d, n\}$를 사용하는 public-key encryption 알고리즘

## RSA Algorithm

## RSA Example

## Security of RSA
- Brute force
  - 가능한 모든 private key 시도
  - 방어책은 큰 키 공간을 사용하는 것이지만, 이는 실행 속도를 늦춤
- Mathematical attacks (수학적 공격)
  - 여러 접근법이 있으며, 모두 두 소수의 곱을 인수분해하는 노력과 동일
- Timing attacks (타이밍 공격)
  - 복호화 알고리즘의 실행 시간에 따라 달라짐
  - 완전히 예상치 못한 방향에서 오며, ciphertext-only attack (암호문 단독 공격)
  - 대응책: 일정한 지수화 시간, 무작위 지연, 블라인딩
- Chosen ciphertext attacks (선택 암호문 공격)
  - RSA 알고리즘의 속성을 악용하는 공격

## Table 21.2 Progress in Factorization
- 인수분해의 진전

## Diffie-Hellman Key Exchange
- 최초로 발표된 public-key 알고리즘
- 1976년 Diffie와 Hellman이 public key 개념 설명과 함께 발표
- 다수의 상용 제품에서 사용됨
- 메시지의 후속 암호화를 위해 사용할 수 있는 secret key를 안전하게 교환하는 실용적인 방법
- 보안은 이산 로그 계산의 어려움에 의존

## Diffie-Hellman Key Exchange Algorithm

## Diffie-Hellman Example
- 소수 $q = 353$
- 원시근 $\alpha = 3$
- A와 B가 각각 자신의 공개키 계산
  - A는 $Y_A = 3^{97} \mod 353 = 40$ 계산
  - B는 $Y_B = 3^{233} \mod 353 = 248$ 계산
- 교환 후 비밀키 계산:
  - A: $K = (Y_B)^{X_A} \mod 353 = 248^{97} \mod 353 = 160$
  - B: $K = (Y_A)^{X_B} \mod 353 = 40^{233} \mod 353 = 160$
- 공격자는 다음을 풀어야 함:
  - $3^a \mod 353 = 40$ (어려움)
  - 원하는 답은 97이며, 그 후 B와 같이 키를 계산

## Key Exchange Protocols

## Man-in-the-Middle Attack
- 공격 과정:
    1. Darth가 개인키 $X_{D1}$ & $X_{D2}$와 그들의 공개키 $Y_{D1}$ & $Y_{D2}$를 생성
    2. Alice가 $Y_A$를 Bob에게 전송
    3. Darth가 $Y_A$를 가로채고 $Y_{D1}$을 Bob에게 전송. Darth는 $K_2$도 계산
    4. Bob이 $Y_{D1}$을 받고 $K_1$을 계산
    5. Bob이 $Y_B$를 Alice에게 전송 (슬라이드 오타: $Y_B$여야 함)
    6. Darth가 $Y_B$를 가로채고 $Y_{D2}$를 Alice에게 전송. Darth는 $K_1$을 계산
    7. Alice가 $Y_{D2}$를 받고 $K_2$를 계산
- 모든 후속 통신이 손상됨

## Other Public-Key Algorithms
- Digital Signature Standard (DSS)
  - FIPS PUB 186
  - SHA-1 및 Digital Signature Algorithm (DSA)을 사용
  - 1991년 최초 제안, 1993년 보안 우려로 개정, 1996년 사소한 개정
  - 암호화나 키 교환에 사용될 수 없음
  - Digital signature 기능만 제공하도록 설계된 알고리즘 사용
- Elliptic-Curve Cryptography (ECC)
  - RSA보다 작은 비트 크기로 동등한 보안 제공
  - IEEE P1363과 같은 표준에서 볼 수 있음
  - ECC에 대한 신뢰 수준은 아직 RSA만큼 높지 않음
  - 타원 곡선이라는 수학적 구조에 기반

## Digital Signatures
- 출처 및 데이터 무결성 인증에 사용
- Private key로 해시 코드를 암호화하여 생성
- Confidentiality를 제공하지 않음
  - 완전한 암호화의 경우에도 마찬가지
  - 메시지는 변경으로부터 안전하지만 도청으로부터는 안전하지 않음

## Public Key Certificates

## Key Distribution
- 데이터를 교환하려는 두 당사자에게 다른 사람이 키를 볼 수 없도록 키를 전달하는 수단
- 두 당사자(A와 B)는 다음 방법으로 이를 달성할 수 있음:
    1. A가 키를 선택하여 B에게 물리적으로 전달
    2. 제3자가 키를 선택하여 A와 B에게 물리적으로 전달
    3. A와 B가 이전에 그리고 최근에 키를 사용한 경우, 한쪽이 다른 쪽에 이전 키로 암호화된 새 키를 전송
    4. A와 B가 각각 제3자 C와 암호화된 연결을 가지고 있는 경우, C가 암호화된 링크를 통해 A와 B에게 키를 전달

## Key Distribution

## Kerberos Overview
- 본래 MIT에서 개발됨
- 공개 도메인 및 상용 지원 버전으로 사용 가능한 소프트웨어 유틸리티
- 인터넷 표준으로 발표되었으며 원격 인증의 사실상 표준
- 전체적인 방식은 신뢰할 수 있는 제3자 인증 서비스
- 사용자가 호출하는 각 서비스에 대해 자신의 신원을 증명해야 하며, 서버는 클라이언트에게 자신의 신원을 증명해야 함

## Kerberos Protocol
- Client/server 대화의 보안에 대한 다양한 위협에 대응하도록 설계됨
- 명백한 보안 위험은 impersonation (가장)
- 서버는 서비스를 요청하는 클라이언트의 신원을 확인할 수 있어야 함
- Clients, application servers, Kerberos server를 포함
  - 사용자는 처음에 신원 확인을 위해 AS (인증 서버)와 협상
  - AS는 신원을 확인한 다음 정보를 application server (응용 프로그램 서버)에 전달하고, 서버는 클라이언트로부터 서비스 요청을 수락
- Authentication Server (AS) 사용
  - 클라이언트가 네트워크를 통해 AS에게 사용자의 비밀번호를 보내면 상대방이 비밀번호를 관찰할 수 있음
  - 상대방이 AS를 가장하여 잘못된 검증을 보낼 수 있음
- 이를 안전한 방식으로 수행할 방법을 찾아야 함

## Kerberos Realms
- Kerberos 환경은 다음으로 구성됨:
  - Kerberos server
  - 서버에 등록된 다수의 clients
  - 서버와 키를 공유하는 다수의 application servers
- 이를 realm (영역)이라고 함
- 다른 관리 조직 하의 클라이언트 및 서버 네트워크는 일반적으로 다른 realm을 구성
- 여러 realm이 있는 경우:
  - 그들의 Kerberos 서버는 secret key를 공유해야 하며, 다른 realm의 Kerberos 서버가 사용자를 인증하는 것을 신뢰해야 함
  - 두 번째 realm의 참여 서버들도 첫 번째 realm의 Kerberos 서버를 신뢰할 의향이 있어야 함

## Kerberos Performance Issues
- 대규모 client-server 설치에서 볼 수 있음
- Kerberos가 대규모 환경의 성능에 미치는 영향:
  - 시스템이 올바르게 구성되었다면 거의 없음
  - 티켓은 재사용 가능하여 트래픽을 줄임
- 대규모 Kerberos 보안은 Kerberos 서버를 별도의 격리된 머신에 배치함으로써 가장 잘 보장됨
- 여러 realm의 동기는 성능 관련이 아닌 관리적인 것임

## Certificate Authority (CA)
- 인증서는 다음으로 구성됨:
  - Public key와 키 소유자의 User ID
  - 신뢰할 수 있는 제3자에 의해 서명됨
  - 일반적으로 제3자는 사용자 커뮤니티(예: 정부 기관 또는 금융 기관)가 신뢰하는 CA (인증 기관)
- 사용자는 자신의 공개키를 기관에 안전한 방식으로 제시하고 인증서를 받을 수 있음
- 그 후 사용자는 인증서를 게시할 수 있음
- 이 사용자의 공개키가 필요한 사람은 누구나 인증서를 얻고 첨부된 신뢰할 수 있는 서명을 통해 유효한지 확인할 수 있음

## X.509 Authentication Service
- Public-key certificates 서식에 대한 보편적으로 인정된 표준
- CCITT X.500 디렉터리 서비스 표준의 일부
- Public-key crypto 및 digital signatures 사용
- IPsec, SSL, SET, S/MIME 등 네트워크 보안 응용 프로그램에서 널리 사용됨
- 알고리즘은 표준화되지 않았지만 RSA가 권장됨

## X.509 Certificates

## Public Key Infrastructure X.509 (PKIX)

## PKIX Management Functions
- Registration (등록)
- Initialization (초기화)
- Certification (인증)
- Key pair recovery (키 쌍 복구)
- Key pair update (키 쌍 갱신)
- Revocation request (폐지 요청)
- Cross certification (교차 인증)

## Rotor Machines
- 현대 암호 이전에 rotor machine (회전기)이 가장 일반적인 product cipher (곱 암호)였음
- 제2차 세계대전에서 널리 사용됨
  - 독일 Enigma, 연합군 Hagelin, 일본 Purple
- 매우 복잡하고 가변적인 substitution cipher를 구현
- 각각 하나의 치환을 제공하는 일련의 실린더를 사용했으며, 각 글자가 암호화된 후 회전하고 변경됨
- 3개의 실린더로 $26^3 = 17576$개의 알파벳을 가짐
- 다중 암호화 단계
  - Substitution cipher와 transposition cipher 모두 사용
- 기본 원리
  - 독립적으로 회전하는 실린더 세트
  - 각 실린더의 전기 펄스가 세트를 따라 흐름
  - 각 실린더에는 26개의 입력 핀과 26개의 출력 핀이 있음
- 각 입력과 출력을 알파벳 문자와 연관시킨다면
  - 단일 실린더는 monoalphabetic substitution (단일치환 암호)을 정의
- 키를 누르면 실린더가 한 위치 회전
  - 내부 연결이 그에 따라 이동
  - 따라서 다른 monoalphabetic substitution cipher가 정의됨
- 26 글자 후에 실린더는 초기 상태로 돌아옴
- 주기가 26인 polyalphabetic permutation (다중치환 순열) 알고리즘
- 한 실린더의 출력이 다음 실린더의 입력에 연결됨
- 가장 바깥쪽 실린더는 각 키 입력마다 한 핀 위치 회전
- 바깥쪽 실린더가 한 바퀴 완전히 회전할 때마다 중간 실린더가 한 핀 위치 회전
- 중간 실린더가 한 바퀴 완전히 회전할 때마다 안쪽 실린더가 한 핀 위치 회전
- $26 \times 26 \times 26 = 17,576$