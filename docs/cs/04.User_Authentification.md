# 04. User Authentication

### RFC 2828. 사용자 인증의 정의
> 시스템 개체에 의해 또는 시스템 개체를 위해 주장된 신원을 검증하는 과정

## Authentication Process
- Identification(식별) 단계
  - 보안 시스템에 식별자(identifier)를 제시
- Verification(검증) 단계
  - 개체와 식별자 간의 바인딩(binding)을 확증하는 인증 정보를 제시하거나 생성
- 근본적인 구성 요소이자 주요 방어선
- 접근 제어(access control) 및 user accountability의 기반

## User Authentication
- 사용자 신원을 인증하는 네 가지 수단
1. 개인이 아는 것(Something the individual knows)
  - 암호(Password), PIN, 정해진 특정 질문에 대한 대답
2. 개인이 소유한 것(Something the individual possesses) (토큰)
  - 스마트카드, 전자 열쇠 카드, 물리적 열쇠
3. 개인의 존재(Something the individual is) (정적인 생체 정보, static biometrics)
  - 지문, 망막(Retina), 얼굴
4. 개인이 하는 행동(Something the individual does) (동적인 생체 정보, dynamic biometrics)
  - 음성 패턴, 필체(handwriting), typing rhythm

## Password Authentication
- 침입자에 대한 널리 사용되는 방식
- 사용자는 name/login과 password를 제공
- 시스템은 해당 로그인에 대해 저장된 암호와 비교하여, 맞으면 로그인에 성공
- 사용자 ID:
  - 사용자가 시스템에 접근할 권한이 있는지 결정
  - 사용자의 권한을 결정
  - 임의 접근 제어(DAC, discretionary access control)에 사용됨.

## Password Vulnerabilities
- 오프라인 딕셔너리 공격(Offline dictionary attack)
- 특정 계정 공격(Specific account attack): 특정 target user를 정해서, 개인정보도 함께 알아냄
- 주요한 암호 공격(Popular password attack): `1111` 같은
- 단일 사용자에 대한 암호 추측(Password guessing against single user)
- 워크스테이션 하이재킹(Workstation hijacking): 사용자가 잠시 자리를 비운 사이에 명령어 실행
- 사용자 실수 악용(Exploiting user mistakes): URL을 전송하고 접속하여 로그인하라는 식
- 다중 암호 사용 악용(Exploiting multiple password use): 하나의 PW를 여러 사이트에서 사용하는 경우, 취약한 사이트의 정보를 먼저 알아냄
- 전자적 감시(Electronic monitoring): 암호화되지 않고 전송되는 경우

## Countermeasures
- Password file에 대한 무단 접근을 방지하기 위한 통제
- 침입 탐지(Intrusion detection) 조치
- 암호가 유출된 경우 신속한 암호 재발급 조치
- 계정 잠금(Account lockout) 메커니즘: 몇 번 이상 틀린 경우
- 사용자가 흔한, 간단한 암호를 선택하는 것을 금지하는 policy
- 암호 정책에 대한 교육 및 시행
  - 9자 이상
  - 대/소문자, 특수 문자, 숫자 등 포함
- 자동 워크스테이션 로그아웃: 화면 잠금장치 등 통해서
- 네트워크 장치에서 유사한 암호 사용을 금지하는 policy

## Use of Hashed Passwords (in UNIX)
사용자가 암호를 설정하면,  

- Salt라고 하는 random한 값을 함께 concatnate함.
- 시스템은 hash 함수(hash function)를 적용하여 이를 암호화하고, hash값을 저장.
- 이에 따라 ID마다 salt값이 다르게 됨
- 사용자 암호 파일에 저장된 hash된 암호와 비교하여 인증을 수행 - 같으면 login 성공

## How Password Salt Works
- Salt 미사용 시:
    1. 사용자가 사용자 ID X와 암호 P를 입력.
    2. 시스템이 X의 암호에 대한 저장된 hash H를 조회.
    3. 시스템이 $h(P) = H$인지 테스트.
  - 암호 파일: `... X: H ...`
- Salt 사용 시:
    1. 사용자가 사용자 ID X와 암호 P를 입력.
    2. 시스템이 S와 H를 조회. 여기서 S는 사용자 ID X에 대한 무작위 salt(salt)이고 H는 S와 X의 암호를 결합한 값의 저장된 hash.
    3. 시스템이 $h(S||P) = H$인지 테스트.
  - 암호 파일: `... X: S, H ...`

## How Salt Increases Search Space Size
- 공격자가 공격하려는 사용자 ID와 연관된 salt를 찾을 수 없다고 가정하면, salt가 적용된 암호에 대한 딕셔너리 공격의 탐색 공간(search space) 크기는 $2^B \times D$임. 여기서 $B$는 무작위 salt의 비트 수이고 $D$는 딕셔너리 공격을 위한 단어 목록의 크기.
- 예를 들어, 시스템이 각 사용자 ID에 대해 32비트 salt를 사용하고 사용자가 `500,000`단어 dictionary에 있는 password를 선택하는 경우, salt가 적용된 password를 공격하기 위한 탐색 공간은 $2^{32} \times 500,000 = 2,147,483,648,000,000$으로, 이는 약 2천조 이상.
- 공격자가 사용자 ID에 대한 salt password를 찾아내더라도 오직 하나의 password만 알게 됨.

## UNIX Implementation
- 기존 방식(Original scheme)
  - 최대 8개의 printable characters in length
  - DES 암호화를 단방향 hash 함수로 수정하기 위해 12비트 salt 사용
  - `0` 값을 25회 반복적으로 암호화
  - 출력을 11개의 문자 시퀀스로 변환
- 현재는 부적절한 것으로 간주됨.
  - 여전히 기존 계정 관리 소프트웨어나 다중 벤더 환경과의 호환성을 위해 종종 요구됨.

## Improved Implementations
- Unix에서 사용 가능한 훨씬 강력한 hash/salt 방식
- 권장되는 hash 함수는 MD5에 기반함.
  - 최대 48비트의 salt
  - 암호 길이는 무제한
  - 128비트 hash 생성
  - 속도 저하를 위해 1000회 반복되는 내부 루프 사용
- OpenBSD는 Bcrypt라는 Blowfish 블록 암호 기반 hash 알고리즘을 사용
  - Unix hash/salt 방식 중 가장 안전한 버전
  - 128비트 salt를 사용하여 192비트 hash 값 생성

## Password Cracking
- 딕셔너리 공격(Dictionary attacks)
  - 가능한 암호들이 포함된 큰 규모의 사전을 개발하여 암호 파일들에 대해 각각 시도
  - 각 암호는 각 salt값을 사용하여 hash된 후 저장된 hash값과 비교되어야 함.
- 레인보우 테이블 공격(Rainbow table attacks)
  - 모든 salt에 대한 hash 값 테이블을 미리 계산
  - 거대한 hash값 테이블
  - 충분히 큰 salt값과 충분히 긴 hash 길이를 사용하여 대응 가능

## Table 3.2 Passwords Cracked from a Sample Set of 13,797 Accounts
62,727개 단어 규모의 간단한 dictionary를 가지고도 전체 사용자의 24.2%에 해당하는 password를 해킹할 수 있었음.

## Password File Access Control
- 암호화된 암호에 대한 접근을 거부함으로써 오프라인 추측 공격을 차단 가능
- 권한 있는 사용자에게만 접근 허용
- 섀도우 암호 파일(Shadow password file)
  - hash된 암호가 저장되는 사용자 ID와는 별개의 파일
- 취약점
  - 파일 접근을 허용하는 OS의 약점
  - 권한 설정 실수로 파일을 읽을 수 있게 됨
  - 다른 시스템에서 동일한 암호를 사용하는 사용자
  - 백업 미디어로부터의 접근
  - 네트워크 트래픽에서 plain text 암호 스니핑(sniffing)

## Password Selection Techniques
1. 사용자 교육(User education)
    - 사용자에게 "추측하기 어려운" 암호 사용의 중요성을 알리고 강력한 암호 선택을 위한 guideline 제공
2. 컴퓨터 생성 암호(Computer generated passwords)
    - 사용자들이 기억하는 데 어려움을 겪음.
3. 사후 암호 검사(Reactive password checking)
    - 시스템이 주기적으로 자체 암호 cracker를 실행하여 추측 가능한 암호를 찾아냄.
4. 사전 암호 검사(Proactive password checking)
    - 사용자가 자신의 암호를 선택할 수 있도록 허용하지만, 시스템은 암호가 허용 가능한지 확인하고 그렇지 않으면 거부함.
    - 목표는 사용자가 기억하기 쉬운 암호를 선택하도록 허용하면서 추측 가능한 암호를 제거하는 것.

## Proactive Password Checking
- 규칙 강제(Rule enforcement)
  - 암호가 준수해야 하는 특정 규칙
- 암호 크래커(Password cracker)
  - 사용하지 말아야 할 암호의 large dictionary를 compile
- 블룸 필터(Bloom filter)
  - hash를 사용하여 dictionary에 기반한 테이블을 구축하는 데 사용
  - 원하는 암호를 이 테이블과 비교하여 확인

## Bloom Filter
- Bloom filter는 어떤 항목이 특정 집합에 속하는지 여부를 확률적으로 검사하는 데이터 구조
- 각 항목을 여러 hash 함수에 통과시켜 비트 배열의 특정 위치를 1로 설정
- 특정 항목 $w$의 소속 여부를 확인하고자 할 때, 해당 항목을 동일한 hash 함수들로 처리하여 비트 배열의 해당 위치들이 모두 `1`인지 확인 모두 `1`이면 해당 항목은 집합에 속할 가능성이 높다고 판단
- False Negative = 0
- False Positive > 0 (약간 있음)

## Password Security – Login Scoring
- Login Scoring
  - 요청 데이터:
    - IP 주소(및 파생된 국가, ISP 등)
    - 브라우저의 사용자 에이전트(user agent)(및 OS, 버전 등)
    - 타임스탬프
    - 쿠키
  - Reputation scores(평판 점수)
    - 이전에 관찰된 공격 IP
  - 전역 카운터
    - ISP 또는 국가 수준 데이터 사용
  - 회원의 이전 (성공적인) 로그인 기록
- 사용자별 공격 데이터는 없음

> 일정 스코어 이상이면 바로 login 되지만, 그렇지 않은 경우에는 추가 인증을 요구하는, 기존의 패턴과 유사한 패턴인지를 score로 매기는 방식

## Table 3.3 Types of Cards Used as Tokens
| 카드 유형 | 정의적 특징 | 예시 |
| :--- | :--- | :--- |
| Embossed (엠보싱) | 전면에만 양각 문자 | 구형 신용카드 |
| Magnetic stripe (마그네틱 스트립) | 뒷면의 마그네틱 바, 전면의 문자 | 은행 카드 |
| Memory (메모리) | 내부에 전자 메모리 | 선불 전화카드 |
| Smart (스마트) <br> - Contact (접촉식) <br> - Contactless (비접촉식) | 내부에 전자 메모리 및 프로세서 <br> 표면에 노출된 전기 접점 <br> 내부에 내장된 radio 안테나 | 생체 인식 ID 카드 |

## Memory Cards 메모리 카드
- 데이터를 저장할 수는 있지만 처리하지는 못함.
- 가장 흔한 것은 마그네틱 스트립 카드(magnetic stripe card).
- 내부 전자 메모리를 포함할 수 있음.
- 물리적 접근에 단독으로 사용 가능
  - 호텔 룸
  - ATM 기계
- 암호나 PIN과 결합될 때 훨씬 더 높은 보안을 제공 (분실할 수도 있기 때문)
- 메모리 카드의 단점:
  - special한 reader 필요
  - 토큰 분실
  - 사용자 불만족

## Smartcard 스마트 카드
- 물리적 특징
  - 내장된 마이크로프로세서(microprocessor) 포함, 약간의 계산 요구
  - 은행 카드처럼 생긴 스마트 토큰
  - 계산기, 열쇠, 작은 휴대용 물체처럼 보일 수 있음.
- 인터페이스
  - 수동 인터페이스는 상호작용을 위한 키패드와 디스플레이를 포함
  - 전자 인터페이스는 호환되는 reader/writer와 통신
- 인증 프로토콜
  - 정적, 동적 암호 생성기, 챌린지-응답(challenge-response)의 세 가지 범주로 분류

## Figure 3.3 Smart Card Dimensions
> 스마트 카드 칩은 내부적으로 CPU, crypto coprocessor, RAM, ROM, 전기 신호를 가지고 칩을 동작하게 하여 계산하도록 함.

## Figure 3.4 Communication Initialization between a Smart Card and a Reader
- reader가 접점을 활성화하면, 스마트 카드는 ATR(Answer to Reset)을 전송함.
- 그 후, reader는 명령을 보내고 스마트 카드는 명령을 실행한 뒤 응답을 보냄.
- 출처: [TUNS06] 기반.

## Biometric Authentication
- 고유한 신체적 특성에 기반하여 개인을 인증하려는 시도
- 패턴 인식(pattern recognition)에 기반함.
- 암호 및 토큰에 비해 기술적으로 복잡하고 비용이 많이 듦.
- 사용되는 신체적 특징:
  - 얼굴 특징
  - 지문
  - 손 모양
  - 망막(Retina) 패턴
  - 홍채(Iris)
  - 서명
  - 음성

## Figure 3.5 Cost Versus Accuracy
- 이 graph는 다양한 인증 방법의 비용과 정확도 간의 관계를 보여줌.
- Iris는 정확도와 비용 모두 높음 - 군사적 목적으로 사용
- Finger, Retina도 정확성 측면에서 높음.

## Figure 3.6 Operation of a Biometric System
- 일반적인 생체 인식 시스템의 작동 방식
  - Enrollment(등록)
  - Verification(인증) - 정확히 같은 값이 나오지는 않음, 따라서 어느 정도의 유사도가 나오면 인증 성공으로 간주해 주어야 함.
  - Identification(식별)

## Biometric Accuracy
- 오거부율(FRR, False Reject Rate): 정상적인 사용자가 거부될 확률
- 오인식률(FAR, False Accept Rate): 비정상적인 사용자가 승인될 확률
- 두 분포 곡선이 교차하는 지점을 교차 에러율(CER, Crossover Error Rate) 또는 등가 에러율(EER, Equal Error Rate)이라 함.
  - 이 지점에서 FRR과 FAR이 같아짐.

## Biometric Measurement Operating Characteristic Curves
- ROC(Receiver Operating Characteristic) 곡선은 결정 임계값(decision threshold)이 변함에 따라 FAR과 FRR 간의 상충 관계를 보여줌.
- 이상적인 시스템은 곡선이 왼쪽 하단 모서리에 가까움(FAR과 FRR이 모두 0에 가까움).
- EER은 곡선이 $FAR = FRR$인 선과 교차하는 지점.

## Actual Biometric Measurement Operating Characteristic Curves
- 이 그래프는 지문, 얼굴, 음성에 대한 실제 ROC 곡선을 보여줌.
- 지문 인식의 경우 false match rate를 낮추더라도 false nonmatch rate가 크게 높아지지 않음
- Iris의 경우 높은 정확도로 군사적 목적으로 사용

## Remote User Authentication
- 네트워크, 인터넷 또는 통신 링크를 통한 인증은 더 복잡함.
- 다음과 같은 추가적인 보안 위협 존재:
  - 도청(eavesdropping), 암호 캡쳐, 관찰된 인증 시퀀스 재전송(replaying)
- 일반적으로 위협에 대응하기 위해 어떤 형태의 challenge-response 프로토콜에 의존함.

## Figure 3.10a Password Protocol
챌린지-응답 프로토콜의 예시
- 사용자는 원격 호스트에 신원을 전송
- 호스트는 임의의 숫자(논스, nonce)를 생성
- nonce가 사용자에게 return됨
- 사용자는 nonce와 암호 hash를 입력으로 하는 함수를 계산하여 결과를 host에 전송
- 호스트는 암호의 hash 코드를 저장
- 암호 hash가 인자 중 하나인 함수
- 임의의 숫자를 사용하면 공격자가 사용자 전송을 캡처하는 것에 대해 방어하는 데 도움이 됨.

## Figure 3.10c Static Biometric Protocol
- 정적 생체 인식 프로토콜의 예시
- 사용자는 호스트에 ID를 전송
- 호스트는 임의의 숫자와 암호화를 위한 식별자로 응답
- 클라이언트 시스템은 사용자 측의 생체 인식 장치를 제어
- 클라이언트는 생체 정보를 캡처하여 임의의 숫자로 암호화한 후 호스트에 전송
- 호스트는 수신 메시지를 해독(decrypt)하고 로컬에 저장된 값과 비교
- 호스트는 수신된 장치 ID를 호스트 데이터베이스에 등록된 장치 목록과 비교하여 인증을 제공

## Authentication Security Issues
- 도청(Eavesdropping)
  - 공격자가 사용자와의 물리적 근접성을 포함하는 어떤 종류의 공격으로 암호를 알아내려는 시도
- 호스트 공격(Host attacks)
  - 암호, 토큰 패스코드 또는 생체 인식 템플릿이 서버에 저장된 호스트의 사용자 파일을 대상으로 함
- 재전송(Replay)
  - 공격자가 이전에 캡처한 사용자 응답을 반복하여 전송하는 공격
- 클라이언트 공격(Client attacks)
  - 공격자가 원격 호스트나 중간 통신 경로에 접근하지 않고 사용자 인증을 달성하려는 시도
- 트로이 목마(Trojan horse)
  - 사용자 암호, 패스코드 또는 생체 인식을 캡쳐할 목적으로 진짜 애플리케이션이나 device인 것처럼 위장하는 애플리케이션 또는 물리적 device
- 서비스 거부(Denial-of-service)
  - 수많은 인증 시도로 사용자 인증 서비스를 마비시키려는 시도

## Practical Application: Iris Biometric System
홍채 인식 기술을 활용한 login 시스템의 실제 적용 사례

## Cloud Security using User Authentication
- 에이전트 없는 사용자 인증(네트워크 기반)
  - 네트워크 트래픽이 정상인가? -> 주기적 요청 -> 네트워크 트래픽
- 에이전트 기반 사용자 인증(Challenge-response 기반)
  - 사용자 패턴이 정상인가? -> 정상이 아니면, 사용자를 다시 확인하기 위해 챌린지를 만들어 전송! -> 챌린지(이벤트) -> 응답(행동 패턴) -> 현재 행동 패턴

## Continuous Authentication
- 프레임워크
  Initial Login Authentication -> Continuous Authentication <-> Enrollment Temlate Update <-> Re-login Authentication
- 생체인식(Biometrics)
  - 소프트 생체인식(Soft biometric)
    - "개인에 대한 일부 정보를 제공하지만, 두 개인을 충분히 구별할 수 있는 독특함이 부족한 특성"으로 정의됨.
    - 예: 성별, 민족, 눈/피부/머리 색깔, 키, 몸무게 등
  - 하드 생체인식(Hard biometric)
    - 예: 지문, 얼굴, 홍채, 손바닥 정맥

## Continuous Authentication - Examples
- PC의 웹캠(Web-CAM) 사용
  - 얼굴이나 옷차림 등
- 모바일 장치의 센서 사용
  - 수많은 sensor들이 있고, 이 정보를 수집하여 판단
  - Mobile device의 가속도계(accelerometer) 사용
  - 서로 다른 두 사람(Person A, Person B)의 걸음걸이에서 측정된 가속도계 데이터(x, y, z축)는 뚜렷하게 다른 패턴을 보임.

## Authentication System
- 사용자 등록(학습/Modeling) 과정
  1. 사용자 데이터 추출
  2. 특징 계산
  3. 특징 DB에 저장
  4. 저장된 특징 DB로 랜덤 포레스트(Random Forest) 모델 학습
- 사용자 인증(Testing) 과정
  1. 사용자 데이터 추출
  2. 특징 계산
  3. 특징을 분류 모델(예: 랜덤 포레스트)을 사용하여 예측
  4. 현재 사용자인지 여부에 따라 인증 성공 또는 실패 결정

## Summary
- 사용자 신원 인증의 네 가지 수단
  - 개인이 아는 것
  - 개인이 소유한 것
  - 개인의 존재
  - 개인이 하는 행동
- 암호의 취약점
  - 오프라인 dictionary attack, 특정 계정 공격, 인기 있는 암호 공격, 단일 사용자에 대한 암호 추측, 워크스테이션 하이재킹, 사용자 실수 악용, 다중 암호 사용 악용, 전자적 감시
- hash된 암호와 salt값
- 암호 파일 접근 제어
- 암호 선택 전략
  - 사용자 교육
  - 컴퓨터 생성 암호
  - 사후 암호 검사
  - 사전 암호 검사
  - 블룸 필터
- 토큰 기반 인증
  - 메모리 카드
  - 스마트 카드
- 생체 인식 인증
- 원격 사용자 인증
  - 암호 프로토콜
  - 토큰 프로토콜
  - 정적 생체 인식 프로토콜
  - 동적 생체 인식 프로토콜