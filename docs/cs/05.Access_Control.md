# 5. Access Control

## Access Control

- ITU-T Recommendation X.800은 접근 제어(access control)를 다음과 같이 정의함.
- "자원의 무단 사용 방지를 포함하여, 승인되지 않은 방식으로 자원을 사용하는 것을 방지하는 것"

## Access Control Principles

- RFC 2828은 컴퓨터 보안을 다음과 같이 정의함.
- "컴퓨터 시스템에서 보안 서비스를 구현하고 보증하는 조치, 특히 접근 제어 서비스를 보증하는 조치"

## Relationship Among Access Control and Other Security Functions

- 접근 제어는 인증(authentication) 및 감사(audit)와 밀접하게 관련됨.
- 인증은 사용자의 신원을 확인하고, 접근 제어는 확인된 사용자가 특정 자원에 접근할 수 있는지 여부를 결정함.
- 감사 기능은 접근 시도를 기록하여 보안 정책 준수 여부를 확인하고 침입을 탐지함.

## Access Control Policies

- 임의 접근 제어(Discretionary Access Control, DAC): 자원의 소유자가 다른 주체에 대한 접근 권한을 설정
- 강제 접근 제어(Mandatory Access Control, MAC): 시스템 전반의 정책에 따라 접근 권한이 중앙에서 관리됨.
- 역할 기반 접근 제어(Role-Based Access Control, RBAC): 사용자의 조직 내 역할에 따라 접근 권한을 부여
- 속성 기반 접근 제어(Attribute-based Access Control, ABAC): 주체, 객체, 환경의 속성에 기반한 정책을 통해 접근을 제어

## Access Control Requirements

- 신뢰할 수 있는 입력(Reliable input)
- 세밀하고 포괄적인 명세 지원(Support for fine and coarse specifications)
- 최소 권한(Least privilege)
- 직무 분리(Separation of duty)
    - 하나의 작업을 완료하기 위해 두 명 이상이 필요함.
- 개방 및 폐쇄 정책(Open and closed policies)
- 정책 조합 및 충돌 해결(Policy combinations and conflict resolution)
- 관리 정책(Administrative policies)
    - 정책 개발 절차 등

## Access Control Basic Elements

- 주체(Subject): 객체에 접근할 수 있는 개체
    - 본래 프로세스(process)의 개념과 동일
    - 일반적으로 자신이 시작한 행동에 대해 책임이 있음.
    - 종종 소유자(owner), 그룹(group), 월드(world)의 세 가지 클래스를 가짐.
- 객체(Object): 접근이 통제되는 자원
    - 정보를 포함 및/또는 수신하는 데 사용되는 개체
    - 보호는 접근 제어가 작동하는 환경에 따라 달라짐.
- 접근 권한(Access right): 주체가 객체에 접근하는 방식을 기술
    - 예: 읽기(read), 쓰기(write), 실행(execute), 삭제(delete), 생성(create), 검색(search)

## Mandatory Access Control

- 강제 접근 제어(MAC)는 더 제한적인 방식임.
- 소유권과 관계없이 사용자가 파일에 대한 권한을 정의하는 것을 허용하지 않음.
- 대신, 보안 결정은 중앙 정책 관리자에 의해 이루어짐.
- 각 보안 규칙은 접근을 시도하는 당사자를 나타내는 주체, 접근 대상 자원을 가리키는 객체, 그리고 해당 자원에 접근할 수 있는 범위를 정의하는 일련의 권한으로 구성됨.
- SELinux(Security-Enhanced Linux)는 강제 접근 제어를 통합함.

## SELinux and MAC

- 모든 프로세스와 시스템 자원은 SELinux 컨텍스트(SELinux context, 또는 SELinux 레이블)라는 특별한 보안 레이블을 가짐.
- SELinux 정책은 이 컨텍스트를 일련의 규칙에서 사용하여 프로세스가 서로 및 다양한 시스템 자원과 상호 작용하는 방식을 정의함.
- 기본적으로, 정책은 규칙이 명시적으로 접근을 허용하지 않는 한 어떠한 상호 작용도 허용하지 않음.
- SELinux 컨텍스트는 사용자(user), 역할(role), 유형(type), 보안 수준(security level) 등 여러 필드를 가짐.
- 가장 일반적인 정책 규칙이 전체 SELinux 컨텍스트가 아닌 SELinux 유형을 사용하기 때문에 SELinux 유형 정보가 SELinux 정책에서 가장 중요할 수 있음.

## Discretionary Access Control (DAC)

- 한 개체가 다른 개체에게 일부 자원에 접근할 수 있도록 허용하는 방식
- 종종 접근 행렬(access matrix)을 사용하여 제공됨.
    - 한 차원은 자원에 대한 데이터 접근을 시도할 수 있는 식별된 주체로 구성됨.
    - 다른 차원은 접근될 수 있는 객체를 나열함.
- 행렬의 각 항목은 특정 주체가 특정 객체에 대해 갖는 접근 권한을 나타냄.

## Access Matrix

- 행은 주체(사용자, 프로세스)를 나타내고 열은 객체(파일, 장치)를 나타냄.
- 행렬의 각 셀 $(i, j)$는 주체 $i$가 객체 $j$에 대해 가질 수 있는 접근 권한(예: 읽기, 쓰기, 소유)을 명시함.

## Example of Access Control Structures

- 접근 행렬(Access Matrix): 주체와 객체 간의 모든 권한을 표로 나타냄.
- 접근 제어 목록(Access Control Lists, ACLs): 객체 중심. 각 객체에 대해 어떤 주체가 어떤 권한을 갖는지 목록으로 관리 (접근 행렬의 열에 해당).
- 능력 목록(Capability Lists): 주체 중심. 각 주체가 어떤 객체에 대해 어떤 권한을 갖는지 목록으로 관리 (접근 행렬의 행에 해당).

## Extended Access Control Matrix

- 기존 접근 행렬을 확장하여 조건부 접근 제어를 포함할 수 있음.
- 예를 들어, 특정 주체가 객체에 대한 권한을 다른 주체에게 복사(Copy)하거나 소유권(Owner)을 이전하는 권한, 또는 접근을 감사(Audit)하는 권한 등을 추가로 명시.

## Access Control Function

- 사용자가 객체에 대한 접근을 요청하면, 접근 제어 기능(Access Control Function)이 요청을 가로챔.
- 이 기능은 접근 제어 정책(Access Control Policy)을 참조하여 요청을 허용(Grant)할지 거부(Deny)할지 결정함.
- 결정 결과는 감사 파일(Audit File)에 기록될 수 있음.

## Table 4.2 Access Control System Commands

| 명령 | 설명 |
| :--- | :--- |
| `grant(subject, right, object)` | 주체에게 객체에 대한 권한을 부여 |
| `revoke(subject, right, object)` | 주체로부터 객체에 대한 권한을 회수 |
| `create(subject, object)` | 주체가 객체를 생성. 생성자는 소유자가 됨. |
| `delete(subject, object)` | 주체가 객체를 삭제. 소유자만 가능. |
| `read(subject, attribute, object)` | 주체가 객체의 속성을 읽음. |
| `write(subject, attribute, object)` | 주체가 객체의 속성을 변경. 소유자만 가능. |

## Protection Domains

- 객체와 그 객체에 대한 접근 권한의 집합
- 보호 도메인(protection domains)과 능력을 연관시킬 때 더 큰 유연성을 제공
- 접근 행렬 측면에서, 한 행은 보호 도메인을 정의함.
- 사용자는 자신의 접근 권한의 일부를 가진 프로세스를 생성할 수 있음.
- 프로세스와 도메인 간의 연관은 정적이거나 동적일 수 있음.
- 사용자 모드(user mode)에서는 특정 메모리 영역이 사용으로부터 보호되며 특정 명령어는 실행될 수 없음.
- 커널 모드(kernel mode)에서는 특권 명령어가 실행될 수 있으며 보호된 메모리 영역에 접근할 수 있음.

## UNIX File Access Control

- UNIX 파일은 아이노드(i-nodes, index nodes)를 사용하여 관리됨.
    - 특정 파일에 필요한 주요 정보가 있는 제어 구조
    - 여러 파일 이름이 단일 아이노드와 연관될 수 있음.
    - 활성 아이노드는 정확히 하나의 파일과 연관됨.
    - 파일 속성, 권한 및 제어 정보는 아이노드에 저장됨.
    - 디스크에는 파일 시스템의 모든 파일의 아이노드를 포함하는 아이노드 테이블 또는 아이노드 목록이 있음.
    - 파일이 열리면 해당 아이노드가 주 메모리로 가져와져 메모리 상주 아이노드 테이블에 저장됨.
- 디렉터리는 계층적 트리 구조로 구성됨.
    - 파일 및/또는 다른 디렉터리를 포함할 수 있음.
    - 파일 이름과 연관된 아이노드를 가리키는 포인터를 포함함.
- 고유 사용자 식별 번호 (사용자 ID, user ID)
- 그룹 ID로 식별되는 주 그룹의 멤버
- 특정 그룹에 속함.
- 12개의 보호 비트
    - 파일의 소유자, 그룹 멤버, 그리고 다른 모든 사용자에 대한 읽기, 쓰기, 실행 권한을 명시
- 소유자 ID, 그룹 ID, 보호 비트는 파일의 아이노드의 일부임.

## Traditional UNIX File Access Control

- `set user ID`(SetUID)
- `set group ID`(SetGID)
    - 시스템이 접근 제어 결정을 내릴 때 실제 사용자의 권한에 더하여 파일 소유자/그룹의 권한을 일시적으로 사용함.
    - 특권 프로그램이 일반적으로 접근할 수 없는 파일/자원에 접근할 수 있게 함.
- 스티키 비트(Sticky bit)
    - 디렉터리에 적용될 때, 해당 디렉터리 내의 파일 소유자만이 파일을 재명명, 이동 또는 삭제할 수 있도록 지정함.
- 슈퍼유저(Superuser)
    - 일반적인 접근 제어 제한에서 제외됨.
    - 시스템 전반에 걸친 접근 권한을 가짐.

## Access Control Lists (ACLs) in UNIX

- 현대 UNIX 시스템은 ACL을 지원함.
    - FreeBSD, OpenBSD, Linux, Solaris
- FreeBSD
    - `setfacl` 명령은 UNIX 사용자 ID 및 그룹의 목록을 할당함.
    - 파일에 임의의 수의 사용자 및 그룹을 연관시킬 수 있음.
    - 읽기, 쓰기, 실행 보호 비트
    - 파일이 ACL을 가질 필요는 없음.
    - 파일에 확장 ACL이 있는지 여부를 나타내는 추가 보호 비트를 포함함.
- 프로세스가 파일 시스템 객체에 접근을 요청할 때 두 단계가 수행됨.
    1. 가장 적절한 ACL을 선택 (소유자, 지정된 사용자, 소유 그룹/지정된 그룹, 기타)
    2. 일치하는 항목에 충분한 권한이 포함되어 있는지 확인

## Role-Based Access Control (RBAC)

- 사용자는 역할을 할당받고, 역할은 권한을 할당받는 구조.
- 사용자-역할, 역할-권한 관계를 통해 접근 제어를 관리함.
- 사용자는 세션(session) 내에서 특정 역할을 활성화하여 해당 역할에 부여된 권한을 행사함.

## Role-Based Access Control Models

- RBAC는 여러 모델로 구성되며, 계층적 구조를 가질 수 있음.
1. 핵심 RBAC (Core RBAC): 사용자, 역할, 권한, 세션의 기본 요소를 정의
2. 계층적 RBAC (Hierarchical RBAC): 역할 간의 상속 관계를 지원하여 권한 관리의 효율성을 높임.
3. 정적 직무 분리 RBAC (Static Separation of Duty RBAC): 상호 배타적인 역할을 정의하여 이해 상충을 방지함.
4. 동적 직무 분리 RBAC (Dynamic Separation of Duty RBAC): 한 세션 내에서 활성화될 수 있는 역할들을 제한함.

## Constraints - RBAC

- 조직의 행정 및 보안 정책의 특수성에 RBAC를 적용하는 수단을 제공
- 역할 간의 정의된 관계 또는 역할과 관련된 조건
- 유형:
    - 상호 배타적 역할(Mutually exclusive roles)
        - 사용자는 (세션 동안 또는 정적으로) 집합 내의 한 역할에만 할당될 수 있음.
        - 모든 권한(접근 권한)은 집합 내의 한 역할에만 부여될 수 있음.
    - 카디널리티(Cardinality)
        - 역할과 관련하여 최대 수를 설정
    - 선행 조건 역할(Prerequisite roles)
        - 사용자가 특정 다른 역할에 이미 할당된 경우에만 특정 역할에 할당될 수 있음을 지시

## RBAC: Basic Definitions

- 객체(Object)
    - 파일, 프린터, 터미널, 데이터베이스 레코드 등 접근 제어의 대상이 되는 모든 시스템 자원
- 연산(Operation)
    - 프로그램의 실행 가능한 이미지로, 호출 시 사용자를 위해 일부 기능을 실행
- 권한(Permission)
    - 하나 이상의 RBAC 보호 객체에 대해 연산을 수행하는 것에 대한 승인

## Core RBAC

- 관리 기능(Administrative functions)
    - 사용자 집합에서 사용자 추가 및 삭제
    - 역할 집합에서 역할 추가 및 삭제
    - 사용자-역할 할당 인스턴스 생성 및 삭제
    - 권한-역할 할당 인스턴스 생성 및 삭제
- 지원 시스템 기능(Supporting system functions)
    - 기본 활성 역할 집합으로 사용자 세션 생성
    - 세션에 활성 역할 추가
    - 세션에서 역할 삭제
    - 세션 주체가 요청된 연산을 객체에 대해 수행할 권한이 있는지 확인
- 검토 기능(Review functions)
    - 관리자가 모델의 모든 요소와 그 관계를 수정하지 않고 볼 수 있게 함.

## Static Separation of Duty Relations (SSD)

- 한 사용자가 집합 내의 한 역할에 할당되면, 해당 집합의 다른 어떤 역할에도 할당될 수 없도록 하는 상호 배타적인 역할 집합의 정의를 가능하게 함.
- 역할 집합에 카디널리티 제약을 둘 수 있음.
    - (역할 집합, n) 쌍으로 정의되며, 어떤 사용자도 해당 역할 집합에서 n개 이상의 역할에 할당되지 않음.
- 역할 집합 생성 및 삭제, 역할 멤버 추가 및 삭제를 위한 관리 기능을 포함함.
- 기존 SSD 집합의 속성을 보기 위한 검토 기능을 포함함.

## Dynamic Separation of Duty Relations (DSD)

- 사용자에게 가용한 권한을 제한함.
- 사용자 세션 내에서 또는 세션 간에 활성화될 수 있는 역할에 제약을 둠.
- 제약은 (역할 집합, n) 쌍으로 정의되며, 여기서 n은 자연수 $n \geq 2$이고, 어떤 사용자 세션도 역할 집합에서 n개 이상의 역할을 활성화할 수 없는 속성을 가짐.
- 관리자가 사용자에 대해 서로 다른, 겹치지 않는 시간대에 특정 능력을 지정할 수 있게 함.
- DSD 관계를 정의하고 보기 위한 관리 및 검토 기능을 포함함.

## Example of Access Control Administration

- RBAC 환경에서는 관리 역할이 사용자-역할 할당 및 권한-역할 할당을 관리함.
- 예를 들어, '사용자 관리자' 역할은 사용자에게 역할을 할당하고, '권한 관리자' 역할은 역할에 권한을 할당하는 작업을 수행함.

## Attribute-based Access Control (ABAC)

- 속성을 함께 결합하는 정책에 기반함.
    - 사용자 속성, 자원 속성, 환경 속성 등
    - 예) 나이, 역할, 직함 등 / 읽기, 삭제, 보기 등 / 객체 유형 등
- 다양한 속성을 평가할 수 있는 복잡한 불리언(Boolean) 규칙 집합을 표현할 수 있음.
- 예시
    - 정책: 관리자는 자신의 지역 내 거래를 볼 수 있음.
    - 규칙: `user.role == manager`인 사용자는 `user.region == transaction.region`인 경우 `TRANSACTIONS` 테이블에 대해 `SELECT` 작업을 수행할 수 있음.