# 14. Indexing
- Indexing: 원하는 데이터에 대한 접근 속도를 높이는 데 사용되는 메커니즘
- Search Key: 파일에서 레코드를 찾는 데 사용되는 속성 또는 속성 집합
- Index file은 search-key와 pointer(s)($\text{Block pointer, offset}$) 형태의 레코드라 불림)로 구성
- 인덱스 파일은 일반적으로 원본 데이터 파일보다 훨씬 작음
- 두 가지 기본 인덱스 종류
  - Ordered indices: search key가 정렬된 순서로 저장
  - Hash indices: search key가 hash function을 사용하여 "buckets"에 균일하게 분산
- Index evaluation metrics
  - 효율적으로 지원되는 Access types
    - Point queries: search key에 대해 지정된 값을 갖는 레코드
    - Range queries: search key 값이 지정된 범위 내에 있는 레코드
  - 데이터 레코드에 대한 Access/Insertion/Deletion times
  - Space overhead

## Ordered Indices
- Ordered index: index entries가 search key 값에 따라 정렬되어 저장
- Clustering index
  - Sequentially ordered data file에서, search key가 데이터 파일의 순차적 순서도 정의하는 인덱스
  - Primary index라고도 함
  - 기본 인덱스의 search key는 일반적으로 primary key이지만, 필수는 아님
- Secondary index
  - search key가 데이터 파일의 순차적 순서와 다른 순서를 지정하는 인덱스
  - Nonclustering index라고도 함
- Index-sequential file
  - search key를 기준으로 정렬된 Sequential data file에, search key에 대한 clustering index가 있는 파일

## Dense Index
- Dense index: 데이터 파일의 모든 search-key 값에 대해 index entry가 나타남

## Sparse Index
- Sparse Index: 일부 search-key 값에 대해서만 index entries를 포함
- 레코드가 search key를 기준으로 순차적으로 정렬되어 있을 때 적용 가능
- search-key 값 $K$를 가진 레코드를 찾으려면
  - $K$보다 작거나 같은 search-key 값 중 가장 큰 값을 가진 index entry를 찾음
  - 해당 index record가 가리키는 레코드에서부터 파일 순차 검색
  - Dense indices와 비교
    - 데이터 레코드의 insertion 및 deletion에 대해 Less space and less maintenance overhead
    - 일반적으로 레코드를 찾는 데 Dense index보다 slower
  - Access time과 space overhead 사이의 trade-off
  - Good compromise
    - Clustering index의 경우: 파일의 모든 block에 대해 index entry를 가진 sparse index. 해당 block에서 least search-key value에 해당
    - Note: Query processing의 주요 비용은 block I/O time; 메모리 내 블록 스캐닝 시간은 negligible
    - 이 방식은 dense index와 동일한 수의 block I/O를 가지면서도 space overhead가 훨씬 적음

## Multilevel Index
- Index가 메모리에 맞지 않으면, access가 expensive
- Solution: Multilevel Index
  - 디스크에 보관된 인덱스를 sequential file로 취급하고 그 위에 sparse index를 구축
  - Outer index: basic index의 sparse index
  - Inner index: basic index file
  - Outer index조차 너무 커서 메인 메모리에 맞지 않으면, 또 다른 level의 index 생성 가능
- 모든 level의 indices는 파일에서의 insertion 또는 deletion 시에 updated되어야 함

## Index Update: Insertion
- Index는 database modification에 오버헤드를 부과
  - 레코드가 삽입 또는 삭제될 때, 관계형의 모든 인덱스가 갱신되어야 함
  - 레코드가 갱신될 때, 갱신된 속성에 대한 모든 인덱스가 갱신되어야 함
- Index update upon insertion: 1) Dense indices
  - 삽입되는 레코드의 search-key 값을 사용하여 lookup 수행
  - search-key 값이 인덱스에 나타나지 않으면, insert
  - search-key 값이 인덱스에 나타나면
    - 인덱스 엔트리가 동일한 search-key 값을 가진 모든 레코드에 대한 pointers를 저장하는 경우, 새로운 레코드에 대한 pointer를 add
    - 그렇지 않은 경우, 인덱스 엔트리가 해당 search-key 값을 가진 첫 번째 레코드에 대한 pointer만 저장. 새로운 레코드를 동일한 search-key 값을 가진 다른 레코드들 뒤에 배치
  - Indices는 sequential files로 유지 관리 됨 $\to$ 새로운 엔트리를 위한 space를 생성해야 하며, overflow blocks이 필요할 수 있음
- Index update upon insertion: 2) Sparse indices
  - 삽입되는 레코드의 search-key 값을 사용하여 lookup 수행
  - 인덱스가 파일의 각 블록에 대한 엔트리를 저장하는 경우, unless 인덱스를 수정할 필요가 없음
    - 새로운 block이 생성되는 경우: 새로운 블록의 first search-key value이 인덱스에 삽입됨
    - 새로운 레코드가 블록에서 least search-key value를 가지는 경우: 블록을 가리키는 index entry를 update

## Index Update: Deletion
- Index update upon deletion: 1) Dense indices
  - (Case 1) 삭제된 레코드가 해당 search-key 값을 가진 파일 내 유일한 레코드인 경우, 인덱스에서도 search-key가 deleted됨
  - 그렇지 않은 경우
    - 인덱스 엔트리가 동일한 search-key 값을 가진 모든 레코드에 대한 pointers를 저장하는 경우, 삭제된 레코드에 대한 pointer를 delete
    - 그렇지 않은 경우, 인덱스 엔트리가 해당 search-key 값을 가진 첫 번째 레코드에 대한 pointer만 저장
      - (Case 2) 삭제된 레코드가 해당 search-key 값을 가진 첫 번째 레코드인 경우, 인덱스 엔트리를 update하여 다음 레코드를 가리키도록 함
      - (Case 3) 그렇지 않은 경우, 인덱스 갱신은 required
- Index update upon deletion: 2) Sparse indices
  - (Case 1) 인덱스가 삭제된 레코드의 search-key 값과 일치하는 index entry를 포함하지 않는 경우, do nothing
  - 그렇지 않은 경우
    - (Case 2) 삭제된 레코드가 해당 search-key를 가진 유일한 레코드인 경우, index entry를 파일에서 next search-key value로 replace
      - 다음 search-key 값이 이미 index entry를 가지고 있다면, 해당 엔트리는 deleted됨
    -) 그렇지 않은 경우, search-key 값에 대한 index entry가 삭제된 레코드를 가리키는 경우, 인덱스 엔트리를 update하여 동일한 search-key 값을 가진 next record를 가리키도록 함

## Secondary Indices: An example
- `instructor` 파일의 `salary` 필드에 대한 Secondary index)
- Index record는 해당 특정 search-key 값을 가진 모든 실제 레코드에 대한 pointers를 포함하는 bucket을 가리킴
- Secondary indices는 dense해야 함
- Index update 과정은 clustering index의 dense index 경우와 동일
- Secondary(nonclustering) index를 사용한 Sequential scan은 HDD에서 expensive
  - 각 레코드 접근 시 디스크에서 새로운 block을 가져와야 할 수 있음

## Indices on Multiple Keys
- Composite search key: 두 개 이상의 속성을 포함하는 search key
  - E.g., `instructor` relation의 속성 `(name, ID)`에 대한 인덱스
- 값은 lexicographically 정렬됨
  - E.g. $(\text{John}, 12121) < (\text{John}, 13514)$ 및 $(\text{John}, 13514) <(\text{Peter}, 11223)$
- `name`만으로 쿼리하거나, `(name, ID)`로 쿼리 가능

# B $^+$-Tree(and B-Tree) Index Files

## B $^+$-Tree Index Files
- Index-sequential file organization의 Disadvantage
  - 파일이 커짐에 따라 overflow blocks이 많이 생성되어 성능 저하
  - 비용이 많이 들고 주기적인 전체 파일 reorganization이 필요
- B $^+$-tree index structure의 Advantage
  - Insertion 및 deletion 시 small, local changes로 자동으로 self-reorganizes
  - 성능 유지를 위해 전체 파일의 reorganization이 필요하지 않음
- B $^+$-trees의(Minor) disadvantage 단점)
  - Extra insertion and deletion overhead, space overhead
- B $^+$-trees의 장점이 단점보다 크기 때문에 extensively 사용됨
- B $^+$-tree는 다음 속성을 만족하는 rooted tree
  - Root에서 leaf까지의 모든 경로는 길이가 같음: Balanced tree
  - Root나 leaf가 아닌 각 node)는 $\lceil n/2 \rceil$와 $n$ 사이의 children을 가짐
    - At least $\lceil n/2 \rceil$ and at most $n$ children(pointers)
  - Leaf node는 $\lceil(n-1)/2 \rceil$와 $n-1$ 사이의 values을 가짐
    - At least $\lceil(n-1)/2 \rceil$ and at most $n-1$ values(not pointers)
  - Special cases
    - Root가 leaf가 아닌 경우, at least 2 children을 가짐
    - Root가 leaf인 경우, 0과 $n-1$ 사이의 values를 가질 수 있음
- B $^+$-tree는 multilevel index이지만, multilevel index-sequential file과는 다른 구조를 가짐

## B $^+$-Tree Node Structure
- Typical node
    | $P_1$ | $K_1$ | $P_2$ | ... | $P_{n+1}$ | $K_{n + 1}$ | $P_n$
    | - | - | - | - | - | - | -
  - $K_i$는 search-key values
  - $P_i$는 children 또는 records/buckets of records에 대한 pointers
  - Note: 최대 $n$개의 pointers와 $n-1$개의 key values가 있을 수 있음
  - 노드 내의 search-keys는 ordered: $K_1 < K_2 < K_3 < \dots < K_{n-1}$

## Leaf Nodes in B $^+$-Trees
- Leaf node의 Properties
  - $i =1,~2,~\dots,~n-1$에 대해, pointer $P_i$는 search-key value $K_i$를 가진 file record를 가리킴
  - $L_i$와 $L_j$가 leaf nodes이고 $i < j$인 경우, $L_i$의 search-key values는 $L_j$의 search-key values보다 작음
  - $P_n$은 search-key order로 next leaf node를 가리킴
  - 순차 처리를 신속하게 하기 위해 모든 leaf nodes를 search-key order로 Chain together
  - B $^+$-tree index가 dense index로 사용되는 경우, 모든 search-key value가 일부 leaf node에 나타나야 함. 그러나 non-leaf node에 나타나는 search-key는 레코드 삭제로 인해 leaf node에 나타나지 않을 수 있음

## Non-Leaf Nodes in B $^+$-Trees
- Non-leaf nodes는 leaf nodes에 대한 multi-level sparse index를 형성
- $n$개의 pointers를 가진 non-leaf node의 경우
  - $P_1$이 가리키는 subtree의 All search-keys는 $K_1$보다 작음
  - $2 \leq i \leq n-1$에 대해, $P_i$가 가리키는 subtree의 All search-keys는 $K_{i-1}$보다 크거나 같고 $K_i$보다 작음
  - $P_n$이 가리키는 subtree의 All search-keys는 $K_{n-1}$보다 크거나 같음
- Note: Non-leaf nodes는 그들 사이에 duplicate search-key values를 가지지 않음
- General structure

## Observations about B $^+$-trees
- Inter-node connections이 pointers로 이루어지기 때문에, "logically" 가까운 blocks이 "physically" 가까울 필요는 없음
- B $^+$-tree의 non-leaf levels은 hierarchy of sparse indices를 형성
- B $^+$-tree는 상대적으로 small number of levels을 포함
  - Root 아래 레벨은 at least $2 \cdot \lceil n/2 \rceil$ values
  - 다음 레벨은 at least $2 \cdot \lceil n/2 \rceil \cdot \lceil n/2 \rceil$ values
- 파일에 $K$개의 search-key values가 있는 경우, tree height는 $\lceil \log_{\lceil n/2 \rceil}(K) \rceil$를 초과하지 않음
  - 따라서 searches가 효율적으로 수행될 수 있음
- Index가 logarithmic time으로 재구성될 수 있으므로, main file에 대한 insertions 및 deletions도 효율적으로 처리될 수 있음

## Queries on B $^+$-Trees: Point Query

```
function find(v)
1. Set C = root node
2. while(C is not a leaf node) begin
   Let i = smallest number s.t. v ≤ C.Ki
   if there is no such number i then
      /* v is larger than every key in C */
      Set C = the node pointed by the last non-null pointer in C
   else if(v = C.Ki ) Set C = C.Pi +1
   else set C = C.Pi /* v < C.Ki */
   end
   /* Now, C is a leaf node */
3. if for some i, Ki = v then return C.Pi
4. else return null /* no record with search-key value v exists */
```

## Queries on B $^+$-Trees: Range Query
- Range queries: 주어진 범위 내의 search key 값을 가진 all records를 찾음
- `function findRange(lb, ub)`는 $\text{lb} \le V \le \text{ub}$인 search key value $V$를 가진 모든 레코드 집합을 반환
  1.  $C$=$ \text{lb} $가 나타날 leaf node를 찾음( `find(v)`에서 $C$를 찾는 것과 동일)
  2.  $i~=~C$ 에서 $K_i \ge \text{lb}$인 smallest value
  3.  `while`($K_i \le \text{ub}$)
    - $C.P_i$를 results에 Add
    - $i~=~i~+ 1$(if more records in $C$) or move to the next leaf node setting $i = 1$
- Real implementations은 일반적으로 `next()` 함수를 사용하여 일치하는 레코드를 one at a time 가져오는 iterator interface를 제공

## Queries on B $^+$-Trees: Cost Analysis
- 파일에 $K$개의 search-key values가 있는 경우, 트리의 height는 $\lceil \log_{\lceil n/2 \rceil}(K) \rceil$를 초과하지 않음
- Node는 일반적으로 disk block과 같은 크기, 일반적으로 4KB
- $n$은 일반적으로 약 100
- Search-key size가 12 Bytes인 경우, $n$은 약 200
- 1 million search key values 및 $n=100$인 경우
  - Root에서 leaf까지의 index lookup에 대해 At most $\lceil \log_{50}(1,000,000) \rceil = 4$ nodes accessed
  - 1 million search key values를 가진 balanced binary tree와 비교: 조회 시 약 20 nodes accessed
  - 모든 node access는 disk I/O를 필요로 할 수 있으며, 약 20 milliseconds의 비용이 들기 때문에 위의 차이는 significant
- Index를 traverse한 후, 일치하는 레코드를 fetch 위해 one more(random) I/O가 필요

## Non-Unique Keys
- Search key $a_i$가 not unique, 대신 unique한 composite key $(a_i, A_{\text{pp}})$에 대한 인덱스를 생성
  - $A_{\text{pp}}$는 primary key, record ID 또는 uniqueness를 보장하는 기타 attribute일 수 있음
- Search for $a_i = v$는 composite key에 대한 range search으로 구현 가능
  - Range $(v, -\infty)$ to $(v, +\infty)$
- But more I/O operations이 실제 레코드를 fetch하는 데 필요
  - Index가 clustering인 경우, 모든 access는 sequential
  - Index가 non-clustering인 경우, 각 record access는 I/O operation을 필요로 할 수 있음

## Updates on B $^+$-Trees: Insertion
- Record가 data file에 already added되었다고 가정
  - $P_r$및$v$는 각각 record에 대한 pointer 및 search key value
- search-key value가 나타날 leaf node $L$을 Find
  1. $L$에 room이 있는 경우, $(v, P_r)$ 쌍을 $L$에 insert
  2. 그렇지 않은 경우, node를 split$ 엔트리를 포함하여)
    - Splitting a leaf node $L$:
      - 정렬된 순서로 $n$개의(search-key, pointer) 쌍을 취함. 첫 번째 $\lceil n/2 \rceil$를 original node $(L)$에 배치하고, 나머지를 new node $(L')$에 배치
      - $k$를 $L'$의 least key value라고 함. $(k, L')$를 split되는 node의 parent에 insert
    - Parent가 full, parent를 split하고 split을 더 위로 propagate
    - Splitting of nodes는 full이 아닌 node를 찾을 때까지 위로 진행
    - 최악의 경우 root node가 split되어 트리의 height가 1 increase할 수 있음
- Splitting a non-leaf node: 이미 full인 internal node $N$에 $(k, L')$를 삽입할 때
  - $N$을 $n+1$ pointers와 $n$ keys를 위한 공간이 있는 in-memory area $M$으로 Copy
  - $(k,~L')$를 $M$에 Insert
  - $M$에서 $P_1, K_1, \dots, K_{\lceil(n+1)/2 \rceil-1}, P_{\lceil(n+1)/2 \rceil}$를 다시 node $N$으로 Copy
  - $M$에서 $P_{\lceil(n+1)/2 \rceil+1}, K_{\lceil(n+1)/2 \rceil+1}, \dots, K_n, P_{n+1}$를 새로 할당된 node $N'$으로 Copy
  - $(K_{\lceil(n+1)/2 \rceil}, N')$를 $N$의 parent에 Insert
  - Note: leaf node를 split하는 것과는 달리, search-key는 'copied'되지 않고 parent node로 'moved'됨(i.e., no duplication\!)

## Updates on B $^+$-Trees: Deletion
- Record가 file에서 already deleted되었다고 가정. $v$는 record의 search key value이고, $P_r$은 record에 대한 pointer
- $(P_r, v)$를 leaf node에서 Remove
- If leaf node가 제거로 인해 too few entries($< \lceil(n-1)/2 \rceil$)를 가지고, node의 entries와 sibling의 entries가 single node($\le n-1$)에 fit, merge siblings
  - 두 node의 모든 entries를 left node에 Insert하고 다른 node를 delete
  - 삭제된 node를 가리키는 pointer가 $P_i$인 경우, 쌍 $(K_{i-1}, P_i)$를 그 parent로부터 recursively delete
- Otherwise, node가 제거로 인해 too few entries를 가지고, node의 entries와 sibling의 entries가 single node에 fit하지 않는 경우, redistribute pointers
  - Node와 sibling 사이에 pointers를 redistribute하여 둘 다 minimum number of entries($\ge \lceil(n-1)/2 \rceil$)보다 more 가지도록 함
  - Node의 parent에서 corresponding search-key value를 Update
- Node deletions는 삭제 후 $\lceil n/2 \rceil$개 이상의 pointers를 가진 node를 찾을 때까지 cascade upwards될 수 있음
- Root node가 삭제 후 only one pointer만 가지는 경우, deleted되고 sole child가 root가 됨

## Complexity of B $^+$-Tree Updates
- Insertion 및 deletion of a single entry의 Cost는 트리의 height에 proportional
- $K$개의 entries와 최대 fanout $n$이 있는 경우, entry의 insert/delete의 worst-case complexity는 $O(\log_{\lceil n/2 \rceil}(K))$
- In practice, I/O 작업 수는 less
  - Internal nodes는 buffer에 있는 경향이 있음
  - Splits/merges는 rare, 대부분의 insert/delete 작업은 only affect a leaf node
- Average node occupancy는 insertion order에 depends on
  - Random insertion 시 $\ge 2/3$
  - Sorted order로 삽입 시 $1/2$

## B $^+$-Tree File Organization
- B $^+$-Tree 'File' Organization
  - B $^+$-tree file organization의 Leaf nodes는 pointers 대신 records를 저장
  - Insertion/deletion/updates가 있을 때도 data records를 clustered된 상태로 유지하는 데 도움 $\to$ data file degradation problem(overflow blocks) 해결
  - Leaf nodes는 여전히 half full 상태가 요구됨
  - Records가 pointers보다 크기 때문에, leaf node에 저장할 수 있는 records의 maximum number는 non-leaf node의 pointers 수보다 less
  - Good space utilization이 중요
    - Splits 및 merges 동안 redistribution에 more sibling nodes를 포함시킴
    - Redistribution에 2 siblings를 포함시키면, 각 node는 at least $\lfloor 3n/4 \rfloor$ entries를 가지게 됨
  - Insertion 및 deletion은 B $^+$-tree index에서 entries의 insertion 및 deletion과 동일한 방식으로 처리

## B-Tree Index Files
- B $^+$-tree와 유사하지만, B-tree는 search-key values가 only once 나타나도록 허용. Redundant storage of search keys를 제거
- Non-leaf nodes의 search keys는 B-tree의 어디에도 나타나지 않음. Non-leaf node의 각 search key에 대해 additional pointer field가 포함되어야 함
- Generalized B-tree leaf node
- Non-leaf node: pointers $B_i$는 bucket 또는 file record pointers
- Advantages of B-Tree indices
  - Corresponding B $^+$-Tree보다 May use less tree nodes
  - 때때로 leaf node에 도달하기 전에 search-key value를 find
- Disadvantages of B-Tree indices
  - Only small fraction의 search-key values만 일찍 발견됨
  - Non-leaf nodes는 larger, fan-out이 reduced $\to$ B-Trees는 일반적으로 corresponding B $^+$-Tree보다 greater depth를 가짐
  - Insertion 및 deletion이 B $^+$-Trees보다 more complicated
  - Implementation이 B $^+$-Trees보다 harder
  - Typically, B-Trees의 장점은 단점보다 out weigh

## Other Issues in Indexing
- Record relocation and secondary indices
  - Record가 moves하면, record pointers를 저장하는 all secondary indices가 have to be updated
  - $\to$ B $^+$-tree file organizations에서 leaf node splits가 very expensive
  - Solution: secondary index에서 record pointer 대신 B $^+$-tree file organization의 search key를 사용
    - Record를 찾기 위해 file organization의 Extra traversal
    - Queries에 대한 Higher cost, but node splits are cheap
- Indexing strings
  - Variable length strings as keys
    - Variable fanout
    - Pointers의 수가 아닌 space utilization을 splitting의 criterion으로 사용
    - Prefix compression
      - Internal nodes의 key values는 prefixes of full key일 수 있음 $\to$ fanout increases
      - Key value로 분리된 subtrees의 entries를 distinguish하기에 충분한 문자를 유지
      - E.g., "Silas"와 "Silberschatz"는 "Silb"로 분리될 수 있음

## Other Issues in Indexing: Bulk Loading & Bottom-Up Build
- Entries를 one-at-a-time B $^+$-tree에 삽입하면 entry당 $\ge 1$가 필요할 수 있음
  - 최악의 경우, 트리의 height에 비례
  - A large number of entries를 한 번에 삽입하는 경우) very inefficient
  - B $^+$-tree index가 large relation에 구축될 때 bulk loading이 필요
- Efficient alternative 1
  - Efficient external sorting algorithms을 사용하여 index entries를 Sort
  - Insert in sorted order
  - 특정 leaf node로 가는 모든 entries는 consecutively 나타남 $\to$ leaf node는 only once written out하면 됨
  - Much improved IO performance, but most leaf nodes half full
- Efficient alternative 2: Bottom-up B $^+$-tree construction
  - 이전과 같이 entries를 sort
  - 그리고 leaf level부터 시작하여 layer-by-layer tree를 create
  - 정렬된 entries를 block에 fit할 수 있는 만큼 많은 entries를 유지하면서 blocks로 Break up $\to$ resulting blocks이 leaf level을 형성
  - 각 block의 minimum value와 block에 대한 pointer는 next level의 entries를 생성하는 데 사용
  - Most database systems에서 bulk-load utility의 일부로 구현

## Hash Indices
- Bucket: $\ge 1$ index entries를 포함하는 storage unit
- Entry의 search-key value에서 hash function을 사용하여 entry의 bucket을 Obtain
- Hash function $h$: 모든 search-key values 집합 $K$에서 모든 bucket addresses 집합 $B$로의 함수
- Hash function은 access, insertion, deletion을 위한 entries를 locate 사용
- Different search-key values를 가진 entries는 same bucket에 매핑될 수 있음. 따라서 entry를 찾기 위해 entire bucket을 sequentially searched해야 함

## Static Hashing
- In a hash index, buckets은 records에 대한 pointers를 가진 entries를 저장(i.e., buckets store index entries)
- In a hash file-organization, buckets은 records를 저장
- Bucket overflow는 다음으로 인해 발생할 수 있음
  - Insufficient buckets
  - Records의 distribution에서의 Skew. 두 가지 이유로 발생 가능
    - Multiple records가 same search-key value를 가짐
    - Chosen hash function이 key values의 non-uniform distribution를 생성
- Bucket overflow의 probability는 줄일 수 있지만, eliminated할 수 없음. overflow buckets을 사용하여 처리

## Hash Functions
- Hash functions은 uniform and random이 요구됨
- Uniform: 각 bucket에 all theoretically possible values 집합에서 same number의 search-key values가 할당됨
- Random: 각 bucket은 파일 내 search-key values의 actual distribution에 irrespective, same number의 entries가 할당됨
- Typical hash functions는 search-key의 internal binary representation에 대한 computation을 수행
  - E.g., string search-key의 경우, string의 모든 characters의 binary representations를 added하고, sum modulo the number of buckets를 returned

## Handling of Bucket Overflows
- Overflow chaining: 주어진 bucket의 overflow buckets은 linked list로 chained together
- Overflow chaining을 사용하는 Hash indexing: closed addressing)
- Overflow buckets을 사용하지 않는 alternative인 open addressing)은 database applications에 not suitable

## Deficiencies of Static Hashing
- Static hashing에서, 함수 $h$는 search-key values를 fixed set($B$)의 bucket addresses로 매핑. Databases는 시간이 지남에 따라 grow or shrink
  - Initial number of buckets가 too small이고, 파일이 grows, too much overflows로 인해 성능이 degrade됨
  - Anticipated growth을 위해 space가 할당되면, initially 상당한 양의 space가 wasted됨)
  - Database가 shrinks, again space가 wasted됨
- One solution
  - New hash function으로 파일의 Periodic re-organization
  - Expensive, disrupts normal operations
- Better solution: Dynamic Hashing
  - Buckets의 number를 dynamically modify할 수 있는 Techniques
  - Size가 grows and shrinks하는 database에 Good
  - Hash function을 dynamically modify할 수 있도록 Allows
  - Extendable hashing: 동적 해싱의 한 형태

## Comparison of Ordered Indexing and Hashing
- Periodic re-organization의 Cost
- Insertions and deletions의 Relative frequency
- Is it desirable to optimize average access time at the expense of worst-case access time?
- Expected type of queries
  - Hashing은 일반적으로 key의 specified value를 가진 records를 retrieving하는 데 better
  - Range queries가 common, ordered indices가 preferred
- In practice
  - PostgreSQL은 hash indices를 지원하지만, poor performance로 인해 discourages use
  - Oracle은 static hash organization을 지원하지만, not hash indices
  - SQLServer는 only B $^+$-trees를 지원