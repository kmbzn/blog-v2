# 19. Recovery System

## Failure Classification
- Transaction 실패
  - Logical errors: 내부 오류 조건으로 인해 Transaction이 완료될 수 없는 상황
  - System errors: Deadlock 등의 오류 조건으로 인해 데이터베이스 시스템이 활성 Transaction을 종료해야 하는 상황
- System crash
  - 전원 실패 또는 기타 하드웨어/소프트웨어 실패로 인한 시스템 붕괴
  - **Fail-stop assumption**: 비휘발성 저장 장치 내용은 System crash로 인해 손상되지 않는다고 가정
- Disk failure
  - Head crash나 유사한 디스크 오류로 인해 저장소의 일부 또는 전체가 파괴됨
  - Checksum을 사용하여 파괴 여부 감지 가능 가정

## Data Access
- Physical blocks: 디스크에 상주하는 블록
- Buffer blocks: 메인 메모리에 일시적으로 상주하는 블록
- 디스크와 메인 메모리 간의 Block 이동을 시작하는 두 가지 연산
  - $\text{input}(B)$: 물리적 블록 $B$를 메인 메모리로 전송
  - $\text{output}(B)$: 버퍼 블록 $B$를 디스크로 전송 및 해당 물리적 블록 교체
- 단순화를 위해 각 데이터 아이템은 단일 블록 내에 적재 및 저장된다고 가정
- 각 Transaction $T_i$는 접근 및 업데이트하는 모든 데이터 아이템의 로컬 복사본을 유지하는 Private work-area 보유

![alt text](image-17.png)
  - $\text{read}(X)$: 데이터 아이템 $X$를 로컬 변수 $x_i$에 할당
  - $\text{write}(X)$: 로컬 변수 $x_i$ 값을 버퍼 블록의 $X$에 할당
  - $\text{write}(X)$ 실행 후 즉시 $\text{output}(B_X)$가 수행될 필요는 없음

## Recovery Algorithms
- Transaction의 Atomicity(원자성)와 Durability(지속성) 보장 필요
  - Atomicity: Commit되지 않은 transaction의 실패가 데이터베이스를 일관성 없는 상태로 만드는 것을 방지
  - Durability: Commit된 transaction의 업데이트가 디스크에 출력되기 전 실패하는 경우(Lost updates)를 방지
- Recovery 알고리즘의 두 가지 파트
    1. 정상 처리 중 조치: 복구를 위한 충분한 정보 저장(Logging)
    2. 실패 후 조치: Atomicity, Consistency, Durability 보장을 위한 데이터베이스 복구(Recovery)

## Recovery and Atomicity
- Log-based recovery 메커니즘 (주요 학습 내용)
  - 데이터베이스 자체를 수정하기 전 수정 사항에 대한 정보를 Stable storage에 출력
- Shadow-copy 및 Shadow-paging (대안적 방법, 소규모 데이터베이스용)

## Log-based Recovery
- Log: 데이터베이스 업데이트 활동 정보를 담은 레코드의 시퀀스 (Stable storage에 유지)
- 주요 로그 레코드
  - $<T_i ~ \text{start}>$: Transaction 시작 시 기록
  - $<T_i, ~ X, ~ V_1, ~ V_2>$: 업데이트 시 기록 ($V_1$: 이전 값, $V_2$: 새 값)
  - $<T_i ~ \text{commit}>$: Transaction 완료 시 기록
- 두 가지 접근 방식
  - Immediate database modification
  - Deferred database modification

## Database Modification Schemes
- Immediate-modification (즉시 수정)
  - Transaction commit 전에도 데이터베이스 수정 허용
  - 데이터베이스 수정 전 업데이트 로그 레코드 작성 필수
- Deferred-modification (지연 수정)
  - Transaction commit 시점에만 데이터베이스 수정 수행
  - 복구의 일부 측면을 단순화하지만 로컬 복사본 저장 오버헤드 존재

## Concurrency Control and Recovery
- 다중 Transaction 환경
  - 단일 디스크 버퍼와 단일 로그 공유
- Strict two-phase locking
  - Transaction이 commit 또는 abort 될 때까지 수정된 아이템에 대한 X-lock 유지
  - Commit되지 않은 transaction의 업데이트가 타 Transaction에 보이지 않도록 제어

## Undo and Redo Operations
- undo(Ti)
  - $T_i$에 의해 변경된 모든 데이터 아이템을 이전 값으로 복구 (로그 역방향 스캔)
  - 복구 시 redo-only 로그 레코드 $<T_i, ~ X, ~ V>$ 작성 (Compensation log record)
  - 완료 시 $<T_i ~ \text{abort}>$ 기록
- redo(Ti)
  - $T_i$에 의해 변경된 모든 데이터 아이템을 새 값으로 설정 (로그 정방향 스캔)
  - 별도의 로깅 수행 안 함

## Recovering from Failure
- 실패 복구 시나리오
  - undo 대상: 로그에 $<T_i ~ \text{start}>$는 있으나 $<T_i ~ \text{commit}>$ 또는 $<T_i ~ \text{abort}>$가 없는 경우
  - redo 대상: 로그에 $<T_i ~ \text{start}>$와 함께 $<T_i ~ \text{commit}>$ 또는 $<T_i ~ \text{abort}>$가 있는 경우
- Repeating history (이력 반복)
  - 이전에 undo된 transaction이라도 다시 redo 수행 (모든 원래 작업 재실행) 후 undo 진행
  - 복구 과정을 단순화

## Checkpoints
- 로그 전체 처리의 비효율성 개선을 위해 주기적 Checkpoint 수행
- Checkpoint 과정
    1. 메인 메모리의 모든 로그 레코드를 Stable storage로 출력
    2. 변경된 모든 버퍼 블록을 디스크로 출력
    3. Stable storage에 로그 레코드 $<checkpoint ~ L>$ 기록 ($L$: 활성 Transaction 목록)
- 복구 시 최신 $<checkpoint ~ L>$ 레코드부터 역방향 스캔하여 불필요한 연산 생략

## Recovery Algorithm
- 정상 작동 시 (Normal operation)
  - Logging: 시작, 업데이트, 종료 시 로그 기록
  - Transaction rollback: 로그 역방향 스캔 후 undo 수행 및 보상 로그 레코드(CLR) 작성
- 실패 복구 시 (Two phases)
    1. Redo phase: 모든 Transaction의 업데이트 재실행 및 undo-list 작성
    2. Undo phase: undo-list에 있는 불완전한 Transaction 역방향 롤백 수행

## Buffer Management
- Log Record Buffering
  - 로그 레코드를 메인 메모리에 버퍼링 후 블록 단위 출력 또는 Log force 시 출력
  - Write-Ahead Logging (WAL): 데이터 블록이 디스크로 출력되기 전, 관련 로그 레코드가 먼저 Stable storage에 출력되어야 함
- Database Buffering 정책
  - No-force policy: Transaction commit 시 업데이트된 블록을 강제로 디스크에 쓰지 않음 (Redo 필요성)
  - Steal policy: commit 되지 않은 transaction의 업데이트도 디스크에 기록 허용 (Undo 필요성, WAL 필수)
- Latches
  - 블록을 디스크로 출력하는 동안 업데이트가 발생하지 않도록 짧은 기간 동안 획득하는 배타적 락(Exclusive latch) 사용