# 3. SQL

## SQL Parts

  * DDL (Data Definition Language, 데이터 정의어)
      * 데이터베이스 스키마(schema) 정의 수단 제공
  * DML (Data Manipulation Language, 데이터 조작어)
      * 데이터베이스 정보 질의 및 튜플(tuple) 삽입, 삭제, 수정 기능 제공
  * Integrity (무결성)
      * DDL은 무결성 제약 조건(integrity constraints) 명시 명령어 포함
  * View definition (뷰 정의)
      * DDL은 뷰(view) 정의 명령어 포함
  * Transaction control (트랜잭션 제어)
      * 트랜잭션(transaction)의 시작과 끝을 명시하는 명령어 포함
  * Embedded SQL and dynamic SQL (embedded SQL 및 동적 SQL)
      * 범용 프로그래밍 언어 내에 SQL 문장을 삽입하는 방법 정의
  * Authorization (권한 부여)
      * 관계(relation) 및 뷰에 대한 접근 권한 명시 명령어 포함

## Data Definition Language

  * SQL DDL은 관계에 대한 정보 명시 허용, 다음 포함:
      * 각 관계의 스키마
      * 각 속성(attribute)과 관련된 값의 유형
      * 무결성 제약 조건
      * 각 관계에 대해 유지될 인덱스(index) 집합
      * 각 관계에 대한 보안 및 권한 정보
      * 디스크 상의 각 관계에 대한 물리적 저장 구조

## DDL: Domain Types in SQL

  * `char(n)`: 사용자 지정 길이 $n$의 고정 길이 문자열
  * `varchar(n)`: 사용자 지정 최대 길이 $n$의 가변 길이 문자열
  * `int`: 정수 (기계에 의존하는 정수의 유한 부분 집합)
  * `smallint`: 작은 정수 (정수 도메인 유형의 기계 의존적 부분 집합)
  * `numeric(p,d)`: $p$자리의 사용자 지정 정밀도와 소수점 이하 $d$자리를 가진 고정 소수점 숫자 (예: `numeric(3,1)`은 44.5는 정확히 저장 가능하나, 444.5나 0.32는 불가)
  * `real`, `double precision`: 기계 의존적 정밀도를 가진 부동 소수점 및 배정밀도 부동 소수점 숫자
  * `float(n)`: 최소 $n$자리의 사용자 지정 정밀도를 가진 부동 소수점 숫자
  * 추가적인 내용은 4장에서 다룸

## DDL: Create Table Construct

  * SQL 관계는 `create table` 명령어를 사용하여 정의:
      * `create table r (A1 D1, A2 D2, ..., An Dn, (integrity-constraint1), ..., (integrity-constraintk));`
  * $r$은 관계의 이름
  * 각 $A_i$는 관계 $r$의 스키마에 있는 속성 이름
  * $D_i$는 속성 $A_i$의 도메인(domain)에 있는 값의 데이터 유형
  * 예시:
    ```sql
    create table instructor(
        ID        char(5),
        name      varchar(20),
        dept_name varchar(20),
        salary    numeric(8,2)
    );
    ```

## DDL: Integrity Constraints in Create Table

  * 무결성 제약 조건의 유형
      * `primary key(A1, ..., An)`
          * 이 관계의 모든 튜플은 서로 다른 기본 키 값을 가져야 함
          * 위의 Primary-key constraint (기본 키 제약 조건) 강제
      * `foreign key (Am, ..., An) references r`
          * Foreign-key constraint (외래 키 제약 조건) 강제
      * `not null`
          * 이 속성이 NULL 값을 가질 수 없도록 강제
  * SQL은 무결성 제약 조건을 위반하는 데이터베이스 업데이트 방지
  * 예시:
    ```sql
    create table instructor(
        ID        char(5),
        name      varchar(20) not null,
        dept_name varchar(20),
        salary    numeric(8,2),
        primary key (ID),
        foreign key (dept_name) references department
    );
    ```

## Updates to tables

  * Insert
      * `insert into instructor values('10211', 'Smith', 'Biology', 66000);`
  * Delete
      * `student` 관계에서 모든 튜플 제거
      * `delete from student;`
  * Drop Table
      * `drop table r;`
  * Alter
      * `alter table r add A D;`
          * 여기서 $A$는 관계 $r$에 추가될 속성의 이름이고 $D$는 $A$의 도메인
          * 관계의 모든 기존 튜플은 새 속성에 대해 `null` 값으로 할당됨
      * `alter table r drop A;`
          * 여기서 $A$는 관계 $r$의 속성 이름
          * 속성 삭제는 많은 데이터베이스에서 지원하지 않음

## Basic Query Structure

  * 일반적인 SQL 질의 형태:
      * `select A1, A2, ..., An from r1, r2, ..., rm where P;`
  * $A_i$는 속성을 나타냄
  * $r_i$는 관계를 나타냄
  * $P$는 술어(predicate)
  * 대응하는 관계 대수(relational algebra)
    $$
    \Pi _{A_1, A_2, \dots, A_n}(\sigma\_P(r_1 \times r_2 \times \dots \times r_m))
    $$
  * SQL 질의의 결과는 관계

## The select Clause

  * `select` 절은 질의 결과에서 원하는 속성을 나열
  * 관계 대수의 프로젝션(projection) 연산에 해당
  * 예시: 모든 강사의 이름 찾기
      * `select name from instructor;`
  * 참고: SQL 이름은 대소문자를 구분하지 않음 (예: `Name` $\equiv$ `NAME` $\equiv$ `name`)
  * SQL은 관계뿐만 아니라 질의 결과에서도 중복을 허용
  * 중복 제거를 강제하려면 `select` 뒤에 `distinct` 키워드 삽입
      * 모든 강사의 학과 이름을 찾고 중복 제거
      * `select distinct dept_name from instructor;`
  * `all` 키워드는 중복이 제거되지 않아야 함을 명시
      * `select all dept_name from instructor;`
  * `select` 절의 별표(`*`)는 "모든 속성"을 의미
      * `select * from instructor;`
      * `select instructor.* from instructor, teaches;`
  * 속성은 `from` 절 없이 리터럴(literal)이 될 수 있음
      * `select '437';`
      * 결과는 "437" 값을 가진 단일 행과 하나의 열을 가진 테이블
  * 다음을 사용하여 열에 이름 부여 가능:
      * `select '437' as FOO;`
  * 속성은 `from` 절과 함께 리터럴이 될 수 있음
      * `select 'A' from instructor;`
      * 결과는 하나의 열과 $N$개의 행(`instructor` 테이블의 튜플 수)을 가진 테이블이며, 각 행의 값은 "A"
  * `select` 절은 `+`, `-`, `*`, `/` 연산을 포함하는 산술 표현식을 포함할 수 있으며, 상수 또는 튜플의 속성에 대해 연산
  * 질의: `select ID, name, dept_name, salary/12 from instructor;`
      * `instructor` 관계와 동일하지만 `salary` 속성 값이 12로 나누어진 관계를 반환
      * 일반화된 프로젝션 연산에 해당
  * `as` 절을 사용하여 "salary/12"의 이름 변경 가능:
      * `select ID, name, dept_name, salary/12 as monthly_salary;`

## The where Clause

  * `where` 절은 결과가 만족해야 하는 조건을 명시
  * 관계 대수의 선택(selection) 술어에 해당
  * 컴퓨터 공학(Comp. Sci.)과의 모든 강사 찾기
      * `select name from instructor where dept_name = 'Comp. Sci.';`
  * SQL은 논리적 연결사 `and`, `or`, `not` 사용을 허용
  * 논리적 연결사의 피연산자는 비교 연산자 `<`, `<=`, `>`, `>=`, `=`, `<>`를 포함하는 표현식이 될 수 있음
  * 비교는 산술 표현식의 결과에 적용 가능
  * 급여가 70000보다 큰 컴퓨터 공학과의 모든 강사 찾기
      * `select name from instructor where dept_name = 'Comp. Sci.' and salary > 70000;`

## The from Clause

  * `from` 절은 질의에 관련된 관계를 나열
  * 관계 대수의 카티전 프로덕트(Cartesian product) 연산에 해당
  * `instructor` $\times$ `teaches`의 카티전 프로덕트 찾기
      * `select * from instructor, teaches;`
  * 가능한 모든 `instructor-teaches` 쌍을 생성하며, 두 관계의 모든 속성을 포함
  * 공통 속성(예: `ID`)의 경우, 결과 테이블의 속성은 관계 이름을 사용하여 이름이 변경됨 (예: `instructor.ID`)
  * 카티전 프로덕트는 직접적으로는 그다지 유용하지 않지만, `where` 절 조건(관계 대수의 선택 연산)과 결합하면 유용

## Examples

  * 어떤 과목을 가르친 모든 강사의 이름과 `course_id` 찾기
      * `select name, course_id from instructor, teaches where instructor.ID = teaches.ID;`
  * 예술(Art) 학과에서 어떤 과목을 가르친 모든 강사의 이름과 `course_id` 찾기
      * `select name, course_id from instructor, teaches where instructor.ID = teaches.ID and instructor.dept_name = 'Art';`
  * SQL은 중복을 허용함

## The Rename Operation

  * SQL은 `as` 절을 사용하여 관계와 속성의 이름 변경을 허용:
      * `old-name as new-name`
  * 만약 `new-name`이 속성이 아닌 관계를 위한 것이라면, '상관 이름(correlation name)'(SQL 표준), '테이블 별칭(table alias)', '상관 변수(correlation variable)' 또는 '튜플 변수(tuple variable)'라고 불림
  * 'Comp. Sci.'에 있는 어떤 강사보다 높은 급여를 받는 모든 강사의 이름 찾기:
      * `select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name = 'Comp. Sci.';`
  * `as` 키워드는 선택 사항이며 생략 가능 (`instructor as T` $\equiv$ `instructor T`)

## String Operations

  * SQL은 문자열 비교를 위한 문자열 매칭 연산자 `like`를 포함하며, 두 개의 특수 문자를 사용한 패턴을 이용:
      * 퍼센트 (`%`): 모든 하위 문자열과 일치
      * 밑줄 (`_`): 모든 단일 문자와 일치
  * 이름에 "dar" 하위 문자열을 포함하는 모든 강사의 이름 찾기
      * `select name from instructor where name like '%dar%';`
  * 문자열 "100%"와 일치시키기
      * `like '100\%' escape '\'`
      * 위 예시에서 백슬래시(`\`)를 이스케이프 문자로 사용 (다른 어떤 문자도 이스케이프 문자로 사용 가능)
  * 패턴은 대소문자를 구분
  * 패턴 매칭 예시:
      * `'Intro%'`: "Intro"로 시작하는 모든 문자열과 일치
      * `'%Comp%'`: "Comp"를 하위 문자열로 포함하는 모든 문자열과 일치
      * `'_ _ _'`: 정확히 세 문자로 된 모든 문자열과 일치
      * `'_ _ _ %'`: 최소 세 문자로 된 모든 문자열과 일치
  * SQL은 다양한 문자열 연산 지원
      * 연결 (`||` 사용)
      * 대소문자 변환
      * 문자열 길이 찾기, 하위 문자열 추출 등

## Ordering the Display of Tuples

  * 모든 강사의 이름을 알파벳 순으로 나열
      * `select distinct name from instructor order by name;`
  * 각 속성에 대해 내림차순은 `desc`, 오름차순은 `asc`를 명시 가능하며, 오름차순이 기본값
      * 예시: `order by name desc`
  * 여러 속성에 대해 정렬 가능
      * 예시: `order by dept_name desc, name asc`

## Where Clause Predicates

  * SQL은 `between` 비교 연산자를 포함
  * 예시: 급여가 $90,000에서 $100,000 사이인 모든 강사의 이름 찾기 (즉, $\ge$ $90,000 이고 $\le$ $100,000$)
      * `select name from instructor where salary between 90000 and 100000;`
  * 튜플 비교
      * `select name, course_id from instructor, teaches where (instructor.ID, dept_name) = (teaches.ID, 'Biology');`
  * 위는 아래와 동일
      * `select name, course_id from instructor, teaches where instructor.ID = teaches.ID and dept_name = 'Biology';`

## Set Operations

  * 집합 연산 `union`, `intersect`, `except`
  * 각 연산은 자동으로 중복을 제거
  * 모든 중복을 유지하려면 `union all` (또는 `intersect all` 혹은 `except all`) 사용
  * 2017년 가을 또는 2018년 봄에 개설된 과목 찾기
      * `(select course_id from section where sem = 'Fall' and year = 2017) union (select course_id from section where sem = 'Spring' and year = 2018);`
  * 2017년 가을과 2018년 봄에 모두 개설된 과목 찾기
      * `(select course_id from section where sem = 'Fall' and year = 2017) intersect (select course_id from section where sem = 'Spring' and year = 2018);`
  * 2017년 가을에는 개설되었지만 2018년 봄에는 개설되지 않은 과목 찾기
      * `(select course_id from section where sem = 'Fall' and year = 2017) except (select course_id from section where sem = 'Spring' and year = 2018);`

## Aggregate Functions

  * 이 함수들은 관계 내 값들의 컬렉션(집합 또는 다중 집합)에 대해 작동하며 단일 값을 반환
      * `avg`: 평균값 (숫자 값에만 해당)
      * `min`: 최솟값 (숫자 및 비숫자 값 모두 해당)
      * `max`: 최댓값 (숫자 및 비숫자 값 모두 해당)
      * `sum`: 값의 합계 (숫자 값에만 해당)
      * `count`: 값의 개수 (숫자 및 비숫자 값 모두 해당)
  * SQL에서 `count`를 제외한 집계 함수(aggregate functions)는 `null` 값을 무시
  * `null` 값이 무시된 결과로 값들의 컬렉션이 비어 있을 수 있음
  * 모든 집계 함수(`count` 제외)는 빈 컬렉션에 적용될 때 `null`을 반환 (빈 컬렉션의 `count`는 0으로 정의됨)
  * `count` 함수는 다른 `non-null` 값처럼 모든 `null` 값을 계산

## Aggregate Functions Examples

  * 컴퓨터 과학 학과 강사들의 평균 급여 찾기
      * `select avg(salary) from instructor where dept_name = 'Comp. Sci.';`
  * 2018년 봄 학기에 과목을 가르치는 총 강사 수 찾기
      * `select count(distinct ID) from teaches where semester = 'Spring' and year = 2018;`
  * `course` 관계의 튜플 수 찾기
      * `select count(*) from course;`

## Aggregate Functions – Group By

  * `group by` 절을 사용하여 단일 튜플 집합이 아닌, 그룹화된 여러 튜플 집합에 개별적으로 집계 함수 적용 가능
  * 각 학과의 강사 평균 급여 찾기
      * `select dept_name, avg(salary) as avg_salary from instructor group by dept_name;`
  * `group by` 절 사용 시, 각 그룹당 하나의 튜플만 출력됨

## Aggregation

  * 집계 함수 외의 `select` 절에 있는 속성들은 `group by` 목록에 나타나야 함
      * `/* erroneous query */`
      * `select dept_name, ID, avg(salary) from instructor group by dept_name;`
  * 특정 그룹(`dept_name`으로 정의됨)의 각 강사는 다른 ID를 가질 수 있지만, 각 그룹에 대해 하나의 튜플만 출력됨

## Aggregate Functions – Having Clause

  * `having` 절을 사용하여 출력될 각 그룹에 대한 조건 명시 가능
  * `having` 절의 술어는 그룹 형성 후에 적용되는 반면, `where` 절의 술어는 그룹 형성 전에 적용됨
  * 평균 급여가 42000보다 큰 모든 학과의 이름과 평균 급여 찾기
    ```sql
    select dept_name, avg(salary) as avg_salary
    from instructor
    group by dept_name
    having avg(salary) > 42000;
    ```
  * 평가 순서
    1.  `from` 절이 먼저 평가됨
    2.  `where` 절의 술어(존재 시)가 `from` 절의 결과에 적용됨
    3.  `where` 술어를 만족하는 튜플들이 `group by` 절에 의해 그룹으로 배치됨
    4.  `having` 절(존재 시)이 각 그룹에 적용됨; `having` 절 술어를 만족하지 않는 그룹들은 제거됨
    5.  `select` 절은 남은 그룹들을 사용하여, 집계 함수(존재 시)를 적용한 후 각 그룹에 대한 단일 결과 튜플을 얻음

## Nested Subqueries

  * SQL은 서브쿼리(subquery)의 중첩 메커니즘 제공
  * 서브쿼리는 다른 쿼리 내에 중첩된 `select-from-where` 표현식
  * 중첩은 다음 SQL 쿼리에서 수행될 수 있음: `select A1, A2, ..., An from r1, r2, ..., rm where P`
  * 다음과 같이:
      * `from` 절: $r_i$는 유효한 서브쿼리로 대체 가능
      * `where` 절: $P$는 `B <operation> (subquery)` 형태의 표현식으로 대체 가능. 여기서 $B$는 속성
      * `select` 절: $A_i$는 단일 값을 생성하는 서브쿼리(스칼라 서브쿼리, scalar subquery)로 대체 가능

## Nested Subqueries: Set Membership

  * 2017년 가을과 2018년 봄에 제공된 과목 찾기
    ```sql
    select distinct course_id
    from section
    where semester = 'Fall' and year = 2017 and
          course_id in (select course_id
                        from section
                        where semester = 'Spring' and year = 2018);
    ```
  * 2017년 가을에는 제공되었지만 2018년 봄에는 제공되지 않은 과목 찾기
    ```sql
    select distinct course_id
    from section
    where semester = 'Fall' and year = 2017 and
          course_id not in (select course_id
                            from section
                            where semester = 'Spring' and year = 2018);
    ```
  * 이름이 "Mozart"도 "Einstein"도 아닌 모든 강사 이름 지정
      * `select distinct name from instructor where name not in ('Mozart', 'Einstein');`
  * ID가 10101인 강사가 가르친 과목 섹션을 수강한 (고유한) 학생들의 총 수 찾기
    ```sql
    select count(distinct ID)
    from takes
    where (course_id, sec_id, semester, year) in (select course_id, sec_id, semester, year
                                                  from teaches
                                                  where teaches.ID = '10101');
    ```
      * 참고: 위 쿼리는 훨씬 간단한 방식으로 작성 가능하며, 위 공식은 SQL 기능 설명 목적임

## Nested Subqueries: Set comparison (“some”)

  * 생물학(Biology) 학과에 있는 어떤 (적어도 한 명의) 강사보다 급여가 높은 강사들의 이름 찾기
      * `select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name = 'Biology';`
  * `some` 절을 사용한 동일한 쿼리
      * `select name from instructor where salary > some (select salary from instructor where dept_name = 'Biology');`

## Definition of “some” Clause

  * `F <comp> some r` $\Leftrightarrow \exists t \in r$ بحيث أن $(F <comp> t)$
  * 여기서 `<comp>`는 `<`, `<=`, `>`, `=`, `!=`가 될 수 있음
  * `  (5 < some {0, 5, 6}) ` = `true`
  * `  (5 < some {0, 5, 0}) ` = `false`
  * `  (5 = some {0, 5, 0}) ` = `true`
  * `  (5 != some {0, 5, 5}) ` = `true` (∵ $0 \ne 5$)
  * `(= some)` $\equiv$ `in`
  * `(!= some)`은 `not in`과 동치가 아님

## Nested Subqueries: Set comparison (“all”)

  * 생물학 학과의 모든 강사의 급여보다 더 많은 급여를 받는 모든 강사의 이름 찾기
      * `select name from instructor where salary > all (select salary from instructor where dept_name = 'Biology');`

## Definition of “all” Clause

  * `F <comp> all r` $\Leftrightarrow \forall t \in r (F <comp> t)$
  * `  (5 < all {0, 5, 6}) ` = `false`
  * `  (5 < all {6, 10, 4}) ` = `false`
  * `  (5 = all {4, 5, 6}) ` = `false`
  * `  (5 != all {4, 6}) ` = `true` (∵ $5 \ne 4$ 이고 $5 \ne 6$)
  * `(= all)`은 `in`과 동치가 아님
  * `(!= all)` $\equiv$ `not in`

## Nested Subqueries: Test for Empty Relations

  * `exists` 구문은 인수 서브쿼리가 비어 있지 않으면 `true`를 반환
  * `exists r` $\Leftrightarrow r \ne \emptyset$
  * `not exists r` $\Leftrightarrow r = \emptyset$
  * "2017년 가을 학기와 2018년 봄 학기 모두에 가르친 모든 과목 찾기" 쿼리를 지정하는 또 다른 방법
    ```sql
    select course_id
    from section as S
    where semester = 'Fall' and year = 2017 and
          exists (select *
                  from section as T
                  where semester = 'Spring' and year = 2018 and
                        S.course_id = T.course_id);
    ```
  * SQL에서, 외부 쿼리의 상관 이름(변수 `S`)은 `where` 절의 서브쿼리에서 사용될 수 있음
  * 외부 쿼리의 상관 이름을 사용하는 서브쿼리를 상관 서브쿼리(correlated subquery)라고 함

## Use of “not exists” Clause

  * 생물학 학과에서 제공하는 모든 과목을 수강한 모든 학생 찾기
  * $X - Y = \emptyset \Leftrightarrow X \subseteq Y$ 참고
    ```sql
    select distinct S.ID, S.name
    from student as S
    where not exists ( (select course_id
                        from course
                        where dept_name = 'Biology')
                       except
                       (select T.course_id
                        from takes as T
                        where S.ID = T.ID) );
    ```
  * 첫 번째 중첩 쿼리는 생물학에서 제공하는 모든 과목을 나열
  * 두 번째 중첩 쿼리는 특정 학생이 수강한 모든 과목을 나열

## Nested Subqueries: Test for Absence of Duplicate Tuples

  * `unique` 구문은 서브쿼리 결과에 중복 튜플이 있는지 테스트
  * 주어진 서브쿼리에 중복이 없으면 `true`로 평가됨
  * 2017년에 최대 한 번 제공된 모든 과목 찾기
    ```sql
    select T.course_id
    from course as T
    where unique (select R.course_id
                  from section as R
                  where T.course_id = R.course_id and R.year = 2017);
    ```

## Subqueries in the ‘from’ Clause

  * SQL은 `from` 절에서 서브쿼리 표현식을 사용하도록 허용
  * 평균 급여가 $42,000 이상인 학과들의 강사 평균 급여 찾기
    ```sql
    select dept_name, avg_salary
    from (select dept_name, avg(salary) as avg_salary
          from instructor
          group by dept_name)
    where avg_salary > 42000;
    ```
  * `having` 절을 사용할 필요가 없다는 점에 유의
  * 위 쿼리를 작성하는 또 다른 방법
    ```sql
    select dept_name, avg_salary
    from (select dept_name, avg(salary)
          from instructor
          group by dept_name)
          as dept_avg(dept_name, avg_salary)
    where avg_salary > 42000;
    ```

## Nested Subqueries: ‘With’ Clause

  * `with` 절은 `with` 절이 발생하는 쿼리에서만 정의가 사용 가능한 임시 관계(임시 뷰)를 정의하는 방법 제공
  * 평균 예산보다 더 큰 예산을 가진 모든 학과 찾기
    ```sql
    with avg_budget(value) as
        (select avg(budget) from department)
    select department.name
    from department, avg_budget
    where department.budget > avg_budget.value;
    ```

## Complex Queries using ‘With’ Clause

  * 총 급여가 모든 학과의 총 급여 평균보다 큰 모든 학과 찾기
    ```sql
    with dept_total (dept_name, value) as
        (select dept_name, sum(salary)
         from instructor
         group by dept_name),
    dept_total_avg(value) as
        (select avg(value)
         from dept_total)
    select dept_name
    from dept_total, dept_total_avg
    where dept_total.value > dept_total_avg.value;
    ```

## Nested Subqueries: Scalar Subquery

  * 스칼라 서브쿼리는 단일 값이 예상되는 곳에 사용되는 서브쿼리
  * 스칼라 서브쿼리는 외부 쿼리의 `select` 절에서 사용될 수 있음
  * 각 학과의 강사 수와 함께 모든 학과 나열
    ```sql
    select dept_name,
           (select count(*)
            from instructor
            where department.dept_name = instructor.dept_name)
            as num_instructors
    from department;
    ```
  * 서브쿼리가 하나 이상의 결과 튜플을 반환하면 런타임 오류 발생

## Null Values

  * 튜플이 일부 속성에 대해 `null`로 표시되는 `null` 값을 가질 수 있음
  * `null`은 알 수 없는 값이거나 값이 존재하지 않음을 의미
  * `null`을 포함하는 모든 산술 표현식의 결과는 `null`
  * 집계 함수는 `null` 값을 무시
  * 중복 제거 및 그룹화의 경우, `null`은 다른 값처럼 취급되며, 두 `null`은 동일한 것으로 간주됨
  * `is null` 술어는 `null` 값을 확인하는 데 사용될 수 있음
  * 예시: 급여가 `null`인 모든 강사 찾기
      * `select name from instructor where salary is null;`
  * `is not null` 술어는 적용된 값이 `null`이 아닌 경우 성공
  * SQL은 `null` 값을 포함하는 비교의 결과를 `unknown`으로 처리 (`is null` 및 `is not null` 술어 제외)
  * 예시: `5 < null` 또는 `null <> null` 또는 `null = null`
  * `where` 절의 술어는 불리언(boolean) 연산(`and`, `or`, `not`)을 포함할 수 있으므로, `unknown` 값을 처리하기 위해 불리언 연산의 정의를 확장해야 함
      * `and`: `(true and unknown)` = `unknown`, `(false and unknown)` = `false`, `(unknown and unknown)` = `unknown`
      * `or`: `(unknown or true)` = `true`, `(unknown or false)` = `unknown`, `(unknown or unknown)` = `unknown`
      * `not`: `(not unknown)` = `unknown`
  * SQL에서 `P is unknown`은 술어 `P`가 `unknown`으로 평가되면 `true`로 평가됨
  * `where` 절 술어의 결과는 `unknown`으로 평가되면 `false`로 처리됨

## Modification of the Database

  * 주어진 관계에서 튜플 삭제
  * 주어진 관계에 새 튜플 삽입
  * 주어진 관계의 일부 튜플 값 업데이트

## Deletion

  * 모든 강사 삭제
      * `delete from instructor;`
  * 재무(Finance) 학과의 모든 강사 삭제
      * `delete from instructor where dept_name = 'Finance';`
  * `'ITBT'` 건물에 위치한 학과와 관련된 `instructor` 관계의 모든 튜플 삭제
      * `delete from instructor where dept_name in (select dept_name from department where building = 'ITBT');`
  * 급여가 강사 평균 급여보다 적은 모든 강사 삭제
      * 문제점: `instructor`에서 튜플을 삭제함에 따라 평균 급여가 변경됨
      * SQL의 해결책:
        1.  먼저 `avg(salary)`를 계산하고 삭제할 모든 튜플을 찾음
        2.  위에서 찾은 모든 튜플을 삭제 (평균을 재계산하거나 튜플을 다시 테스트하지 않음)
    <!-- end list -->
    ```sql
    delete from instructor
    where salary < (select avg(salary) from instructor);
    ```

## Insertion

  * `course`에 새 튜플 추가
      * `insert into course values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);`
  * 또는 동등하게
      * `insert into course (course_id, title, dept_name, credits) values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);`
  * `tot_creds`가 `null`로 설정된 새 튜플을 `student`에 추가
      * `insert into student values ('3003', 'Green', 'Finance', null);`
  * 144 학점 이상을 이수한 음악(Music) 학과의 각 학생을 급여 $18,000의 음악 학과 강사로 만듦
      * `insert into instructor select ID, name, dept_name, 18000 from student where dept_name = 'Music' and total_cred > 144;`
  * `student` 관계의 스키마: `(ID, name, dept_name, tot_cred)`
  * `instructor` 관계의 스키마: `(ID, name, dept_name, salary)`
  * `select from where` 문은 그 결과 중 어떤 것이라도 관계에 삽입되기 전에 완전히 평가됨

## Updates

  * 모든 강사에게 5% 급여 인상
      * `update instructor set salary = salary * 1.05;`
  * 70000 미만을 버는 강사에게 5% 급여 인상
      * `update instructor set salary = salary * 1.05 where salary < 70000;`
  * 평균보다 급여가 적은 강사에게 5% 급여 인상
      * `update instructor set salary = salary * 1.05 where salary < (select avg(salary) from instructor);`
  * 급여가 $100,000 이상인 강사의 급여를 3% 인상하고, 나머지는 5% 인상
  * 두 개의 `update` 문 작성 (순서가 중요함):
    ```sql
    update instructor set salary = salary * 1.03 where salary > 100000;
    update instructor set salary = salary * 1.05 where salary <= 100000;
    ```
  * `case` 문을 사용한 더 나은 방법:
    ```sql
    update instructor
    set salary = case
                    when salary <= 100000 then salary * 1.05
                    else salary * 1.03
                 end;
    ```